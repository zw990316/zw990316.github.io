<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>国际化开发解决方案指南</title>
    <link href="/2024/05/20/%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%8C%87%E5%8D%97/"/>
    <url>/2024/05/20/%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、整体方案以及项目结构"><a href="#一、整体方案以及项目结构" class="headerlink" title="一、整体方案以及项目结构"></a>一、整体方案以及项目结构</h1><table><thead><tr><th><strong>技术方案</strong></th><th><strong>技术选型</strong></th><th><strong>解决问题</strong></th></tr></thead><tbody><tr><td>国际化框架</td><td>i18next</td><td>多语言资源管理和切换以及本地化</td></tr><tr><td>RTL支持</td><td>dir=”rtl” + postcss-rtlcss</td><td>实现从右到左的布局和样式</td></tr><tr><td>本地化</td><td>day.js + Intl + i18next内置函数</td><td>本地化日期、数字等格式</td></tr><tr><td>辅助工具</td><td>VSCode 的 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally&source=article&objectId=2349931">i18n Ally</a> 插件</td><td>提升开发效率</td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n-project<br>└─ src<br>   ├─ views<br>   │  └─ <span class="hljs-title class_">View1</span><br>   │     ├─ style.<span class="hljs-property">less</span><br>   │     └─ index.<span class="hljs-property">vue</span><br>   ├─ i18n<br> │  ├─ locales <span class="hljs-comment">// 存放翻译资源</span><br> │├─ config <span class="hljs-comment">// 存放国际化相关配置</span><br>   │  └─ index.<span class="hljs-property">js</span> <span class="hljs-comment">// 国际化框架初始化</span><br>   ├─ compoments<br>   │  └─ <span class="hljs-title class_">Compoment1</span><br>   │     ├─ style.<span class="hljs-property">less</span><br>   │     └─ index.<span class="hljs-property">vue</span><br>   ├─ styles<br> │     ├─ theme <span class="hljs-comment">//存放主题文件</span><br> │     └─ languages <span class="hljs-comment">//存放语言样式文件</span><br> │        ├─ style_en.<span class="hljs-property">less</span> <span class="hljs-comment">//存放中文相关css变量</span><br> │        ├─ style_zh.<span class="hljs-property">less</span> <span class="hljs-comment">//存放英文相关css变量</span><br> │        └─ index.<span class="hljs-property">less</span> <span class="hljs-comment">//汇聚style_zh、style_en的变量</span><br>   │     ├─ <span class="hljs-variable language_">global</span>.<span class="hljs-property">less</span> <span class="hljs-comment">//全局类样式</span><br>   │     └─ index.<span class="hljs-property">less</span> <span class="hljs-comment">//只用于汇聚样式</span><br>   └─ main.<span class="hljs-property">js</span><br><br></code></pre></td></tr></table></figure><h1 id="二、国际化框架"><a href="#二、国际化框架" class="headerlink" title="二、国际化框架"></a>二、国际化框架</h1><h2 id="1-框架选择"><a href="#1-框架选择" class="headerlink" title="1. 框架选择"></a>1. 框架选择</h2><p>整体框架采用i8next，原因如下：</p><ul><li>是最早的国际化框架</li><li>适用框架广泛，是一个通用的解决方案，使学习成本降低</li><li>社区活跃，插件众多，提供很多优化方案</li><li>可扩展性，提供了将翻译拆分为多个文件的选项，并按需加载它们</li></ul><p>具体对比如下：</p><table><thead><tr><th><strong>对比项目</strong></th><th><strong>react-intl</strong></th><th><strong>i18next</strong></th><th><strong>vue-i18n</strong></th><th><strong>kiwi</strong></th></tr></thead><tbody><tr><td>多语言支持</td><td>提供丰富的多语言支持，包括常见语言和地区的特定格式化</td><td>支持多种语言，并且能够灵活处理复杂的语言结构</td><td>支持多种语言，能够满足 Vue 应用的多语言需求</td><td>支持多语言，语言格式强制language-region格式</td></tr><tr><td>适用框架</td><td>主要适用于 React 框架</td><td>适用于多种框架，具有广泛的适用性</td><td>专为 Vue.js 框架设计</td><td>任何框架</td></tr><tr><td>社区和文档支持</td><td>拥有活跃的社区和丰富的文档，有大量的示例和教程，但插件生态较少</td><td>社区活跃，文档详细且全面，有许多官方和第三方插件</td><td>社区活跃，文档较为完善，但插件生态较少</td><td>社区活跃度一般，文档写的比较简单，但插件生态很少</td></tr><tr><td>npm周下载数</td><td>1,443,114</td><td>4,795,569</td><td>1,045,674</td><td>342</td></tr><tr><td>性能和效率</td><td>性能较好，在 React 应用中的集成相对高效</td><td>性能表现出色，能够处理大规模的语言数据</td><td>在 Vue 应用中的性能表现良好，能有效处理语言切换</td><td>未有实际数据</td></tr><tr><td>本地化支持</td><td>对本地化的支持较为全面，包括日期、数字、货币等的格式化</td><td>提供强大的本地化功能，支持自定义本地化规则</td><td>能够很好地支持 Vue 应用中的本地化需求</td><td>支持单复数，其他本地化需要搭配原生Intl api</td></tr><tr><td>优势</td><td>1⃣️ react-intl 是基于 react 整合了 format.js 的 一套 react 国际化方案。</td><td></td><td></td><td></td></tr><tr><td>2⃣️ 提供了国际化前端转换的完整方案（即字符串、时间、日期的转换）</td><td></td><td></td><td></td><td></td></tr><tr><td>3⃣️ 易使用</td><td>1⃣️ 多框架的通用解决方案</td><td></td><td></td><td></td></tr><tr><td>2⃣️ 社区活跃，插件丰富，功能更全</td><td>1⃣️ 为 Vue 专门设计，与 Vue 框架结合紧密，</td><td></td><td></td><td></td></tr><tr><td>2⃣️ 易使用提供了简洁的 API 和易用性</td><td>1⃣️ 提供key的自动翻译和提取和未提取key的辅助检查</td><td></td><td></td><td></td></tr><tr><td>2⃣️ 通用的国际化框架，不绑定任何框架</td><td></td><td></td><td></td><td></td></tr><tr><td>缺点</td><td>插件生态偏少</td><td>api相对复杂，学习成本较高</td><td>插件生态偏少</td><td>会失去一些灵活性</td></tr></tbody></table><h2 id="2-框架配置"><a href="#2-框架配置" class="headerlink" title="2.框架配置"></a>2.框架配置</h2><p><img src="/img/d74e994d-4a9f-44d5-861f-f4b2b0100822.png"></p><h3 id="2-1-语言检测"><a href="#2-1-语言检测" class="headerlink" title="2.1 语言检测"></a>2.1 语言检测</h3><p><img src="/img/b0b262fd-f44e-479f-b1cc-e6d0f44f3edf.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">LanguageDetector</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;i18next-browser-languagedetector&#x27;</span><br><br>i18next<br>  .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">LanguageDetector</span>)<br>  .<span class="hljs-title function_">init</span>(&#123;<br>    ...<br>    <span class="hljs-attr">detection</span>: &#123;<br>      <span class="hljs-attr">order</span>: [<span class="hljs-string">&#x27;localStorage&#x27;</span>, <span class="hljs-string">&#x27;navigator&#x27;</span>, <span class="hljs-string">&#x27;querystring&#x27;</span>],<br>      <span class="hljs-attr">lookupQuerystring</span>: <span class="hljs-string">&#x27;lang&#x27;</span>,<br>    &#125;,<br>  &#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-comment">//初始语言检测</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLang</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> language = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;language&#x27;</span>)<br>    <span class="hljs-keyword">if</span>(!language)&#123;<br>        <span class="hljs-comment">// 检测用户语言偏好并设置对应的语言</span><br>        <span class="hljs-keyword">const</span> languageMap = [<span class="hljs-string">&#x27;zh&#x27;</span>,<span class="hljs-string">&#x27;en&#x27;</span>,<span class="hljs-string">&#x27;ar&#x27;</span>,<span class="hljs-string">&#x27;es&#x27;</span>,<span class="hljs-string">&#x27;ja&#x27;</span>,<span class="hljs-string">&#x27;ru&#x27;</span>]<br>        <span class="hljs-keyword">const</span> fallbackLanguage = <span class="hljs-string">&#x27;en&#x27;</span>;   <span class="hljs-comment">// 默认语言为英文</span><br>        <span class="hljs-keyword">const</span> userLanguage = navigator.<span class="hljs-property">language</span> || navigator.<span class="hljs-property">userLanguage</span>;<br>        language = languageMap.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">lang</span> =&gt;</span> userLanguage.<span class="hljs-title function_">startsWith</span>(lang)) || fallbackLanguage;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;language&#x27;</span>, language);<br>    &#125;<br>    <span class="hljs-keyword">return</span> language;<br>&#125;<br><br><span class="hljs-comment">//i18next初始化后的语言检测</span><br><br>$i18next.<span class="hljs-property">language</span><br></code></pre></td></tr></table></figure><h3 id="2-2-语言切换"><a href="#2-2-语言切换" class="headerlink" title="2.2 语言切换"></a>2.2 语言切换</h3><p>脱离框架影响，利用JS原生的 <code>dispatchEvent</code>实现一个类似的观察者模式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeDocumentDir</span>(<span class="hljs-params">language</span>)&#123;<br><span class="hljs-keyword">if</span>(language === <span class="hljs-string">&quot;ar&quot;</span> )&#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;dir&#x27;</span>,<span class="hljs-string">&#x27;rtl&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;dir&#x27;</span>,<span class="hljs-string">&#x27;ltr&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个处理全局语言更改的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleGloalLanguage</span>(<span class="hljs-params">nextLanguage</span>)&#123;<br>    <span class="hljs-comment">// 向文档派发一个自定义事件 &#x27;language-change&#x27;，并传递下一个语言作为详情</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;language-change&#x27;</span>,&#123;<span class="hljs-attr">detail</span>: nextLanguage&#125;))<br>&#125;<br><br><span class="hljs-comment">// 定义一个监听本地语言切换函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">registerLocalChange</span>(<span class="hljs-params">i18nCallBack</span>)&#123;<br>    <span class="hljs-comment">// 为文档添加 &#x27;language-change&#x27; 事件的监听</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;language-change&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">&#123; detail &#125;</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;language&#x27;</span>,detail)<br>        <span class="hljs-title function_">i18nCallBack</span>(detail)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">registerLocalChange</span>(<span class="hljs-function">(<span class="hljs-params">nextLanguage</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//改变文档的阅读方向</span><br>    <span class="hljs-title function_">changeDocumentDir</span>(nextLanguage)<br>    <span class="hljs-comment">// 调用改变html的lang属性</span><br>    <span class="hljs-title function_">changeHtmlLang</span>(nextLanguage)<br>    <span class="hljs-comment">// 调用改变系统语言的函数</span><br>    i18next.<span class="hljs-title function_">changeLanguage</span>(nextLanguage)<br>    <span class="hljs-comment">// 调用改变组件语言的函数</span><br>    <span class="hljs-title function_">changePuiLanguage</span>(nextLanguage)<br>&#125;)<br><br><span class="hljs-comment">// 在 Vue 原型上添加一个全局属性 &#x27;$global&#x27;，其中包含 &#x27;changeLanguage&#x27; 方法</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$global</span> = &#123;<br>    <span class="hljs-attr">changeLanguage</span>:handleGloalLanguage<br>&#125;<br><br><span class="hljs-comment">// 在 Vue 页面中调用 &#x27;$global&#x27; 的 &#x27;changeLanguage&#x27; 方法，并传递 &#x27;en&#x27; 作为参数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$global</span>.<span class="hljs-title function_">changeLanguage</span>(<span class="hljs-string">&#x27;en&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-3-资源获取"><a href="#2-3-资源获取" class="headerlink" title="2.3 资源获取"></a>2.3 资源获取</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLocalesMessage</span>(<span class="hljs-params">lang</span>) &#123;<br>    <span class="hljs-keyword">let</span> message = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> modules = [<span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-string">&#x27;glossary&#x27;</span>, <span class="hljs-string">&#x27;validation&#x27;</span>, <span class="hljs-string">&#x27;login&#x27;</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">of</span> modules) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> jsonObj = <span class="hljs-built_in">require</span>(<span class="hljs-string">`./locales/<span class="hljs-subst">$&#123;lang&#125;</span>/<span class="hljs-subst">$&#123;<span class="hljs-variable language_">module</span>&#125;</span>.json`</span>);<br>            message[<span class="hljs-variable language_">module</span>] = jsonObj;<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">module</span>&#125;</span>报错！！！！`</span>, error);<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;message&quot;</span>, message);<br>    <span class="hljs-keyword">return</span> message;<br>&#125;<br><br><span class="hljs-comment">//资源获取</span><br><span class="hljs-keyword">let</span> zh = <span class="hljs-title function_">getLocalesMessage</span>(<span class="hljs-string">&#x27;zh&#x27;</span>)<br><span class="hljs-keyword">let</span> en = <span class="hljs-title function_">getLocalesMessage</span>(<span class="hljs-string">&#x27;en&#x27;</span>)<br>...<br></code></pre></td></tr></table></figure><h3 id="2-4-i18next初始化"><a href="#2-4-i18next初始化" class="headerlink" title="2.4 i18next初始化"></a>2.4 i18next初始化</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLocalesMessage</span>(<span class="hljs-params">lang</span>) &#123;<br>    <span class="hljs-keyword">let</span> message = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> modules = [<span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-string">&#x27;glossary&#x27;</span>, <span class="hljs-string">&#x27;validation&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">of</span> modules) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> jsonObj = <span class="hljs-built_in">require</span>(<span class="hljs-string">`./locales/<span class="hljs-subst">$&#123;lang&#125;</span>/<span class="hljs-subst">$&#123;<span class="hljs-variable language_">module</span>&#125;</span>.json`</span>);<br>            message[<span class="hljs-variable language_">module</span>] = jsonObj;<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">module</span>&#125;</span>报错！！！！`</span>, error);<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;message&quot;</span>, message);<br>    <span class="hljs-keyword">return</span> message;<br>&#125;<br><br>  <span class="hljs-keyword">let</span> zh = <span class="hljs-title function_">getLocalesMessage</span>(<span class="hljs-string">&#x27;zh&#x27;</span>);<br>  <span class="hljs-keyword">let</span> en = <span class="hljs-title function_">awgetLocalesMessage</span>(<span class="hljs-string">&#x27;en&#x27;</span>);<br><br>i18next<br> .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">LanguageDetector</span>) <span class="hljs-comment">// 引入语言检测器插件</span><br> .<span class="hljs-title function_">init</span>(&#123;<br>      <span class="hljs-attr">debug</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 关闭调试模式</span><br>      <span class="hljs-attr">detection</span>: &#123;<br>        <span class="hljs-attr">order</span>: [<span class="hljs-string">&#x27;localStorage&#x27;</span>, <span class="hljs-string">&#x27;navigator&#x27;</span>], <span class="hljs-comment">// 语言检测的顺序，先查找本地存储，再通过浏览器导航器</span><br>        <span class="hljs-attr">lookupLocalStorage</span>: <span class="hljs-string">&#x27;language&#x27;</span>, <span class="hljs-comment">// 在本地存储中查找的键为 &#x27;language&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">fallbackLng</span>: <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-comment">// 当无法确定语言时，回退使用英语</span><br>      <span class="hljs-attr">ns</span>: [<span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-string">&#x27;login&#x27;</span>], <span class="hljs-comment">// 定义命名空间</span><br>      <span class="hljs-attr">defaultNS</span>: [<span class="hljs-string">&#x27;common&#x27;</span>], <span class="hljs-comment">// 设置默认命名空间</span><br>      <span class="hljs-attr">interpolation</span>: &#123;<br>        <span class="hljs-attr">escapeValue</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 插值时不转义值</span><br>      &#125;,<br>      <span class="hljs-attr">resources</span>: &#123; <br>        zh,<br>        en<br>      &#125;<br>    &#125;, <span class="hljs-function">(<span class="hljs-params">err, t</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err&quot;</span>, err); <span class="hljs-comment">// 初始化完成后的回调，打印可能出现的错误</span><br>    &#125;);<br></code></pre></td></tr></table></figure><h1 id="三、语言管理"><a href="#三、语言管理" class="headerlink" title="三、语言管理"></a>三、语言管理</h1><h2 id="1-翻译资源管理"><a href="#1-翻译资源管理" class="headerlink" title="1. 翻译资源管理"></a>1. 翻译资源管理</h2><h3 id="1-1-目录存放"><a href="#1-1-目录存放" class="headerlink" title="1.1 目录存放"></a>1.1 目录存放</h3><p>通常放在  <code>i18n</code> 目录下的<code>locales</code>里。比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">/src<br>  /i18n<br>  /locales<br>    /zh<br>    /en<br>...<br></code></pre></td></tr></table></figure><h3 id="1-2-模块划分"><a href="#1-2-模块划分" class="headerlink" title="1.2 模块划分"></a>1.2 模块划分</h3><p>推荐如下结构来<code>按照业务来聚合&#39;实现&#39;</code>，大部分情况不应该将所有的语言包一股脑放在一起，除非项目比较简单。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> i18n-project<br>└─ i18n<br> └─ locales<br>  ├─ en<br>    │  ├─ common.<span class="hljs-property">json</span> <span class="hljs-comment">//公用常用交互词</span><br>      │  ├─ glossary.<span class="hljs-property">json</span> <span class="hljs-comment">// 专有名词</span><br>      │  ├─ validation.<span class="hljs-property">json</span> <span class="hljs-comment">//存放全局验证信息</span><br>    │  ├─ moduleD.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块D里资源串</span><br>    │  ├─ moduleB.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块B里资源串</span><br>    │  ├─ moduleC.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块C里资源串</span><br>    │  └─ moduleA.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块A里资源串</span><br>    ├─ ar<br>    │  ├─ common.<span class="hljs-property">json</span> <span class="hljs-comment">//公用常用交互词</span><br>      │  ├─ glossary.<span class="hljs-property">json</span> <span class="hljs-comment">// 专有名词</span><br>      │  ├─ validation.<span class="hljs-property">json</span> <span class="hljs-comment">//存放全局验证信息</span><br>    │  ├─ moduleD.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块D里资源串</span><br>    │  ├─ moduleB.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块B里资源串</span><br>    │  ├─ moduleC.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块C里资源串</span><br>    │  └─ moduleA.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块A里资源串</span><br>    └─ zh<br>       ├─ ...<br></code></pre></td></tr></table></figure><ul><li>优点：<ul><li>按照语言进行分类，每个语言下又细分了不同的模块，组织较为清晰。</li><li>便于针对特定语言进行模块配置的管理和维护。</li></ul></li><li>缺点：<ul><li>结构相对复杂，对于简单的项目可能会显得过于繁琐。</li><li>增加了文件路径的深度，可能在操作文件时增加一些复杂性。</li></ul></li></ul><h3 id="1-3-模块颗粒度把握"><a href="#1-3-模块颗粒度把握" class="headerlink" title="1.3 模块颗粒度把握"></a>1.3 模块颗粒度把握</h3><p>模块划分的颗粒度越小，它的扩展性越强，方便后期整合新的资源。但是颗粒度过细会增加模块管理的复杂性，可能导致过多的小模块，使得系统架构显得过于繁琐，所以需要在颗粒度的粗细之间找到一个平衡，以实现最佳的扩展性和可维护性。</p><p>通常按照<code>业务模块</code>的粒度来划分。<strong>业务模块是由一个或多个页面组成的完整的功能</strong>。</p><p>业务模块可以是一个<code>子域</code>、甚至更小粒度的<code>聚合</code>。总之这个业务模块有以下特征：</p><ul><li>自包含。自给自足实现一个完整的功能闭环</li><li>高聚合。对外部依赖较少。</li></ul><p><img src="/img/97bb3144-af47-4c74-88d8-21e545094bba.png"></p><p>模块文件建议如下划分：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n-project<br>└─ i18n<br>   ├─ en<br>   │  ├─ common.<span class="hljs-property">json</span> <span class="hljs-comment">//公用常用交互词</span><br>   │  ├─ glossary.<span class="hljs-property">json</span> <span class="hljs-comment">// 专有名词</span><br>   │  ├─ your-moudule-name.<span class="hljs-property">json</span> <span class="hljs-comment">//项目模块里资源串</span><br>   │  └─ validation.<span class="hljs-property">json</span> <span class="hljs-comment">//存放全局验证信息</span><br>   └─ ...<br><br></code></pre></td></tr></table></figure><h3 id="1-4-资源串命名"><a href="#1-4-资源串命名" class="headerlink" title="1.4 资源串命名"></a>1.4 资源串命名</h3><p>1.4.1 命名原则</p><ul><li>唯一性：每个键应该对应唯一的文本内容。</li><li>与原文保持一致：如果可能，键的名称应与原始文本有一定的关联。</li><li>考虑扩展性：为未来可能的新增文本预留足够的空间。</li></ul><p><img src="/img/22e69696-94a0-4dc7-9f5d-ce1f03673623.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br>&#123;<br><span class="hljs-attr">taskname</span>:<span class="hljs-string">&#x27;任务名称&#x27;</span>，<br><span class="hljs-attr">tasknameplaceholder</span>:<span class="hljs-string">&#x27;请输入任务名称&#x27;</span><br><span class="hljs-attr">modalname</span>:<span class="hljs-string">&#x27;模型名称&#x27;</span>,<br><span class="hljs-attr">modalnameplaceholder</span>:<span class="hljs-string">&#x27;请输入模型名称&#x27;</span><br><span class="hljs-attr">modalversion</span>:<span class="hljs-string">&#x27;模型版本&#x27;</span>,<br><span class="hljs-attr">modalversionplaceholder</span>:<span class="hljs-string">&#x27;请输入模型版本&#x27;</span><br><span class="hljs-attr">reset</span>:<span class="hljs-string">&#x27;重置&#x27;</span>,<br><span class="hljs-attr">search</span>:<span class="hljs-string">&#x27;搜索&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;<br><span class="hljs-attr">taskname</span>:<span class="hljs-string">&#x27;任务名称&#x27;</span>,<br><span class="hljs-attr">tasknameplaceholder</span>:<span class="hljs-string">&#x27;请输入任务名称&#x27;</span><br><span class="hljs-attr">tasktime</span>:<span class="hljs-string">&#x27;任务时间&#x27;</span>,<br><span class="hljs-attr">tasktimeplaceholder</span>:<span class="hljs-string">&#x27;请输入任务时间&#x27;</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>1.4.2 推荐命名</p><p>模块名称-功能名称-相关名 =xxxxxx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//表格模块的高级查询的label——〉假如叫：任务名称</span><br><br>table-advancequery-<span class="hljs-attr">formlabel1</span>:“任务名称”<span class="hljs-comment">//推荐命名</span><br><br><span class="hljs-attr">taskName</span>:“任务名称” <span class="hljs-comment">//不推荐</span><br><br><span class="hljs-comment">// </span><br></code></pre></td></tr></table></figure><p>注意：【相关名】规则不同，模块要求不同</p><ul><li>common、glossary、validation 公共模块中的【相关名】直接以语义命名即可。</li><li>页面自己的 key 的【相关名】要求以场景、位置相关描述，主要应对 key 后续的变化，提高扩展性。  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-comment">// table</span><br>&#123;<br>table-form-<span class="hljs-attr">label1</span>:<span class="hljs-string">&#x27;任务名称&#x27;</span>，<br>table-form-<span class="hljs-attr">placeholder1</span>:<span class="hljs-string">&#x27;请输入任务名称&#x27;</span><br>...<br>&#125;<br><br><span class="hljs-comment">//common</span><br>&#123;<br>common-<span class="hljs-attr">reset</span>:<span class="hljs-string">&#x27;重置&#x27;</span>,<br>common-search：<span class="hljs-string">&#x27;搜索&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-5-语言标签"><a href="#1-5-语言标签" class="headerlink" title="1.5 语言标签"></a>1.5 语言标签</h3><p>多语言的语言标签通常遵循 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://en.wikipedia.org/wiki/IETF_language_tag&source=article&objectId=2349931">BCP 47</a>， 这是由互联网工程任务组（IETF）发布的一种语言标签规范，用于唯一标识各种语言。格式为 <code>lng-(script)-(Region 区域)-(Variant 变体)</code>，例如 zh-Hans-CN、en-US、zh-Hant 等等。</p><p>因为语言标签形式多种多样，而且不同的环境给出的结果可能都不太一样，所以建议开发者在维护语言包时统一使用语言标签，并且前后端保持统一。</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">en 默认英文<br>zh 默认简体中文<br>zh-Hant 默认繁体<br>th 默认泰文<br></code></pre></td></tr></table></figure><p>同时维护一些语言标签的映射规则：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>  <span class="hljs-string">&quot;zh-TW&quot;</span>: <span class="hljs-string">&quot;zh-Hant-TW&quot;</span>,<br>  <span class="hljs-string">&quot;zh-HK&quot;</span>: <span class="hljs-string">&quot;zh-Hant-HK&quot;</span>,<br>  <span class="hljs-string">&quot;zh-MO&quot;</span>: <span class="hljs-string">&quot;zh-Hant-MO&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用的 en、zh、zh-Hant、th 这些语言标签都是 <code>lng-(script)</code> 形式，这样兜底/命中效果会更好：</p><p>举个例子 <code>zh-Hant-TW</code> 的 <code>Locale chain</code> 是 <code>[&#39;zh-Hant-TW&#39;, &#39;zh-Hant&#39;, &#39;zh&#39;]</code> , 会回退加载 <code>zh-Hant</code> 和 <code>zh</code> 语言包。 如果有朝一日，需要对 TW 地区做特殊的适配，我们再创建一个更具体 <code>zh-Hant-TW</code> 语言包就行了。</p><h2 id="2-静态文案翻译"><a href="#2-静态文案翻译" class="headerlink" title="2.静态文案翻译"></a>2.静态文案翻译</h2><p>静态文案通常指在 Web 应用中相对固定、不随用户操作或系统状态实时变化的文本内容。</p><p>利用i18next的$t函数自动匹配即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// zh.json</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;inputText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;selectText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请选择&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;startTimeText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;开始时间&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;endTimeText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;结束时间&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;login&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;登录&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;required&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;该项为必填项&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;loginOut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;退出系统&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;document&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;项目文档&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;profile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;个人中心&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// en.json</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;inputText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Please enter&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;selectText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Please select&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;startTimeText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Start time&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;endTimeText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;End time&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;login&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Log in&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;required&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This item is a required field&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;loginOut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Logout of the system&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;document&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Project documentation&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;profile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Personal center&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-动态文案翻译（本地动态、后端动态）"><a href="#3-动态文案翻译（本地动态、后端动态）" class="headerlink" title="3.动态文案翻译（本地动态、后端动态）"></a>3.动态文案翻译（本地动态、后端动态）</h2><p>动态文案一般分几种：、基于后端数据库的动态文案</p><ul><li>基于前端的部分动态文案<ul><li>例如： XXXX校验成功、XXX用户登录成功。</li></ul></li><li>基于后端数据库的动态文案<ul><li>搜索热词</li><li>服务器相关错误提示</li><li>评论</li></ul></li></ul><p>方案一：接口增加语言参数，后端直接返回相应的语言。</p><p>方案二：与后端增加代码映射，将文本放到前端字典中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// zh.json</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;10002&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;登录成功！&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;10003&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;登录失败&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;10004&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户密码错误&quot;</span><span class="hljs-punctuation">,</span><br>...<br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// zh.json</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;10002&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Login succeeded!&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;10003&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Login failed&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;10004&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User password error&quot;</span><span class="hljs-punctuation">,</span><br>...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="四、-静态资源"><a href="#四、-静态资源" class="headerlink" title="四、 静态资源"></a>四、 静态资源</h1><h2 id="1-图片"><a href="#1-图片" class="headerlink" title="1. 图片"></a>1. 图片</h2><p><strong>推荐使用统一的命名约定，统一以</strong><code>xxx_&#123;lang&#125;</code><strong>格式命名</strong></p><p>给图片文件名添加语言标识，例如 <code>button_en.png</code> 和 <code>button_zh.png</code>。</p><ul><li>优点：不需要为每种语言创建单独的文件夹，节省结构层次，方便使用切换</li><li>缺点：文件名可能会变得较长且不太直观。</li></ul><h2 id="2-图标"><a href="#2-图标" class="headerlink" title="2.图标"></a>2.图标</h2><p>推荐使用<code>svg compoment</code>或者<code>iconfont</code>来使用图标，理由如下：</p><ul><li><code>iconfont</code>和<code>svg components</code>都是基于矢量图形构建的，不存在失真</li><li>拥有比png、jpg格式更小的文件大小</li><li>统一管理图标，方便后期对于RTL组件的维护</li></ul><p><code>Iconfont</code> 使用方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>svg component</code> 使用方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">icon-name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon-name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注： <code>svg components</code> 一般由组件库提供 ，不同的组件库的组件使用方式不同。</p><h1 id="五、样式"><a href="#五、样式" class="headerlink" title="五、样式"></a>五、样式</h1><h2 id="1-样式结构"><a href="#1-样式结构" class="headerlink" title="1.样式结构"></a>1.样式结构</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n-project<br>└─ src<br>   ├─ views<br>   │  └─ <span class="hljs-title class_">View1</span><br>   │     ├─ style.<span class="hljs-property">less</span><br>   │     └─ index.<span class="hljs-property">vue</span><br>   ├─ compoments<br>   │  └─ <span class="hljs-title class_">Compoment1</span><br>   │     ├─ style.<span class="hljs-property">less</span><br>   │     └─ index.<span class="hljs-property">vue</span><br>   ├─ styles<br> │     ├─ theme <span class="hljs-comment">//存放主题文件</span><br> │     └─ languages <span class="hljs-comment">//存放语言样式文件</span><br> │        ├─ style_en.<span class="hljs-property">less</span> <span class="hljs-comment">//存放中文相关css变量</span><br> │        ├─ style_zh.<span class="hljs-property">less</span> <span class="hljs-comment">//存放英文相关css变量</span><br> │        └─ index.<span class="hljs-property">less</span> <span class="hljs-comment">//汇聚style_zh、style_en的变量</span><br>   │     ├─ <span class="hljs-variable language_">global</span>.<span class="hljs-property">less</span> <span class="hljs-comment">//全局类样式</span><br>   │     └─ index.<span class="hljs-property">less</span> <span class="hljs-comment">//只用于汇聚样式</span><br>   └─ ...<br></code></pre></td></tr></table></figure><h2 id="2-多语言样式适配策略"><a href="#2-多语言样式适配策略" class="headerlink" title="2.多语言样式适配策略"></a>2.多语言样式适配策略</h2><p>不同语言在设计和开发中都需要提供合适的行高、行艰巨或字号，来保证页面最佳视觉体验。</p><h3 id="2-1-根据语言处理不同样式"><a href="#2-1-根据语言处理不同样式" class="headerlink" title="2.1 根据语言处理不同样式"></a>2.1 根据语言处理不同样式</h3><p>在开发时，建议将语言特定的文本样式（如字体大小、颜色、对齐方式等）与通用的布局样式分开，创建专门的语言样式文件，以便于针对性地管理和维护。</p><p>例如，一个多语言网站项目中，对于英语页面，标题的字体颜色可能是蓝色；而对于法语页面，由于文化和设计偏好，标题字体颜色可能是红色。通过分离样式文件，我们可以在 <code>styles_en.css</code> 中设置标题颜色为蓝色，在 <code>styles_fr.css</code> 中设置为红色，从而实现对不同语言页面样式的精准管理。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-comment">// style-zh.less</span><br><span class="hljs-selector-pseudo">:root</span>,<br><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-attr">[lang=<span class="hljs-string">&quot;zh&quot;</span>]</span>&#123;<br><span class="hljs-attr">--font-size</span>: 14px;<br><span class="hljs-attr">--line-height</span>:1.5<br><span class="hljs-attr">--font-color</span>:rgb(0,0,0,0.9)<br><span class="hljs-attr">--font-family</span>:&quot;微软雅黑&quot;<br><br>&#125;<br><br><span class="hljs-comment">// style-ar.less</span><br><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-attr">[lang=<span class="hljs-string">&quot;ar&quot;</span>]</span>&#123;<br><span class="hljs-attr">--font-size</span>: 16px;<br><span class="hljs-attr">--line-height</span>:1.5<br><span class="hljs-attr">--font-color</span>:rgb(0,0,0)<br><span class="hljs-attr">--font-family</span>:&quot;Noto Naskh&quot;,&quot;Microsoft YaHei&quot;;<br><br>&#125;<br><br><span class="hljs-comment">// .global.less</span><br><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-built_in">var</span>(--font-size);<br><span class="hljs-attribute">line-height</span>:<span class="hljs-built_in">var</span>(--line-height);<br><span class="hljs-attribute">font-color</span>:<span class="hljs-built_in">var</span>(--font-color);<br><span class="hljs-attribute">font-family</span>:<span class="hljs-built_in">var</span>(--font-family);<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">switchTheme</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br>      <span class="hljs-keyword">if</span> (root.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>) === <span class="hljs-string">&#x27;light&#x27;</span>) &#123;<br>        root.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>, <span class="hljs-string">&#x27;dark&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>, <span class="hljs-string">&#x27;light&#x27;</span>);<br>      &#125;<br>    &#125;<br>    <br>    <br>    <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeHtmlLang</span>(<span class="hljs-params">language</span>) &#123;<br>      <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br>      <span class="hljs-keyword">if</span> (language) &#123;<br>        root.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;lang&#x27;</span>, language);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;lang&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>);<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-pseudo">:root</span>,<br><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-attr">[lang=<span class="hljs-string">&quot;zh&quot;</span>]</span><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;dark&quot;</span>]</span>&#123;<br><span class="hljs-attr">--brand-color-1</span>: #F3F5FD;<br><span class="hljs-attr">--brand-color-2</span>: #ECF0FE;<br><span class="hljs-attr">--brand-color-3</span>: #E4E9FA;<br>&#125;<br></code></pre></td></tr></table></figure><p>应根据不同语言特性设置定制的样式，保证页面的视觉平衡，所以在开发中可以使用以下几种方案：</p><p><strong>2.1.1. 通过 JavaScript 动态添加样式</strong></p><ul><li>根据获取到的当前语言，通过操作 DOM 来添加或修改相应的样式类。</li><li>示例：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">if</span> (language === <span class="hljs-string">&#x27;en&#x27;</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.element&#x27;</span>).<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;style-for-en&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (language === <span class="hljs-string">&#x27;zh&#x27;</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.element&#x27;</span>).<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;style-for-zh&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.1.2. 采用 CSS 自定义属性（CSS Variables）</strong></p><ul><li>在根元素上设置语言相关的自定义属性，然后在具体的样式中使用。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--fontSizeEn</span>: <span class="hljs-number">14px</span>;<br>  <span class="hljs-attr">--fontSizeZh</span>: <span class="hljs-number">16px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.text</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">var</span>(--fontSize$&#123;language&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2不同语言长度造成布局问题"><a href="#2-2不同语言长度造成布局问题" class="headerlink" title="2.2不同语言长度造成布局问题"></a>2.2不同语言长度造成布局问题</h3><p>在多语言编码时，不同语言应该有单独页面设计，或出于成本考虑应在设计时<strong>优先考虑响应式设计</strong>。</p><p>在CSS应避免直接width、height属性将宽高写死，应尽量用min-width、max-width、min-height、max-height代替，再根据超出最大宽度或者高度设置合理的超长样式，例如：省略显示、换行、自适应、滚动等。</p><p>注意：如果宽高设计时不允许有变化，则可以使用width、height</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs css">// 常用属性<br>white-break：nowrap;<br><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">overflow-x</span>: scroll;<br><span class="hljs-attribute">overflow-y</span>: scroll;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><br>//换行<br><span class="hljs-selector-class">.break-line</span>&#123;<br><span class="hljs-attribute">white-space</span>：wrap<br>&#125;<br>//省略样式<br><span class="hljs-selector-class">.ellipsis-single-line</span> &#123;<br><span class="hljs-attribute">min-width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">white-space</span>: nowrap; //不换行<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>&#125;<br><span class="hljs-selector-class">.ellipsis-multi-line</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-<span class="hljs-selector-tag">line</span>-clamp: <span class="hljs-number">3</span>; //最多显示<span class="hljs-number">3</span>行<br>  -webkit-box-orient: vertical;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br>//水平滚动<br><span class="hljs-selector-class">.horizontal-scroll</span> &#123;<br><span class="hljs-attribute">max-width</span>：<span class="hljs-number">200px</span><br>  <span class="hljs-attribute">overflow-x</span>: scroll;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-RTL布局"><a href="#3-RTL布局" class="headerlink" title="3. RTL布局"></a>3. RTL布局</h2><h3 id="3-1-如何下手"><a href="#3-1-如何下手" class="headerlink" title="3.1 如何下手"></a>3.1 如何下手</h3><p><strong>RTL语言改造主要需要考虑四个方面：</strong></p><ul><li>布局结构（元素相对于整体的布局结构、元素内部布局结构）  在 RTL 模式下，页面的布局方向需要完全反转。这包括元素的排列顺序、边距和填充的方向等。</li><li>文字  文本的流向从左到右变为从右到左，这涉及到字符的顺序、标点的位置以及文字换行的规则等。不同语言的文字在 RTL 环境中的表现可能有所不同，需要进行针对性的处理。</li><li>图标、图片  一些图片和图标可能具有特定的方向性，在 RTL 模式下需要进行翻转或重新设计，以确保其视觉效果符合从右到左的阅读习惯。</li><li>交互  对于动态生成的内容和具有交互功能的元素，如表单、下拉菜单等，需要确保其在 RTL 模式下的操作和显示都是正确和直观的。</li></ul><h3 id="3-2-方案：html原生属性dir-“rtl”-css转换工具postcss-rtlcss"><a href="#3-2-方案：html原生属性dir-“rtl”-css转换工具postcss-rtlcss" class="headerlink" title="3.2 方案：html原生属性dir=“rtl”+ css转换工具postcss-rtlcss"></a>3.2 方案：<strong>html原生属性</strong><code>dir=“rtl”</code>+ css转换工具<code>postcss-rtlcss</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">loaderOptions</span>: &#123;<br>        <span class="hljs-attr">postcss</span>: &#123;  <span class="hljs-comment">// 配置 PostCSS 相关选项</span><br>            <span class="hljs-attr">postcssOptions</span>:&#123;<br>                <span class="hljs-attr">plugins</span>: [  <span class="hljs-comment">// 定义 PostCSS 插件数组</span><br>                    [<br>                        <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-rtlcss&#x27;</span>).<span class="hljs-title function_">postcssRTLCSS</span>(&#123;  <span class="hljs-comment">// 使用 postcss-rtlcss 插件并配置其选项</span><br>                            <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;combined&#x27;</span>,  <span class="hljs-comment">// 模式为&quot;combined&quot;</span><br>                            <span class="hljs-attr">ignorePrefixedRules</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 忽略带前缀的规则</span><br>                            <span class="hljs-attr">ltrPrefix</span>: <span class="hljs-string">&#x27;[dir=&quot;ltr&quot;]&#x27;</span>,  <span class="hljs-comment">// 定义从左到右（LTR）的前缀</span><br>                            <span class="hljs-attr">rtlPrefix</span>: <span class="hljs-string">&#x27;[dir=&quot;rtl&quot;]&#x27;</span>,  <span class="hljs-comment">// 定义从右到左（RTL）的前缀</span><br>                            <span class="hljs-attr">bothPrefix</span>: <span class="hljs-string">&#x27;[dir]&#x27;</span>,  <span class="hljs-comment">// 定义同时适用于 LTR 和 RTL 的前缀</span><br>                            <span class="hljs-attr">safeBothPrefix</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 安全的同时适用前缀</span><br>                            <span class="hljs-attr">processUrls</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 处理 URL</span><br>                            <span class="hljs-attr">processKeyFrames</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 处理关键帧</span><br>                            <span class="hljs-attr">useCalc</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 使用计算功能</span><br>                        &#125;)<br><br>                    ]<br>                ]<br>            &#125;<br><br>          &#125;<br>        &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;rtl&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ar&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>...<br></code></pre></td></tr></table></figure><p>在html中默认的<code>dir=“ltr”</code>，整个文档是从左往右的基本方向，如果设置 <code>dir=“rtl”</code> 之后，基本方向则改为从右往左，文档中的所有块元素将继承此设置，除非方向被明确覆盖。</p><p>但是值只设置<code>dir=“rtl”</code>只能对以下属性生效：</p><ul><li><code>inline-block</code>、<code>flex</code>、<code>table</code>、<code>grid</code> 的布局方向</li><li>没有设置<code>text-align</code>属性的元素的文字方向</li></ul><p>像以下属性<code>dir=“rtl”</code>起不到作用：</p><ul><li><code>absolute</code> / <code>fixed</code>、<code>float</code>、<code>margin</code>、<code>padding</code> 、<code>text-align</code>等</li></ul><p>所以我们使用<code>postcss-rtlcss</code>来解决<code>dir</code>起不到作用的属性。</p><p><strong>3.2.1</strong> <code>postcss-rtlcss</code><strong>插件的使用</strong></p><p>按照 RTL 布局对 CSS 代码进行转换，原理是所有涉及左右方向性属性进行转换，例如：<code>margin-left</code> 改写成 <code>margin-right</code>，将 <code>left: 0;</code> 改写成 <code>right: 0;</code>。</p><p><img src="/img/88c54352-db7b-42bd-a75b-42faeaa7ea3a.png"></p><p><strong>拿国际化最佳实践导航举例：</strong></p><p>这是未使用rtlcss之前的代码</p><p><img src="/img/070b5844-bbcb-4f52-b7c7-6922d759ebe9.png"></p><p>这是使用rtlcss对项目样式文件编译后的文件</p><p><img src="/img/ef8323e8-64ef-4aae-a074-d5043b0cf8db.png"></p><p><img src="/img/40f6c564-22aa-4435-9252-2b799fe6d878.png"></p><aside>💡 [dir=”rtl”]代表当有dir=“rtl”时应用的属性，[dir=”ltr”]代表当有dir=“ltr”时应用的属性<p>[dir]前缀是代表rtl时和ltr时，公用的样式<strong>含方向的样式</strong>，这样抽离出来是为了避免重复unset</p></aside><p>这里解释一下</p><p>原样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test1</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不抽离方向属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test1</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-attr">[dir=<span class="hljs-string">&quot;ltr&quot;</span>]</span><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-attr">[dir=<span class="hljs-string">&quot;rtl&quot;</span>]</span><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin-left</span>:unset;<br><span class="hljs-attribute">margin-right</span>:<span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽离方向属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test1</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;  <br>&#125;<br><br><span class="hljs-selector-attr">[dir]</span><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-attr">[dir=<span class="hljs-string">&quot;ltr&quot;</span>]</span><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-attr">[dir=<span class="hljs-string">&quot;rtl&quot;</span>]</span><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin-right</span>:<span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>插件逻辑时先抽去所有方向属性到<code>[dir]</code>中，再将涉及左右转换的样式再抽离到<code>[dir=&quot;ltr&quot;]</code>或者<code>[dir=&quot;rtl&quot;]</code>中。这种样式抽取方式也就是组件的combined模式，这样好处代码量相对会少很多。</p><p>【注意】针对不需要镜像处理然后被插件镜像处理了的，我们需要通过<code>rtlcss</code>提供的注释<code>/*rtl:begin:ignore*/</code>和<code>/*rtl:end:ignore*/</code>来告诉插件不需要执行镜像操作。</p><p><img src="/img/aeb764d7-0d99-499f-8658-f7626b19b9ce.png"></p><p>更多RTL请参考：</p><ul><li><a href="https://rtlcss.com/learn/">https://rtlcss.com/learn/</a></li><li><a href="https://www.notion.so/1-3334908e1c5a4c2aaedfd4cf90291d7f?pvs=21">https://www.notion.so/1-3334908e1c5a4c2aaedfd4cf90291d7f?pvs=4#61eea16dd1fa49e5a595e20a363f7f29</a></li></ul><p><strong>3.2.2 JS中方向</strong></p><p><code>dir=”rtl”</code> 以及 <code>“postcss-rtlcss”</code> 只能解决 CSS 上的方向问题，解决不了 JS 中的方向问题，所以需要在函数中添加判断处理。</p><p>例如，利用 “i18next” 获取全局语言，封装一个判断 RTL 的函数，并绑定到 Vue 原型上</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isRTL</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">if</span>(i18next.<span class="hljs-property">languge</span>===<span class="hljs-string">&#x27;ar&#x27;</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$global</span> = &#123;<br>isRTL<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="img/9be84739-81ca-43d9-9fd6-428b90074034.png"></p><p><strong>3.2.3 图片、图标</strong></p><p>图片和图标需要我们针对业务和当地人习惯单独判断是否需要镜像处理，一般建议针对需要镜像的图片或着图标重新设计，通过切换name的方式根据语言切换，否则就只能简单通过<code>transform:scaleX(-1)</code>方式直接镜像翻转。</p><ul><li><code>Iconfont</code> 使用方式  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$global.isRTL()? &#x27;icon-name-rtl&#x27;:&#x27;icon-name&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>svg component</code> 使用方式  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">icon-name</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;$global.isRTL()? &#x27;rtl&#x27;:&#x27;ltr&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon-name</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>注： <code>svg components</code> 一般又组件库提供 ，不同的组件库的组件使用方式不同。</p><p><strong>3.2.4 第三方库的适配</strong></p><p>最好选择已经支持RTL的第三方库，因为如果不支持的话，我们就只能自己把项目fork出来，自行适配</p><h3 id="3-3-编码注意事项："><a href="#3-3-编码注意事项：" class="headerlink" title="3.3 编码注意事项："></a>3.3 编码注意事项：</h3><p>1.编写样式不要使用内联样式</p><ol start="2"><li><p>不要逻辑属性和方向属性混用</p></li><li><p>关于背景图片 <code>background:url(”XXX”)</code>的RTL可以采用<code>background-position:right</code></p></li></ol><p>4.不需要镜像翻转的元素就可以用direction：ltr 来覆盖文档继承的进本方向</p><p>5.样式穿透时，前面要跟上父类，不要直修改</p><p>6.应尽量使用流式布局、flex布局、grid布局，尽量少使用相对定位、绝对定位、浮动布局。</p><p>注意：不应在 HTML 页面里通过 CSS 来实现基本方向的应用<code>direction:rtl</code>，主要是因为就算 CSS 不可用，希望方向信息是可用的。</p><h1 id="六、配置i18next数据本地化"><a href="#六、配置i18next数据本地化" class="headerlink" title="六、配置i18next数据本地化"></a>六、配置i18next数据本地化</h1><h2 id="1-基本语法格式"><a href="#1-基本语法格式" class="headerlink" title="1.基本语法格式"></a>1.基本语法格式</h2><p>资源串中定义：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Some format &#123;&#123;value, formatname&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keyWithOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Some format &#123;&#123;value, formatname(option1Name: option1Value; option2Name: option2Value)&#125;&#125;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>页面中使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123; value, <span class="hljs-attr">option1Name</span>: option1Value &#125;)<br><span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123; value, <span class="hljs-attr">formatParams</span>: &#123; <span class="hljs-attr">value</span>: &#123; <span class="hljs-attr">option1Name</span>: option1Value &#125; &#125;)<br></code></pre></td></tr></table></figure><p>其中<code>formatname</code>是格式化函数名称，i18next内置很多格式化函数其中包括<code>number</code>、<code>currency</code>、<code>relativetime</code>、<code>datetime</code>、<code>list</code>，其中这些内置函数都是基于JS的Intl实现，具体这些函数的option可参考MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl - JavaScript | MDN (mozilla.org)</a></p><p><img src="/img/18640717-df38-4d1a-94a6-a20a37e723c9.png"></p><p>当内置格式函数无法满足我们需求时我们可以使用i18next的自定义格式函数功能：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18next.<span class="hljs-property">services</span>.<span class="hljs-property">formatter</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;your-formatname&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">value, lng, options</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// do something to format value</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">XXX</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-单-复数"><a href="#1-单-复数" class="headerlink" title="1.单/复数"></a>1.单/复数</h2><p>基本使用方法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br>&#123;<br>  <span class="hljs-string">&quot;key_one&quot;</span>: <span class="hljs-string">&quot;item&quot;</span>,<br>  <span class="hljs-string">&quot;key_other&quot;</span>: <span class="hljs-string">&quot;items&quot;</span>,<br>  <span class="hljs-string">&quot;keyWithCount_one&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;count&#125;&#125; item&quot;</span>,<br>  <span class="hljs-string">&quot;keyWithCount_other&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;count&#125;&#125; items&quot;</span><br>&#125;<br><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// -&gt; &quot;items&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// -&gt; &quot;item&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">5</span>&#125;); <span class="hljs-comment">// -&gt; &quot;items&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;key&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">100</span>&#125;); <span class="hljs-comment">// -&gt; &quot;items&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;keyWithCount&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// -&gt; &quot;0 items&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;keyWithCount&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// -&gt; &quot;1 item&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;keyWithCount&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">5</span>&#125;); <span class="hljs-comment">// -&gt; &quot;5 items&quot;</span><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;keyWithCount&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">100</span>&#125;); <span class="hljs-comment">// -&gt; &quot;100 items&quot;</span><br></code></pre></td></tr></table></figure><p>我们需要确认两件事情：</p><ul><li>该语言的单/复数语法规则有几种，这个参考 CLDR Language Plural Rules</li><li>对应词语单/复数形式</li></ul><p>注意：变量名必须是“count”，不可以起名val1、val2、value等其他值。</p><h2 id="2-数字格式"><a href="#2-数字格式" class="headerlink" title="2. 数字格式"></a><strong>2. 数字格式</strong></h2><p>使用内置格式化函数<code>number</code>即可，它会根据i18next的语言自动使用国家的数据格式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 日期</span><br>&#123;<br>  <span class="hljs-string">&quot;intlNumber&quot;</span>: <span class="hljs-string">&quot;Some &#123;&#123;val, number&#125;&#125;&quot;</span>,<br>&#125;<br><br>i18next.<span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;intlNumber&#x27;</span>, &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">1000</span> &#125;);<br><span class="hljs-comment">// --&gt; Some 1,000</span><br></code></pre></td></tr></table></figure><p>当然如果有定制化需求，则可以利用i18next的自定义格式化函数功能：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18next.<span class="hljs-property">services</span>.<span class="hljs-property">formatter</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;numberFormat&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">value,lng</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">NumberFormat</span>(lng).<span class="hljs-title function_">format</span>(value)<br>&#125;)<br></code></pre></td></tr></table></figure><p>（<code>numberFormat</code>的功能效果和<code>i18next</code>内置的格式化函数<code>number</code>效果一样）</p><h2 id="3-时区和日期本地化"><a href="#3-时区和日期本地化" class="headerlink" title="3. 时区和日期本地化"></a><strong>3. 时区和日期本地化</strong></h2><p>这里不推荐使用i18next内置格式化函数，使用相对繁琐，推荐结合i18next自定义格式化函数和第三方时间库<code>day.js</code>使用，具体对比如下</p><table><thead><tr><th></th><th>描述</th><th>体积</th><th>npm包</th></tr></thead><tbody><tr><td><a href="https://link.zhihu.com/?target=https://github.com/moment/moment">Moment</a></td><td>用于解析、验证、操作和格式化日期的 JavaScript 日期库.应该属于前端使用最广的日期处理库了。</td><td>包体积较大18</td><td>Vue版本：<a href="https://link.zhihu.com/?target=https://github.com/brockpetrie/vue-moment">vue-moment</a></td></tr><tr><td>React版本：<a href="https://link.zhihu.com/?target=https://github.com/headzoo/react-moment">react-moment</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://link.zhihu.com/?target=https://github.com/iamkun/dayjs">**Day.js</a>（推荐）**</td><td>一个仅 <strong>2kb</strong> 大小的<code>轻量级</code> JavaScript 时间日期处理库，和 Moment.js 的 API 设计保持完全一样。</td><td>仅<strong>2kb</strong></td><td>Vue版本：<a href="https://link.zhihu.com/?target=https://github.com/brockpetrie/vue-moment">vue-moment</a></td></tr><tr><td>React版本：<a href="https://link.zhihu.com/?target=https://github.com/devshawn/react-dayjs">react-dayjs</a></td><td></td><td></td><td></td></tr></tbody></table><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dayTimeIntlFormat</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">let</span> dateParser = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(value))) &#123;<br>    value = <span class="hljs-title class_">Number</span>(value);<br>    dateParser = <span class="hljs-title function_">dayjs</span>(value);<br>  &#125;<br>  <span class="hljs-keyword">return</span> dateParser.<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);<br>&#125;<br><br>i18next.<span class="hljs-property">services</span>.<span class="hljs-property">formatter</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;dateformat&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> format.<span class="hljs-title function_">dayTimeIntlFormat</span>(value);<br>&#125;);<br></code></pre></td></tr></table></figure><aside>💡 **问题1:  前后端跨时区导致时间错误问题？**<p><strong>问题描述：</strong></p><p>以泰国举例，相关数据库部署在泰国。如果在中国创建一条数据插入泰国数据库，通过时间控件选择数据的创建时间，这时获取的时间是从浏览器获取 为中国时区时间。需要把这个时间传到后端服务器，存储到数据库，但服务器的时间为泰国时区的时间。中国是东八区 泰国是东七区，相差一个小时。这就会导致两个问题：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>、创建数据：在前端选的<span class="hljs-number">8</span>:<span class="hljs-number">00</span>，落到数据库中就会变为<span class="hljs-number">7</span>：<span class="hljs-number">00</span><br><br><span class="hljs-attribute">b</span>、数据查询时的错觉：在前端选择查询<span class="hljs-number">8</span>点到<span class="hljs-number">9</span>点创建的数据，到后端经过转换会变为查找<span class="hljs-number">7</span>:<span class="hljs-number">00</span>到<span class="hljs-number">8</span>点的消息，返回的数据又会带有相应的时区，导致，数据的一种假象。以为查的是<span class="hljs-number">8</span>点到<span class="hljs-number">9</span>点创建的数据，而实际看到的是<span class="hljs-number">7</span>:<span class="hljs-number">00</span>到<span class="hljs-number">8</span>点的消息。<br></code></pre></td></tr></table></figure><p>问题追踪发现，前端传过来的时间，在经过java时间格式转换后会转换为对应时区的时间。</p><p><strong>解决：</strong></p><p>1、这种问题一般数据库的时区设置为UTC时间，前端传的数据增加时区的字段，标识自己是哪个时区，后端将这个时间转为UTC时区传给数据库，同时，数据库返回的时间再转为前端需要的时区传递出去，这样会有效避免时区问题。</p><p>2、既然我们的数据库已经是当地的时区，无法改变，那一种有效的做法时，登录页面前做个选择时区的页面，用户选择切换到对应的时区，访问对应的数据源。</p><p>3、另外一种简单的做法：所有前端的时间去掉时间格式，作为字符串与后端交互。后端将时间转换为字符串传给前端，前端的时间同样处理为字符串传给后端，后端做时间处理，这样就可避免时区问题，做到前端时间可见即可得（前端展示什么，库中就是什么时间）</p></aside><h2 id="4-图标和图片"><a href="#4-图标和图片" class="headerlink" title="4. 图标和图片"></a><strong>4. 图标和图片</strong></h2><p>一些图标和图片可能在不同文化环境中有不同的意义。为了适应本地化需求，可以使用不同的图标和图片，或者根据语言环境切换不同的资源文件。</p><p>4.1 将所有图标直接生成两套资源，根据语言切换资源文件即可</p><p>4.2 规范化命名将所有图标重新增加一套命名，即增加-rtl后缀（无论是否需要翻转都增加-rtl），根据语言直接修改图标名称后缀即可</p><p>4.3 根据系统挨个修改icon图标名称或替换</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl - JavaScript | MDN</a></p><h1 id="七、提效工具i18n-Ally"><a href="#七、提效工具i18n-Ally" class="headerlink" title="七、提效工具i18n-Ally"></a>七、提效工具i18n-Ally</h1><h2 id="1-多语言资源管理"><a href="#1-多语言资源管理" class="headerlink" title="1.多语言资源管理"></a>1.多语言资源管理</h2><h3 id="1-1-资源属性样式配置"><a href="#1-1-资源属性样式配置" class="headerlink" title="1.1 资源属性样式配置"></a>1.1 资源属性样式配置</h3><p>i18n-Ally支持嵌套对象（nested）和路径平铺（flat）两种书写格式，这决定资源串的显示形式。</p><h3 id="1-2-适应不同项目的目录结构"><a href="#1-2-适应不同项目的目录结构" class="headerlink" title="1.2 适应不同项目的目录结构"></a>1.2 适应不同项目的目录结构</h3><p><strong>Options</strong></p><p>The path matcher matches the relative path from your locale folder. File paths with no match will not be loaded.</p><p>Some common examples:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;locale&#125;/&#123;<span class="hljs-keyword">namespace</span>&#125;.&#123;ext&#125;   <span class="hljs-meta"># matches <span class="hljs-string">&quot;zh-CN/attributes.yaml&quot;</span></span><br><br>&#123;namespaces&#125;/&#123;locale&#125;.&#123;ext&#125;  <span class="hljs-meta"># matches <span class="hljs-string">&quot;common/users/en-US.json&quot;</span></span><br><br>&#123;locale&#125;.json                <span class="hljs-meta"># matches <span class="hljs-string">&quot;fr-FR.json&quot;</span></span><br></code></pre></td></tr></table></figure><p>The following table lists some matchers you may want to use. is required, while the others are optional.<code>&#123;locale&#125;</code></p><table><thead><tr><th>Matcher</th><th>Description</th></tr></thead><tbody><tr><td><code>&#123;locale&#125;</code></td><td>Match the locale code, etc.<code>en-USzh-CNfr</code></td></tr><tr><td><code>&#123;namespace&#125;</code></td><td>Match anything excludes folder separator . It only matches one level of directories<code>/</code></td></tr><tr><td><code>&#123;namespaces&#125;</code></td><td>Match anything. It can match multiple levels of directories. The folder separator will be converted to in keypath<code>.</code></td></tr><tr><td><code>&#123;ext&#125;</code></td><td>File extensions, based on current enabled parsers</td></tr><tr><td><code>&#123;locale?&#125;</code></td><td>Optional version of , if not locale captured, the current source language will be applied<code>&#123;locale&#125;</code></td></tr><tr><td><code>&#123;namespace?&#125;</code></td><td>Optional version of <code>&#123;namespace&#125;</code></td></tr><tr><td><code>&#123;namespaces?&#125;</code></td><td>Optional version of <code>&#123;namespaces&#125;</code></td></tr></tbody></table><p>例1：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n<br>  ├── nl-<span class="hljs-variable constant_">NL</span><br>  |   ├── general<br>  |   |   └── ...<br>  |   ├── attributes<br>  |   |   └── foo.<span class="hljs-property">yaml</span><br>  |   └── ...<br>  ├── en<br>  |   ├── general<br>  |   |   └── ...<br>  |   ├── attributes<br>  |   |   └── foo.<span class="hljs-property">yaml</span><br>  |   └── ...<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Path Matcher</span><br><span class="hljs-string">&#x27;&#123;locale&#125;/&#123;namespaces&#125;.yaml&#x27;</span><br><br><span class="hljs-comment">// Example Path</span><br><span class="hljs-string">&#x27;nl-NL/attributes/foo.yaml&#x27;</span><br><br><span class="hljs-comment">// Matched result</span><br>&#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;nl-NL&#x27;</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;attributes.foo&#x27;</span> &#125;<br><br><span class="hljs-comment">// Example usage</span><br>$t(<span class="hljs-string">&#x27;attributes.foo.your-key&#x27;</span>)<br></code></pre></td></tr></table></figure><p>例2:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n<br>  ├── general<br>  |   ├── nl.<span class="hljs-property">yaml</span><br>  |   ├── de.<span class="hljs-property">yaml</span><br>  |   ├── en.<span class="hljs-property">yaml</span><br>  |   └── ...<br>  ├── attributes<br>  |   ├── foo<br>  |   |   ├── nl.<span class="hljs-property">yaml</span><br>  |   |   ├── de.<span class="hljs-property">yaml</span><br>  |   |   ├── en.<span class="hljs-property">yaml</span><br>  |   |   └── ...<br>  |   ├── bar<br>  |   |    └── ...<br>  |   └── ...<br>  ├──  resources<br>  |    └── ...<br>  └── ...<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Path Matcher</span><br><span class="hljs-string">&#x27;&#123;namespaces&#125;/&#123;locale&#125;.yaml&#x27;</span><br><br><span class="hljs-comment">// Example Path</span><br><span class="hljs-string">&#x27;attributes/bar/en.yaml&#x27;</span><br><br><span class="hljs-comment">// Matched result</span><br>&#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;attributes.bar&#x27;</span> &#125;<br><br><span class="hljs-comment">// Example usage</span><br>$t(<span class="hljs-string">&#x27;attributes.bar.your-key&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-统一的增删改查"><a href="#2-统一的增删改查" class="headerlink" title="2. 统一的增删改查"></a>2. 统一的增删改查</h2><h3 id="2-1快速定位key的位置"><a href="#2-1快速定位key的位置" class="headerlink" title="2.1快速定位key的位置"></a>2.1快速定位key的位置</h3><p><img src="/img/ff1437a2-1679-4ca1-b685-5cb2059fcb9f.png"></p><p><img src="/img/078997a4-249f-4171-802a-9290af0c5f7b.png"></p><h3 id="2-2-同key不同语言的value一键修改"><a href="#2-2-同key不同语言的value一键修改" class="headerlink" title="2.2 同key不同语言的value一键修改"></a>2.2 同key不同语言的value一键修改</h3><p><img src="/img/b5878d00-7e60-414d-9d5f-20de2e7dccfb.png"></p><p><img src="/img/2420b883-384d-4f6b-a1e2-905c0c9ca0d7.png"></p><h3 id="2-3-资源串key的一键重命名"><a href="#2-3-资源串key的一键重命名" class="headerlink" title="2.3 资源串key的一键重命名"></a>2.3 资源串key的一键重命名</h3><p><img src="/img/a7c0ee39-c57a-45c7-bd12-1599c3552058.png"></p><h2 id="3-显示指定语言"><a href="#3-显示指定语言" class="headerlink" title="3.显示指定语言"></a>3.显示指定语言</h2><p><img src="/img/2c069c40-f48e-4199-b405-0556bbe21398.png"></p><h2 id="4-翻译进度显示与漏翻检查"><a href="#4-翻译进度显示与漏翻检查" class="headerlink" title="4.翻译进度显示与漏翻检查"></a>4.翻译进度显示与漏翻检查</h2><p>全局所有页面各个语言翻译进度的检查以及全局漏翻检查</p><p><img src="/img/02290760-eb14-4bbd-956c-5c0df22b0ab1.png"></p><p>当前页面的漏翻检查</p><p><img src="/img/77886336-e35b-4af3-986e-3eb1f68d774f.png"></p><p>注：默认中文算漏翻，英文不会统计在内</p><h2 id="5-在线自动翻译（黄云不可用）"><a href="#5-在线自动翻译（黄云不可用）" class="headerlink" title="5. 在线自动翻译（黄云不可用）"></a>5. 在线自动翻译（黄云不可用）</h2><p>可以单个自动翻译</p><p><img src="/img/5f0d99f9-935f-479e-a423-f230651a6c19.png"></p><p>也可一键翻译</p><p><img src="/img/e015e71c-86dc-450b-84e9-f5261f8e3f5e.png"></p><h2 id="6-提取key"><a href="#6-提取key" class="headerlink" title="6.提取key"></a>6.提取key</h2><h3 id="6-1一键提取当前页面key"><a href="#6-1一键提取当前页面key" class="headerlink" title="6.1一键提取当前页面key"></a>6.1一键提取当前页面key</h3><p><img src="/img/ffa34c45-08d8-4eed-ace3-8216d09c3e0d.png"></p><h3 id="6-2半手动快速提取key"><a href="#6-2半手动快速提取key" class="headerlink" title="6.2半手动快速提取key"></a>6.2半手动快速提取key</h3><p><img src="/img/36a36d3d-8acd-4d11-844f-bf738e94061e.png"></p><p><img src="/img/49249dd8-3726-4736-8350-d4081f1851d0.png"></p><h2 id="7-可评论"><a href="#7-可评论" class="headerlink" title="7.可评论"></a>7.可评论</h2><p>用于多人协作以及check，默认评论的文件会存储在<code>.vscode/i18n-ally-reviews.yml</code>中，建议将此文件提交到 git 中。</p><p><img src="/img/8d67ef7f-1d7b-477f-b698-24e5bca92905.png"></p><p><img src="/img/3b30c2e7-f2ca-474b-9aec-4f822de3651f.png"></p><p><img src="/img/b9850b98-7ea6-4d13-882c-8d91d0873e60.png"></p><p><img src="/img/3747fe94-95e3-4ce2-8637-96a24513d5e8.png"></p><p>更多设置参考官网：<a href="https://github.com/lokalise/i18n-ally/wiki">Home · lokalise/i18n-ally Wiki (github.com)</a></p><h1 id="八、推荐方案"><a href="#八、推荐方案" class="headerlink" title="八、推荐方案"></a>八、推荐方案</h1><table><thead><tr><th><strong>静态文案翻译</strong></th><th>通过<a href="http://i18next.github.io/i18next-scanner">i18next-scanner</a> 或者  <strong><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally&source=article&objectId=2349931">i18n Ally</a></strong> 插件自动提取</th></tr></thead><tbody><tr><td><strong>动态文案翻译</strong></td><td>方案一：接口增加语言参数，后端直接返回相应的语言。</td></tr><tr><td>方案二：与后端增加代码映射，将文本放到前端字典中</td><td></td></tr><tr><td><strong>语言包命名空间</strong></td><td>按照【一级菜单】为最小颗粒度</td></tr><tr><td><strong>国际化框架</strong></td><td>采用i18next</td></tr><tr><td><strong>不同语言样式</strong></td><td>利用css选择器特性，单独写相应语言css实现</td></tr><tr><td><strong>RTL布局</strong></td><td>css采用<code>direction：rtl</code> + <code>rtlcs插件</code></td></tr><tr><td><strong>多语言布局</strong></td><td>采用同一套布局（RTL除外）</td></tr><tr><td><strong>本地化</strong></td><td>采用i18next内置api，其中时间本地采用day.js库来完成</td></tr><tr><td><strong>图标图片</strong></td><td>设计针对需要翻转图片图标命名增加-rtl标识</td></tr><tr><td><strong>打包方式</strong></td><td>采用import 按需加载</td></tr><tr><td><strong>翻译检查</strong></td><td>采用<a href="https://github.com/locize/translation-check">translation-check</a>插件</td></tr><tr><td><strong>第三方npm国际化支持</strong></td><td>需要第三方作相应的适配</td></tr><tr><td><strong>辅助工具</strong></td><td><strong>VSCode 的 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally&source=article&objectId=2349931">i18n Ally</a> 插件</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>国际化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>国际化</tag>
      
      <tag>方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>font-family在多语言中的应用</title>
    <link href="/2024/05/05/font-family%E5%9C%A8%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/05/font-family%E5%9C%A8%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="font-family在多语言中的应用"><a href="#font-family在多语言中的应用" class="headerlink" title="font-family在多语言中的应用"></a>font-family在多语言中的应用</h1><h2 id="一、font-family的匹配机制"><a href="#一、font-family的匹配机制" class="headerlink" title="一、font-family的匹配机制"></a>一、font-family的匹配机制</h2><p><code>font-family</code> 属性指定的是一个优先级从高到低的字体列表。字体的选定<em>不是</em>在发现用户计算机上安装的列表中的第一个字体时停止。相反，<code>font-family</code>对<strong>字体选择是逐字进行的，</strong>当一个字体只在某些特定的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style">样式</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant">变体</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size">大小</a>下有效时，这些属性的值也可能对字体族的选择造成影响。</p><p>这意味着浏览器在渲染文本时，不是一旦找到列表中的第一个可用字体就完全使用该字体来显示所有字符。而是对于每个字符，都会依次在字体列表中查找最合适的字体。</p><h2 id="二、font-family的兼容写法"><a href="#二、font-family的兼容写法" class="headerlink" title="二、font-family的兼容写法"></a>二、font-family的兼容写法</h2><p>根据font-family的匹配机制，我们可以为英文、中文等两种字体调用不同的字体来渲染。</p><p>例如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">font-<span class="hljs-attr">family</span>:<span class="hljs-title class_">Arial</span>,<span class="hljs-string">&#x27;Times New Roman&#x27;</span>,<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>,<span class="hljs-title class_">SimHei</span>;   <br></code></pre></td></tr></table></figure><p>像 Arial,’Times New Roman’ 这两种字体不包含中文，只有英文，所以这两种字体只能渲染英文数字和一些特殊符号，而页面中的中文就会自动调用第三种字体Microsoft YaHei。</p><p>再来感受下这个过程：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">font-<span class="hljs-attr">family</span>: <span class="hljs-string">&#x27;Helvetica Neue&#x27;</span>, <span class="hljs-string">&#x27;Helvetica&#x27;</span>, <span class="hljs-string">&#x27;Microsoft Yahei&#x27;</span>, sans-serif;<br></code></pre></td></tr></table></figure><p><img src="/img/image2131454345.png"></p><p>所以在定义字体的时候把英文的字体写在前面把中文的写在后面。这样，系统就会自动按顺序依次给字用字体，如果当前字体不支持文本，自动换用列表中的下一个字体。</p><p>所以我们需要做到以下几点：</p><ul><li><strong>尽量使用系统默认字体</strong><ul><li>以下使用各个系统下默认的<a href="https://zhida.zhihu.com/search?q=%E8%A5%BF%E6%96%87%E5%AD%97%E4%BD%93&zhida_source=entity&is_preview=1">西文字体</a>：<ol><li><code>system-ui</code>，使用各个<a href="https://zhida.zhihu.com/search?q=%E6%94%AF%E6%8C%81%E5%B9%B3%E5%8F%B0&zhida_source=entity&is_preview=1">支持平台</a>上的默认系统字体</li><li><code>apple-system</code>， 在一些稍低版本 Mac OS X 和 iOS 上，升级使用更为合适的旧金山西文字体</li><li><code>BlinkMacSystemFont</code>，针对一些 Mac OS X 上的 Chrome 浏览器，使用系统默认字体</li><li><code>segoe ui</code>，在 Windows 及 Windows Phone 上选取系统默认字体</li><li><code>Roboto</code>，面向 Android 和一些新版的的 Chrome OS</li><li><code>Helvetica,Arial</code>，在针对不同操作系统不同平台设定采用默认系统字体后，针对一些低版本浏览器的降级方案</li><li><code>sans-serif</code>，兜底方案，保证字体风格统一，至少也得是无衬线字体</li></ol>  上述几个字体族定义，优先级由高到底，可以看到，它们 5 个都并非某个特定字体，<strong>基本的核心思想都是选择对应平台上的默认系统字体。</strong></li><li>以下是各个系统下默认的中文字体：<ol><li><code>&quot;PingFang SC&quot;</code> 苹果默认的中文字体</li><li><code>Microsoft Yahei</code> windows默认的中文字体</li></ol></li></ul></li><li><strong>西文在前，中文在后</strong>  由于大部分中文字体也是带有英文部分的，但是英文部分又不怎么好看，同理英文字体中大多不包含中文。所以通常会先进行英文字体的声明，选择最优的英文字体，这样不会影响到中文字体的选择，中文字体声明则紧随其次。</li><li><strong>兼顾多操作系统</strong>  选择字体的时候要考虑多操作系统。例如 MAC OS 下的很多中文字体在 Windows 都没有预装，为了保证 MAC 用户的体验，在定义中文字体的时候，先定义 MAC 用户的中文字体，再定义 Windows 用户的中文字体；</li><li><strong>兼顾旧操作系统，以字体族系列 <code>serif</code> 和 <code>sans-serif</code> 结尾</strong>  当使用一些非常新的字体时，要考虑向下兼容，兼顾到一些极旧的操作系统，使用字体族系列 <code>serif</code> 和<code>sans-serif</code> 结尾总归是不错的选择。</li></ul><h2 id="三、国际化语言字体适配"><a href="#三、国际化语言字体适配" class="headerlink" title="三、国际化语言字体适配"></a>三、国际化语言字体适配</h2><p>在处理国际化时，一般情况下需要我们为每种语言来适配不同字体，来达到视觉的美观行以及不同设备的兼容性，我们需要解决以下两个问题：</p><ul><li>多语言字体混排问题</li><li>某字体的某语言字体不好看，想使用不同字体文件的不同字体或符号</li></ul><h3 id="问题一：解决字体混排问题"><a href="#问题一：解决字体混排问题" class="headerlink" title="问题一：解决字体混排问题"></a>问题一：解决字体混排问题</h3><p><strong>方法一：利用lang属性或者:lang伪元素根据语言匹配不同字体家族，再通过必要的标签动态添加</strong><code>lang</code>标签</p><ul><li>以下以 <a href="https://w3c.github.io/clreq/local.css">github</a>为参考：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 来源自 https://w3c.github.io/clreq/local.css */</span><br><span class="hljs-selector-attr">[lang=zh-hant]</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;PingFang TC&#x27;</span>, <span class="hljs-string">&#x27;Noto Sans CJK TC&#x27;</span>, <span class="hljs-string">&#x27;Heiti TC&#x27;</span>, <span class="hljs-string">&#x27;Microsoft JhengHei&#x27;</span>, Helvetica, Segoe UI, Arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-attr">[lang=zh-hans]</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;PingFang SC&#x27;</span>, <span class="hljs-string">&#x27;Noto Sans CJK SC&#x27;</span>, <span class="hljs-string">&#x27;Heiti SC&#x27;</span>, <span class="hljs-string">&#x27;DengXian&#x27;</span>, <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>, Helvetica, Segoe UI, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 来源自 https://w3c.github.io/clreq/ --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">its-locale-filter-list</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Each cultural community has its own language, script and writing system. The transfer of each and every writing system into cyberspace is a task of utmost importance for information and communication technology.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">its-locale-filter-list</span>=<span class="hljs-string">&quot;zh-hans&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-hans&quot;</span>&gt;</span>每一个文化群体都拥有独自的语言、文字、书写系统。将个别书写系统在虚拟空间再现，对文化资产的承继而言，是信息传播技术的重要责任。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">its-locale-filter-list</span>=<span class="hljs-string">&quot;zh-hant&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-hant&quot;</span>&gt;</span>每一個文化群體都擁有獨自的語言、文字、書寫系統。將個別書寫系統在虛擬空間再現，對文化資產的承繼而言，是資訊傳播技術的重要責任。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>以<a href="https://www.apple.com.cn/cn/">苹果公司中文首页</a>为例：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 来源自 https://www.apple.com.cn/v/home/er/built/styles/main.built.css */</span><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif;<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(ja) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro JP&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;Hiragino Kaku Gothic Pro&quot;</span>,<span class="hljs-string">&quot;ヒラギノ角ゴ Pro W3&quot;</span>,<span class="hljs-string">&quot;メイリオ&quot;</span>,<span class="hljs-string">&quot;Meiryo&quot;</span>,<span class="hljs-string">&quot;ＭＳ Ｐゴシック&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(ko) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro KR&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;Apple Gothic&quot;</span>,<span class="hljs-string">&quot;HY Gulim&quot;</span>,<span class="hljs-string">&quot;MalgunGothic&quot;</span>,<span class="hljs-string">&quot;HY Dotum&quot;</span>,<span class="hljs-string">&quot;Lexi Gulim&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(zh-CN) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro SC&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;PingFang SC&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(zh-HK) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro HK&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;PingFang HK&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(zh-MO) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro HK&quot;</span>,<span class="hljs-string">&quot;SF Pro TC&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;PingFang HK&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br><br><span class="hljs-selector-attr">[lang]</span><span class="hljs-selector-pseudo">:lang</span>(zh-TW) &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro TC&quot;</span>,<span class="hljs-string">&quot;SF Pro Text&quot;</span>,<span class="hljs-string">&quot;SF Pro Icons&quot;</span>,<span class="hljs-string">&quot;PingFang TC&quot;</span>,<span class="hljs-string">&quot;Helvetica Neue&quot;</span>,<span class="hljs-string">&quot;Helvetica&quot;</span>,<span class="hljs-string">&quot;Arial&quot;</span>,sans-serif<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的这段 CSS 同样是使用 <code>:lang</code> 伪类为不同语言、地区指定不同的字体。</p><p>最后，演示一下中英文混排，样式参见上面的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">p</span> lang=&quot;zh-hans&quot;&gt;苹果公司联合创始人史蒂夫·乔布斯（&lt;<span class="hljs-selector-tag">span</span> lang=&quot;en&quot;&gt;Steve Jobs&lt;/<span class="hljs-selector-tag">span</span>&gt;）在斯坦福大学<span class="hljs-number">2005</span>年毕业典礼上的演讲中曾提到过一句名言“&lt;<span class="hljs-selector-tag">span</span> lang=&quot;en&quot;&gt;Stay hungry, stay foolish.&lt;/<span class="hljs-selector-tag">span</span>&gt;”&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>方法二：利用font-family的回退机制</strong></p><p>如果设计要求不高可以采用一种更简单粗暴的方法，利用浏览器字体的回退机制，将西文字体写在前面，中文字体写在后面，这样也可以实现字母数字渲染为西文字体，中文部分渲染为中文字体。</p><ul><li>以下以 <a href="http://airbnb.com/">Airbnb</a> 为参考：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx">[lang=<span class="hljs-string">&quot;ja&quot;</span>] body&#123;<br>    font-<span class="hljs-attr">family</span>:<span class="hljs-string">&quot;ヒラギノ角ゴ Pro&quot;</span>,<span class="hljs-string">&quot;Hiragino Kaku Gothic Pro&quot;</span>,<span class="hljs-string">&quot;メイリオ&quot;</span>,<span class="hljs-title class_">Meiryo</span>,<span class="hljs-title class_">Osaka</span>,<span class="hljs-string">&quot;ＭＳ Ｐゴシック&quot;</span>,<span class="hljs-string">&quot;MS PGothic&quot;</span>,<span class="hljs-string">&quot;MS Gothic”,</span><br><span class="hljs-string">    &quot;</span>ＭＳ ゴシック<span class="hljs-string">&quot;,&quot;</span><span class="hljs-title class_">Helvetica</span> <span class="hljs-title class_">Neue</span>”,<span class="hljs-title class_">Helvetica</span>,<span class="hljs-title class_">Arial</span>,<br>    sans-serif !important<br>&#125;<br>[lang=<span class="hljs-string">&quot;ko&quot;</span>] body&#123;<br>    font-<span class="hljs-attr">family</span>:<span class="hljs-string">&quot;나눔 고딕&quot;</span>,<span class="hljs-string">&quot;Nanum Gothic&quot;</span>,<span class="hljs-string">&quot;맑은 고딕&quot;</span>,<span class="hljs-string">&quot;Malgun Gothic”,</span><br><span class="hljs-string">    &quot;</span><span class="hljs-title class_">Apple</span> <span class="hljs-title class_">Gothic</span><span class="hljs-string">&quot;,&quot;</span>돋움<span class="hljs-string">&quot;,Dotum,&quot;</span><span class="hljs-title class_">Helvetica</span> <span class="hljs-title class_">Neue</span>”,<span class="hljs-title class_">Helvetica</span>,<br>    <span class="hljs-title class_">Arial</span>,sans-serif !important<br>&#125;<br>[lang^=<span class="hljs-string">&quot;zh&quot;</span>] body&#123;<br>    font-<span class="hljs-attr">family</span>:<span class="hljs-string">&quot;Hiragino Sans GB”,&quot;</span>华文细黑<span class="hljs-string">&quot;,&quot;</span><span class="hljs-title class_">STHeiti</span><span class="hljs-string">&quot;,&quot;</span>微软雅黑<span class="hljs-string">&quot;,</span><br><span class="hljs-string">    &quot;</span><span class="hljs-title class_">Microsoft</span> <span class="hljs-title class_">YaHei</span><span class="hljs-string">&quot;,SimHei,&quot;</span><span class="hljs-title class_">Helvetica</span> <span class="hljs-title class_">Neue</span>”,<span class="hljs-title class_">Helvetica</span>,<span class="hljs-title class_">Arial</span>,<br>    sans-serif !important<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题二：解决使用不同字体文件的部分字体或符号问题"><a href="#问题二：解决使用不同字体文件的部分字体或符号问题" class="headerlink" title="问题二：解决使用不同字体文件的部分字体或符号问题"></a>问题二：解决使用不同字体文件的部分字体或符号问题</h3><p>这种方式设置 <code>unicode-range</code> 属性时需要明确字符的 Unicode 范围，在利用<code>font-family</code>按字符的匹配机制。</p><p>这种方式一般仅针对少量字符做处理，适合处理中文双引号展示、人民币符号、等宽字体显示时间等问题。</p><p>用法可参考如下 antd 的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 来源自 https://fonts.googleapis.com/css?family=Open%20Sans:300,400,600,700&amp;lang=en */</span><br><br><span class="hljs-comment">/* cyrillic */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OVuhpKKSTj5PW.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0400</span>-<span class="hljs-number">045</span>F, U+<span class="hljs-number">0490</span>-<span class="hljs-number">0491</span>, U+<span class="hljs-number">04</span>B0-<span class="hljs-number">04</span>B1, U+<span class="hljs-number">2116</span>;<br>&#125;<br><br><span class="hljs-comment">/* greek */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OUehpKKSTj5PW.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0370</span>-<span class="hljs-number">03</span>FF;<br>&#125;<br><br><span class="hljs-comment">/* latin */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OUuhpKKSTjw.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0000</span>-<span class="hljs-number">00</span>FF, U+<span class="hljs-number">0131</span>, U+<span class="hljs-number">0152</span>-<span class="hljs-number">0153</span>, U+<span class="hljs-number">02</span>BB-<span class="hljs-number">02</span>BC, U+<span class="hljs-number">02</span>C6, U+<span class="hljs-number">02</span>DA, U+<span class="hljs-number">02</span>DC, U+<span class="hljs-number">2000</span>-<span class="hljs-number">206</span>F, U+<span class="hljs-number">2074</span>, U+<span class="hljs-number">20</span>AC, U+<span class="hljs-number">2122</span>, U+<span class="hljs-number">2191</span>, U+<span class="hljs-number">2193</span>, U+<span class="hljs-number">2212</span>, U+<span class="hljs-number">2215</span>, U+FEFF, U+FFFD;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中指定 U+0030 - U+0039 的字符（即 0-9）使用 Helvetica Neue 字体，U+2018, U+2019, U+201C, U+201D（即单引号、双引号）使用苹方-简、中易宋体。</p><p>除此以外还可以参考 Google Fonts 的 CSS，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 来源自 https://fonts.googleapis.com/css?family=Open%20Sans:300,400,600,700&amp;lang=en */</span><br><br><span class="hljs-comment">/* cyrillic */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OVuhpKKSTj5PW.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0400</span>-<span class="hljs-number">045</span>F, U+<span class="hljs-number">0490</span>-<span class="hljs-number">0491</span>, U+<span class="hljs-number">04</span>B0-<span class="hljs-number">04</span>B1, U+<span class="hljs-number">2116</span>;<br>&#125;<br><br><span class="hljs-comment">/* greek */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OUehpKKSTj5PW.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0370</span>-<span class="hljs-number">03</span>FF;<br>&#125;<br><br><span class="hljs-comment">/* latin */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Open Sans&#x27;</span>;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;Open Sans Light&#x27;</span>), <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OpenSans-Light&#x27;</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">https://fonts.gstatic.com/s/opensans/v17/mem5YaGs126MiZpBA-UN_r8OUuhpKKSTjw.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  unicode-range: U+<span class="hljs-number">0000</span>-<span class="hljs-number">00</span>FF, U+<span class="hljs-number">0131</span>, U+<span class="hljs-number">0152</span>-<span class="hljs-number">0153</span>, U+<span class="hljs-number">02</span>BB-<span class="hljs-number">02</span>BC, U+<span class="hljs-number">02</span>C6, U+<span class="hljs-number">02</span>DA, U+<span class="hljs-number">02</span>DC, U+<span class="hljs-number">2000</span>-<span class="hljs-number">206</span>F, U+<span class="hljs-number">2074</span>, U+<span class="hljs-number">20</span>AC, U+<span class="hljs-number">2122</span>, U+<span class="hljs-number">2191</span>, U+<span class="hljs-number">2193</span>, U+<span class="hljs-number">2212</span>, U+<span class="hljs-number">2215</span>, U+FEFF, U+FFFD;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、字体版权"><a href="#四、字体版权" class="headerlink" title="四、字体版权"></a>四、字体版权</h2><p>在页面中，字体引入方式有两种：</p><h3 id="1-通过CSS样式直接声明字体："><a href="#1-通过CSS样式直接声明字体：" class="headerlink" title="1.通过CSS样式直接声明字体："></a>1.通过CSS样式直接声明字体：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>  <span class="hljs-attribute">font-family</span>: Helvetica Neue,PingFang SC,<br>Microsoft YaHei, Source Han Sans SC,Noto Sans CJK SC,sans-serif;<br> &#125;<br>// 网页渲染时，浏览器会通过上面所定义的字体，<br>// 按顺序检索系统是否有该字体，有就用该字体渲染，没有就继续检索，<br>// 如果一直检索不到，浏览器会自动渲染宋体（SimSun）。<br></code></pre></td></tr></table></figure><p>CSS的 <strong>font-family</strong> 指的是指定字体，建议访客的浏览器优先使用这些字体来显示，如果访客的系统中没有安装这些指定的字体，则用默认字体来显示。注意这种方式不管指定何种字体都不涉及侵权，这种方式是在合法范围。</p><h3 id="2-通过CSS样式嵌入字体："><a href="#2-通过CSS样式嵌入字体：" class="headerlink" title="2.通过CSS样式嵌入字体："></a>2.通过CSS样式嵌入字体：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;fontname&quot;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/fontname.eot);</span><br><span class="hljs-string">  src: url(&#x27;</span><span class="hljs-string">fonts/fontname.eot</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),<br>  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/fontname.ttf) format(&#x27;</span><span class="hljs-string">truetype&#x27;</span>), <br>  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/fontname.svg) format(&#x27;</span><span class="hljs-string">svg&#x27;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>CSS的 <strong>font-face</strong> 指的是加载字体。这种方式需要引入相关字体文件，涉及到字体文件的实体，不管访客的系统有没有安装这些字体，都会加载字体文件实体。加载后，网页相关文字就会按照设定的字体显示。如果加载的字体有版权保护，而你的网页没有取得使用授权，那么就涉及到版权问题了。这种侵权会按照使用时长、字数来计算赔偿。</p>]]></content>
    
    
    <categories>
      
      <category>国际化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>国际化</tag>
      
      <tag>字体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国际化 i18n-Ally 插件配置入门</title>
    <link href="/2024/04/20/%E5%9B%BD%E9%99%85%E5%8C%96%20i18n-Ally%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/20/%E5%9B%BD%E9%99%85%E5%8C%96%20i18n-Ally%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="国际化-i18n-Ally-插件配置入门"><a href="#国际化-i18n-Ally-插件配置入门" class="headerlink" title="国际化 i18n-Ally 插件配置入门"></a>国际化 i18n-Ally 插件配置入门</h1><h2 id="1-增强语言包开发体验"><a href="#1-增强语言包开发体验" class="headerlink" title="1. 增强语言包开发体验"></a>1. 增强语言包开发体验</h2><ul><li>能够在编辑器回显 key 对应的中文</li><li>能够点击跳转到 key 定义的语言包</li><li>能够分析语言包是否被引用、有没有重复、缺译的情况</li><li>支持 key 重命名(重构)</li><li>能自动发现文本硬编码，并支持提取</li><li>支持<a href="https://cloud.tencent.com/product/tmt?from_column=20065&from=20065">机器翻译</a></li><li>提供协同翻译…</li></ul><p><em>【问题】如果无法发现 i18n ally 插件没有启用，那大概率就是它检测失败了, 可以在 <code>OUTPUT</code> Panel 下看的日志：</em></p><p><img src="/img/f5cafccb4ef59043b0791e9f04dd86ec.png"></p><p>解决办法就是显式告诉它：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// .vscode/setting.json</span><br>&#123;<br>  <span class="hljs-string">&quot;i18n-ally.enabledFrameworks&quot;</span>: [<span class="hljs-string">&quot;vue&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-自定义语言包检查目录。"><a href="#2-自定义语言包检查目录。" class="headerlink" title="2. 自定义语言包检查目录。"></a>2. 自定义语言包检查目录。</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// .vscode/setting.json</span><br>&#123;<br>  <span class="hljs-comment">// 支持在所有嵌套的 locales、i18n 目录下发现语言包</span><br>  <span class="hljs-string">&quot;i18n-ally.localesPaths&quot;</span>: [<span class="hljs-string">&quot;**/locales&quot;</span>, <span class="hljs-string">&quot;**/i18n&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是复杂项目结构，可能会出现无法识别key的问题，需要使用到pathMatcher来告诉i18n-ally插件我们的目录结构</p><table><thead><tr><th>匹配器</th><th>描述</th></tr></thead><tbody><tr><td><code>&#123;locale&#125;</code></td><td>匹配区域设置代码等。<code>en-USzh-CNfr</code></td></tr><tr><td><code>&#123;namespace&#125;</code></td><td>匹配任何内容不包括文件夹分隔符。它只匹配一个级别的目录<code>/</code></td></tr><tr><td><code>&#123;namespaces&#125;</code></td><td>匹配任何东西。它可以匹配多个级别的目录。文件夹分隔符将转换为 in 键路径<code>.</code></td></tr><tr><td><code>&#123;ext&#125;</code></td><td>文件扩展名，基于当前启用的分析程序</td></tr><tr><td><code>&#123;locale?&#125;</code></td><td>如果未捕获区域设置，则将应用当前源语言的可选版本<code>&#123;locale&#125;</code></td></tr><tr><td><code>&#123;namespace?&#125;</code></td><td>可选版本<code>&#123;namespace&#125;</code></td></tr><tr><td><code>&#123;namespaces?&#125;</code></td><td>可选版本<code>&#123;namespaces&#125;</code></td></tr></tbody></table><h3 id="2-1-目录结构1"><a href="#2-1-目录结构1" class="headerlink" title="2.1 目录结构1"></a>2.1 目录结构1</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n<br>  ├── zh<br>  |   ├── general<br>  |   |   └── ...<br>  |   ├── attributes<br>  |   |   └── foo.<span class="hljs-property">json</span><br>  |   └── ...<br>  ├── en<br>  |   ├── general<br>  |   |   └── ...<br>  |   ├── attributes<br>  |   |   └── foo.<span class="hljs-property">yaml</span><br>  |   └── ...<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Path Matcher</span><br><span class="hljs-string">&#x27;&#123;locale&#125;/&#123;namespaces&#125;.json&#x27;</span><br><br><span class="hljs-comment">// Example Path</span><br><span class="hljs-string">&#x27;nl-NL/attributes/foo.json&#x27;</span><br><br><span class="hljs-comment">// Matched result</span><br>&#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;nl-NL&#x27;</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;attributes.foo&#x27;</span> &#125;<br><br><span class="hljs-comment">// Example usage</span><br>$t(<span class="hljs-string">&#x27;attributes.foo.your-key&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-例如目录结构2"><a href="#2-2-例如目录结构2" class="headerlink" title="2.2 例如目录结构2"></a>2.2 例如目录结构2</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx">i18n<br>  ├── general<br>  |   ├── nl.<span class="hljs-property">json</span><br>  |   ├── de.<span class="hljs-property">json</span><br>  |   ├── en.<span class="hljs-property">json</span><br>  |   └── ...<br>  ├── attributes<br>  |   ├── foo<br>  |   |   ├── nl.<span class="hljs-property">json</span><br>  |   |   ├── de.<span class="hljs-property">json</span><br>  |   |   ├── en.<span class="hljs-property">json</span><br>  |   |   └── ...<br>  |   ├── bar<br>  |   |    └── ...<br>  |   └── ...<br>  ├──  resources<br>  |    └── ...<br>  └── ...<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Path Matcher</span><br><span class="hljs-string">&#x27;&#123;namespaces&#125;/&#123;locale&#125;.json&#x27;</span><br><br><span class="hljs-comment">// Example Path</span><br><span class="hljs-string">&#x27;attributes/bar/en.json&#x27;</span><br><br><span class="hljs-comment">// Matched result</span><br>&#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;attributes.bar&#x27;</span> &#125;<br><br><span class="hljs-comment">// Example usage</span><br>$t(<span class="hljs-string">&#x27;attributes.bar.your-key&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-语言包配置"><a href="#3-语言包配置" class="headerlink" title="3. 语言包配置"></a>3. 语言包配置</h2><p>上文使用的是 <code>.tr</code> 扩展名， i18n ally 并不能识别它，可以通过下面的配置来告诉它如何处理 tr 文件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// .vscode/setting.json</span><br>&#123;<br>  <span class="hljs-comment">// 语言包的命名规则</span><br>  <span class="hljs-string">&quot;i18n-ally.pathMatcher&quot;</span>: <span class="hljs-string">&quot;&#123;locale&#125;.tr&quot;</span>,<br>  <span class="hljs-comment">// 语言包的 parser</span><br>  <span class="hljs-string">&quot;i18n-ally.parsers.extendFileExtensions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tr&quot;</span>: <span class="hljs-string">&quot;json&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-其他常见配置"><a href="#4-其他常见配置" class="headerlink" title="4. 其他常见配置"></a>4. 其他常见配置</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>  <span class="hljs-comment">// 源语言。主要会影响翻译，即以哪个语言为源语言翻译到其他语种。中文开发者通常设置为中文</span><br>  <span class="hljs-string">&quot;i18n-ally.sourceLanguage&quot;</span>: <span class="hljs-string">&quot;zh&quot;</span>,<br>  <span class="hljs-comment">// 在编辑器内联提示的语种</span><br>  <span class="hljs-string">&quot;i18n-ally.displayLanguage&quot;</span>: <span class="hljs-string">&quot;zh&quot;</span>,<br>  <span class="hljs-comment">// 语言包的组织形式，nested 表示嵌套对象模式</span><br>  <span class="hljs-string">&quot;i18n-ally.keystyle&quot;</span>: <span class="hljs-string">&quot;nested&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>更多的配置可以看它的<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/lokalise/i18n-ally/wiki&source=article&objectId=2349931">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>国际化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>国际化</tag>
      
      <tag>vscode插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用patch-package给npm包打补丁</title>
    <link href="/2023/11/08/%E4%BD%BF%E7%94%A8patch-package%E7%BB%99npm%E5%8C%85%E6%89%93%E8%A1%A5%E4%B8%81/"/>
    <url>/2023/11/08/%E4%BD%BF%E7%94%A8patch-package%E7%BB%99npm%E5%8C%85%E6%89%93%E8%A1%A5%E4%B8%81/</url>
    
    <content type="html"><![CDATA[<h1 id="使用patch-package给npm包打补丁"><a href="#使用patch-package给npm包打补丁" class="headerlink" title="使用patch-package给npm包打补丁"></a>使用<strong>patch-package给npm包打补丁</strong></h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>在日常开发中，如果遇到一些依赖包有bug，但是我们又等不急官方版本升级去修复这个问题。又或者，我们升级包版本依赖后，发现新版本有bug，需要部分代码回退的时候，我们就可以通过使用<code>patch-package</code>修改依赖包。</p><h1 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h1><h2 id="1-安装-patch-package"><a href="#1-安装-patch-package" class="headerlink" title="1. 安装 patch-package"></a>1. 安装 patch-package</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm i patch<span class="hljs-literal">-package</span> <span class="hljs-literal">--save-dev</span><br></code></pre></td></tr></table></figure><h2 id="2-修改npm包"><a href="#2-修改npm包" class="headerlink" title="2. 修改npm包"></a>2. 修改npm包</h2><p>在项目根目录下的 node_modules 文件夹中找到要修改依赖包的相关文件，然后根据我们的需求直接修改npm包源码，然后运行<code>npm run dev</code>，测试项目直到没有问题。</p><h2 id="3-打补丁"><a href="#3-打补丁" class="headerlink" title="3. 打补丁"></a>3. 打补丁</h2><p>回到根目录执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm patch<span class="hljs-literal">-package</span> package<span class="hljs-literal">-name</span> // package<span class="hljs-literal">-name</span>是要修改的依赖包名<br></code></pre></td></tr></table></figure><p>执行完成后，会在项目根目录的 patches 目录中创建补丁文件 package-name+5.5.1.patch（5.5.1 是依赖包版本），这个补丁需要提交到代码仓库中;</p><p>例如，我修改<code>ant-design</code>中的代码，然后在根目录执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm patch<span class="hljs-literal">-package</span> antd<br></code></pre></td></tr></table></figure><p>然后就会生成布丁文件：，如下所示：</p><p><img src="/img/d0677488-65fa-4ace-a934-3d38b17b5df9.png"></p><p><code>patch-package</code>会将当前<code>node_modules</code>下的源码与原始源码进行<code>git diff</code>，并在项目根目录下生成一个<code>patch</code>补丁文件。</p><p><img src="/img/521de3ef-551e-4e80-b97e-3cb9ed1ac115.png"></p><h2 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a><strong>4. 部署</strong></h2><p>当其他同事拉到代码如何应用补丁呢？基于上述操作我们在<code>npm install</code>后执行<code>patch-package</code>命令即可</p><p>这个流程可借助<code>npm script</code>实现，在<code>package.json</code>的<code>script</code>中添加如下字段及内容，后续在执行完install相关命令时就会自动执行<code>patch-package命令</code>，也就是自动为依赖打包了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;postinstall&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;patch-package&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5. 拓展"></a><strong>5. 拓展</strong></h2><ol><li><code>-reverse</code>撤回所有补丁Note: 如果打补丁后，补丁文件被修改过，此操作将失败，此时可以重新安装 node_modules</li><li><code>-patch-dir</code>指定补丁文件所在目录</li></ol><h1 id="三、patch-package优势"><a href="#三、patch-package优势" class="headerlink" title="三、patch-package优势"></a>三、<strong>patch-package优势</strong></h1><h2 id="1-快速修复问题"><a href="#1-快速修复问题" class="headerlink" title="1.快速修复问题"></a><strong>1.快速修复问题</strong></h2><h3 id="1-1-无需等待官方更新"><a href="#1-1-无需等待官方更新" class="headerlink" title="1.1 无需等待官方更新"></a>1.1 无需等待官方更新</h3><ul><li>当在使用某个依赖包时发现一个紧急的 bug，但依赖包的官方更新可能需要一段时间才能发布。使用 “patch-package” 可以立即为这个有问题的依赖包打补丁，快速解决问题，避免因等待官方更新而影响项目进度。</li></ul><h3 id="1-2-针对特定项目定制修复"><a href="#1-2-针对特定项目定制修复" class="headerlink" title="1.2 针对特定项目定制修复"></a>1.2 针对特定项目定制修复</h3><ul><li>不同的项目可能对同一个依赖包有不同的使用场景和需求。“patch-package” 允许针对特定项目进行定制化的修复，而不会影响到其他使用该依赖包的项目。</li></ul><h2 id="2-灵活的补丁管理"><a href="#2-灵活的补丁管理" class="headerlink" title="2. 灵活的补丁管理"></a><strong>2. 灵活的补丁管理</strong></h2><h3 id="2-1-易于应用和撤销"><a href="#2-1-易于应用和撤销" class="headerlink" title="2.1 易于应用和撤销"></a>2.1 易于应用和撤销</h3><ul><li>应用补丁非常简单，只需要运行一个命令即可将补丁应用到项目中。如果后续发现补丁有问题或者不再需要，可以轻松地撤销补丁。</li><li>这使得开发人员可以在不破坏项目结构的情况下，快速尝试不同的修复方案，提高开发效率。</li></ul><h3 id="2-2-可与版本控制系统集成"><a href="#2-2-可与版本控制系统集成" class="headerlink" title="2.2 可与版本控制系统集成"></a>2.2 可与版本控制系统集成</h3><ul><li>“patch-package” 生成的补丁文件可以方便地与版本控制系统（如 Git）集成。这样，团队成员可以轻松地共享和管理补丁，确保项目的一致性。</li><li>当多个开发人员在同一个项目上工作时，一个人应用的补丁可以通过版本控制系统推送给其他成员，避免重复劳动和不一致性。</li></ul><h2 id="3-可持续的开发流程"><a href="#3-可持续的开发流程" class="headerlink" title="3.可持续的开发流程"></a><strong>3.可持续的开发流程</strong></h2><h3 id="3-1-不破坏依赖包升级流程"><a href="#3-1-不破坏依赖包升级流程" class="headerlink" title="3.1 不破坏依赖包升级流程"></a>3.1 不破坏依赖包升级流程</h3><ul><li>当依赖包的官方版本发布更新时，“patch-package” 可以与正常的依赖包升级流程共存。在升级依赖包后，可以检查补丁是否仍然适用，并根据需要进行调整。</li><li>这意味着即使依赖包不断更新，项目中的特定修复也可以持续存在，而不会被新版本覆盖。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修改源码</tag>
      
      <tag>打补丁</tag>
      
      <tag>patch-package</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端主题方案对比总结</title>
    <link href="/2023/09/01/%E5%89%8D%E7%AB%AF%E4%B8%BB%E9%A2%98%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/01/%E5%89%8D%E7%AB%AF%E4%B8%BB%E9%A2%98%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前端主题方案调研"><a href="#前端主题方案调研" class="headerlink" title="前端主题方案调研"></a>前端主题方案调研</h1><h2 id="方案1：link标签动态引入"><a href="#方案1：link标签动态引入" class="headerlink" title="方案1：link标签动态引入"></a><strong>方案1：link标签动态引入</strong></h2><p>其做法就是提前准备好几套<code>CSS</code>主题样式文件，在需要的时候，创建<code>link</code>标签动态加载到<code>head</code>标签中，或者是动态改变<code>link</code>标签的<code>href</code>属性。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>实现了按需加载，提高了首屏加载时的性能</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次切换主题都会请求新的css主题文件，会<strong>导致卡顿，切换不丝滑</strong></li><li>如果主题样式表内定义不当，会有<strong>优先级问题</strong></li><li>后续新增主题麻烦，扩展性不好</li></ul><h2 id="方案2：提前引入所有主题样式，做类名切换"><a href="#方案2：提前引入所有主题样式，做类名切换" class="headerlink" title="方案2：提前引入所有主题样式，做类名切换"></a><strong>方案2：提前引入所有主题样式，做类名切换</strong></h2><p>为解决【方案一】需要反复切换主题文件导致的卡顿问题，提前将样式全部引入，在需要切换主题的时候将<strong>指定的根元素类名更换</strong>，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* day样式主题 */</span><br><br>body.<span class="hljs-property">day</span> .<span class="hljs-property">box</span> &#123;<br>  <span class="hljs-attr">color</span>: #f90;<br>  <span class="hljs-attr">background</span>: #fff;<br>&#125;<br><br><span class="hljs-comment">/* dark样式主题 */</span><br>body.<span class="hljs-property">dark</span> .<span class="hljs-property">box</span> &#123;<br>  <span class="hljs-attr">color</span>: #eee;<br>  <span class="hljs-attr">background</span>: #<span class="hljs-number">333</span>;<br>&#125;<br><br>.<span class="hljs-property">box</span> &#123;<br>  <span class="hljs-attr">width</span>: 100px;<br>  <span class="hljs-attr">height</span>: 100px;<br>  <span class="hljs-attr">border</span>: 1px solid #<span class="hljs-number">000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>不用重新加载样式文件，在样式切换时不会有卡顿</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>首屏加载会牺牲些时间加载样式资源</li><li>样式主题表定义不当，会有优先级问题</li><li>后续新增主题麻烦，扩展性不好</li></ul><h2 id="方案3：CSS变量-类名切换"><a href="#方案3：CSS变量-类名切换" class="headerlink" title="方案3：CSS变量+类名切换"></a><strong>方案3：CSS变量+类名切换</strong></h2><p>方案3在方案2的基础上，将类名中的样式的值通过CSS变量提取出来。只需要在不同的主题下更改CSS变量对应的取值即可，解决了【方案2】中扩展性不好的缺点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 定义根作用域下的变量 */</span><br>:root &#123;<br>  --theme-<span class="hljs-attr">color</span>: #<span class="hljs-number">333</span>;<br>  --theme-<span class="hljs-attr">background</span>: #eee;<br>&#125;<br><br><span class="hljs-comment">/* 更改dark类名下变量的取值 */</span><br>.<span class="hljs-property">dark</span>&#123;<br>  --theme-<span class="hljs-attr">color</span>: #eee;<br>  --theme-<span class="hljs-attr">background</span>: #<span class="hljs-number">333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 更改pink类名下变量的取值 */</span><br>.<span class="hljs-property">pink</span>&#123;<br>  --theme-<span class="hljs-attr">color</span>: #fff;<br>  --theme-<span class="hljs-attr">background</span>: pink;<br>&#125;<br><br>.<span class="hljs-property">box</span> &#123;<br>  <span class="hljs-attr">transition</span>: all .2s;<br>  <span class="hljs-attr">width</span>: 100px;<br>  <span class="hljs-attr">height</span>: 100px;<br>  <span class="hljs-attr">border</span>: 1px solid #<span class="hljs-number">000</span>;<br>  <span class="hljs-comment">/* 使用变量 */</span><br>  <span class="hljs-attr">color</span>: <span class="hljs-title function_">var</span>(--theme-color);<br>  <span class="hljs-attr">background</span>: <span class="hljs-title function_">var</span>(--theme-background);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>不用重新加载样式文件，<strong>在样式切换时不会有卡顿</strong></li><li>在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题</li><li>新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li><del>IE兼容性（忽略不计）</del></li><li>首屏加载时会牺牲一些时间加载样式资源</li></ul><h2 id="方案4：CSS变量-theme-mode"><a href="#方案4：CSS变量-theme-mode" class="headerlink" title="方案4：CSS变量 + theme-mode"></a><strong>方案4：CSS变量 + theme-mode</strong></h2><p>将类名切换改为通过自定义属性theme-mode来控制，不用添加额外的类名，简化操作，让代码更好理解和维护</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 定义根作用域下的变量 */</span><br>:root &#123;<br>  --theme-<span class="hljs-attr">color</span>: #<span class="hljs-number">333</span>;<br>  --theme-<span class="hljs-attr">background</span>: #eee;<br>&#125;<br><br><span class="hljs-comment">/* 更改dark主题下变量的取值 */</span><br>:root[theme-mode=<span class="hljs-string">&quot;dark&quot;</span>]&#123;<br>  --theme-<span class="hljs-attr">color</span>: #eee;<br>  --theme-<span class="hljs-attr">background</span>: #<span class="hljs-number">333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 更改pink主题下变量的取值 */</span><br>:root[theme-mode=<span class="hljs-string">&quot;pink&quot;</span>]&#123;<br>  --theme-<span class="hljs-attr">color</span>: #fff;<br>  --theme-<span class="hljs-attr">background</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>简化代码，代码更好维护</li><li>其余与【方案三】优点相同</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li><del>IE兼容性（忽略不计）</del></li><li>首屏加载时会牺牲一些时间加载样式资源</li></ul><h2 id="方案5：SCSS-CSS变量-theme-mode"><a href="#方案5：SCSS-CSS变量-theme-mode" class="headerlink" title="方案5：SCSS + CSS变量 + theme-mode"></a><strong>方案5：SCSS + CSS变量 + theme-mode</strong></h2><p>通过引入SCSS的变量使得主题的设定和代码更好维护，前提是需要我们需要一套严格的UI制定规范，才能设定一套扩展性强的CSS变量库，示例的方案是<strong>使得变量成树形结构，每次需要更改主题方案，只需更改树的根部（也就是root中的变量）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 定义根作用域下的变量 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--base-color1</span>: <span class="hljs-number">#333</span>;<br>  <span class="hljs-attr">--base-color2</span>: <span class="hljs-number">#eee</span>;<br>&#125;<br><br><span class="hljs-comment">/* 更改dark主题下变量的取值 */</span><br><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-attr">[theme-mode=<span class="hljs-string">&quot;dark&quot;</span>]</span>&#123;<br>  <span class="hljs-attr">--base-color1</span>: <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attr">--base-color2</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 更改pink主题下变量的取值 */</span><br><span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-attr">[theme-mode=<span class="hljs-string">&quot;pink&quot;</span>]</span>&#123;<br>  <span class="hljs-attr">--base-color1</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attr">--base-color2</span>: pink;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>$theme-<span class="hljs-attribute">color</span>:<span class="hljs-built_in">var</span>(--base-color1)<br>$theme-background:<span class="hljs-built_in">var</span>(--base-color2)<br></code></pre></td></tr></table></figure><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>简化代码，比【方案四】更加灵活，代码更好维护</li><li>其余域【方案四】优点相同</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li><del>IE兼容性（忽略不计）</del></li><li>首屏加载时会牺牲一些时间加载样式资源</li></ul><h3 id="【思考】为什么同时使用CSS变量和SCSS变量，各自有什么作用？"><a href="#【思考】为什么同时使用CSS变量和SCSS变量，各自有什么作用？" class="headerlink" title="【思考】为什么同时使用CSS变量和SCSS变量，各自有什么作用？"></a>【思考】为什么同时使用CSS变量和SCSS变量，各自有什么作用？</h3><ol><li>CSS 变量是浏览器原生支持的特性，可在运行时通过 JavaScript 动态修改，因为浏览器能直接处理。而 SCSS 变量是在编译阶段被处理，编译后成为固定的 CSS 属性值，无法在运行时直接修改。</li><li>CSS 变量适合运行时动态样式变化，SCSS 变量主要用于开发阶段提高代码可维护性，不适合运行时频繁动态更改。</li></ol><h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><ol><li>如果对首屏加载性能要求高且用户不太可能切换主题，可以考虑【方案 1】</li><li>如果希望切换主题时流畅且不考虑 IE 兼容性，【方案 3、4、5 】都是不错的选择<ol><li>其中【方案 5 】可能在代码维护性上更优一些</li><li>如果希望代码简洁且不考虑首屏加载时间和 IE 兼容性，【方案 4 】也比较合适</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>主题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主题</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pa11y源码分享</title>
    <link href="/2023/08/22/pa11y%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"/>
    <url>/2023/08/22/pa11y%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="pa11y源码分享"><a href="#pa11y源码分享" class="headerlink" title="pa11y源码分享"></a>pa11y源码分享</h1><h2 id="一、目录介绍"><a href="#一、目录介绍" class="headerlink" title="一、目录介绍"></a>一、目录介绍</h2><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_5c59e696-d9cf-498f-abea-afd4c76000f1.png"></p><ul><li><code>bin</code>：<code>pa11y</code> 命令的入口文件，该文件主要完成了参数解析、配置文件加载和初始化等操作。</li><li><code>lib</code>：<code>pa11y</code> 的主要逻辑代码。该目录下的核心代码包括了 <code>pa11y</code> 的页面检测逻辑、规则和插件管理等。</li><li><code>example</code>：<code>pa11y</code>使用的示例。</li><li><code>test</code>：包含了 <code>pa11y</code> 的测试文件。<code>pa11y</code> 使用了一系列测试文件来确保其功能正常、代码无误。测试框架主要采用的是<code>Jest</code>。</li><li><code>package.json</code>：定义了 <code>pa11y</code> 的相关信息，包括名称、版本、依赖和开发者等内容。</li></ul><p><strong>【问题1】当你打开lib中的文件夹，你会发现也有个<code>pa11y.js</code>，他们两个作用是什么呢？</strong></p><p>由于<code>pa11y</code>本身支持命令行也可以直接在项目通过js引用，所以造就我们造就我们现在看到的样子。</p><ul><li><code>bin/pa11y</code>：主要是引入了 <code>commander</code> 和 <code>package.json</code> 文件，用于解析命令行参数以及获取程序的版本号等信息。然后，它调用 <code>lib/pa11y.js</code> 中的各种方法来执行不同的功能，如分析 <code>HTML</code> 页面、执行自动化测试、输出测试结果等等。</li><li><code>lib/pa11y</code>：是 Pa11y 的核心代码，它实现了 <code>Pa11y</code> 的所有功能，包括对 <code>HTML</code> 页面进行分析、执行自动化测试等。这个文件通常被其他程序或库所使用，可以被视为 <code>Pa11y</code> 的 <code>API</code> 接口。</li></ul><p><img src="/img/Untitled523524625.png"></p><h2 id="二、解析-bin-pa11y-js命令行入口"><a href="#二、解析-bin-pa11y-js命令行入口" class="headerlink" title="二、解析/bin/pa11y.js命令行入口"></a>二、解析<code>/bin/pa11y.js</code>命令行入口</h2><p><img src="/img/Untitled47857875647.jpg"></p><p>通过上面流程图我们大致了解了这个流程，接下来来看下<code>runProgram</code>函数的内部</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runProgram</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">handleHelp</span>();<br><span class="hljs-keyword">const</span> options = <span class="hljs-title function_">processOptions</span>();<br><span class="hljs-keyword">const</span> report = <span class="hljs-title function_">loadReporter</span>(options.<span class="hljs-property">reporter</span>);<br>options.<span class="hljs-property">log</span> = report.<span class="hljs-property">log</span>;<br><span class="hljs-keyword">if</span> (!programOptions.<span class="hljs-property">debug</span>) &#123;<br>options.<span class="hljs-property">log</span>.<span class="hljs-property">debug</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* NoOp */</span> &#125;;<br>&#125;<br><span class="hljs-keyword">await</span> report.<span class="hljs-title function_">begin</span>(program.<span class="hljs-property">url</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pa11y</span>(program.<span class="hljs-property">url</span>, options);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">reportShouldFail</span>(options.<span class="hljs-property">level</span>, results.<span class="hljs-property">issues</span>, options.<span class="hljs-property">threshold</span>)) &#123;<br>process.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>&#125;<br><span class="hljs-keyword">await</span> report.<span class="hljs-title function_">results</span>(results);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-keyword">await</span> options.<span class="hljs-property">log</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">stack</span>);<br>process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数主要做了以下几件事：</p><ul><li><code>handleHelp()</code> 函数来检查是否需要打印帮助信息，如果需要则打印帮助信息并退出程序。</li><li>调用 <code>processOptions()</code> 函数来获取和处理命令行选项和参数。这个函数会返回一个包含 <code>Pa11y</code> 运行所需选项和参数的对象。</li><li>调用 <code>loadReporter()</code> 函数来加载并初始化生成报告所需的报告器。这里需要根据 <code>options.reporter</code> 属性的值来选择加载何种类型的报告器。加载报告器之后，会接着将日志记录器传递给报告器。</li><li>根据命令行参数中是否包含 <code>-debug</code> 选项来判断是否需要启用调试模式。在调试模式下，<code>Pa11y</code> 生成的调试日志将被输出到控制台。如果没有开启调试模式，则将 <code>options.log.debug</code> 方法置为空。这意味着在生成正常输出时，任何调试日志都将被忽略。</li><li>使用选项和参数调用报告器的 <code>begin()</code> 方法，以开始报告器生成报告的流程。在此期间，会为报告器分配必要的资源，并开始创建报告文件或者输出到控制台。</li><li>调用 <code>pa11y()</code> 函数来执行 <code>Pa11y</code> 检查。根据 <code>Pa11y</code> 的结果生成报告。</li><li>如果报告显示问题且问题数量超出了设定的阈值，则调用 <code>process.exit(2)</code> 函数，告知外部程序该进程以状态码 2 退出。状态码 2 通常表示意外地遇到错误。</li><li>如果发生了任何异常，使用 <code>options.log.error</code> 方法记录错误信息。最后使用 <code>process.exit(1)</code> 函数随即终止进程，并告知外部程序该进程以状态码 1 退出，表示发生了一般性错误。</li></ul><h2 id="三、解析-lib-pa11y-js中核心函数pa11y"><a href="#三、解析-lib-pa11y-js中核心函数pa11y" class="headerlink" title="三、解析/lib/pa11y.js中核心函数pa11y()"></a>三、解析<code>/lib/pa11y.js</code>中核心函数<code>pa11y()</code></h2><p><img src="/img/Untitled1343144315.jpg"></p><p>我们通过流程图了解了pa11y函数核心流程了，接下来我们了解流程中核心函数<code>runPa11yTest()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runPa11yTest</span>(<span class="hljs-params">url, options, state</span>) &#123;<br><br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Running Pa11y on URL <span class="hljs-subst">$&#123;url&#125;</span>`</span>);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">setBrowser</span>(options, state);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">setPage</span>(url, options, state);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">interceptRequests</span>(options, state);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">gotoUrl</span>(url, options, state);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">runActionsList</span>(options, state);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">injectRunners</span>(options, state);<br><br><span class="hljs-comment">// Launch the test runner!</span><br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;Running Pa11y on the page&#x27;</span>);<br><br><span class="hljs-comment">/* istanbul ignore next */</span><br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">wait</span> &gt; <span class="hljs-number">0</span>) &#123;<br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`Waiting for <span class="hljs-subst">$&#123;options.wait&#125;</span>ms`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title function_">runPa11yWithOptions</span>(options, state);<br><br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`Document title: &quot;<span class="hljs-subst">$&#123;results.documentTitle&#125;</span>&quot;`</span>);<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">saveScreenCapture</span>(options, state);<br><br><span class="hljs-keyword">return</span> results;<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数主要做了以下几件事：</p><ul><li><code>options.log.info()</code>：记录正在运行Pa11y的URL。</li><li><code>setBrowser(options, state)</code>：来设置浏览器实例，核心通过<code>puppeteer.launch()</code>来设置<code>browser</code>实例的。</li><li><code>setPage(url, options, state)</code>：创建一个新的浏览器页面，并在其中加载指定的URL，核心通过<code>browser.newPage()</code>来创建新页面<code>page</code>。</li><li><code>interceptRequests(options, state)</code>：来配置浏览器实例以拦截网络请求。</li><li><code>gotoUrl(url, options, state)</code>：在浏览器页面中加载指定的URL，核心通过<code>page.goto()</code>加载指定url</li><li><code>runActionsList(options, state)</code>：执行用户提供的操作列表，例如点击按钮、输入表单值等，其核心是<code>runAction()</code>函数</li><li><code>injectRunners(options, state)</code>：将必要的脚本（指的是<code>axe</code>或者<code>htmlcs</code>）注入到浏览器页面中（注入到window中），以支持Pa11y的运行，其核心是<code>runner()</code>IIFE函数和<code>axe</code>引擎和<code>htmlcs</code>引擎。</li><li><code>options.log.debug()</code>：记录正在对页面运行Pa11y。</li><li>如果指定了<code>options.wait</code>，则会使用<code>options.log.debug()</code>记录等待的时长。</li><li><code>runPa11yWithOptions(options, state)</code>：带着options执行Pa11y相应脚本检查，并返回结果。</li><li><code>options.log.debug()</code>：记录页面的标题。</li><li><code>saveScreenCapture(options, state)</code>：函数保存页面的屏幕截图。</li><li>返回Pa11y检查的结果。</li></ul><p>以上所有都是比较宏观上的流程，所以我们基本知道了pa11y.js和其他文件的一个调用关系，如图所示：</p><p><img src="/img/Untitled764353456634.jpg"></p><ul><li><code>action.js</code>：主要是模拟用户的一些操作，例如点击元素操作、清空input操作等，以及一些执行函数</li><li><code>option.js</code>：主要是对<code>option</code>选项的解析和验证合法性以及设置默认option的API</li><li><code>runner.js</code>：是<code>pa11y</code>的测试引擎框架，其作用是提供了一些通用的测试功能，如配置解析、页面加载和运行测试等，用于<strong>支持各类测试引擎的开发和运行，例如</strong><code>axe-core</code><strong>和</strong><code>htmlcs</code><strong>都是基于runner运行，为其提供统一的测试执行环境</strong></li><li><code>axe.js</code>：以axe-core的JS库为核心开发的测试引擎，提供web的无障碍测试。</li><li><code>htmlcs.js</code>：以<code>HTMLCS</code>的<code>JS</code>库为核心开发的测试引擎，提供<code>web</code>的无障碍测试。</li></ul><h2 id="四、解析-lib-option-js"><a href="#四、解析-lib-option-js" class="headerlink" title="四、解析/lib/option.js"></a><strong>四、解析<code>/lib/option.js</code></strong></h2><p>这个文件里主要是提供一些对于option的操作的API,主要涉及这两个函数：<code>parseArguments()</code>和<code>verifyOptions()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseArguments</span>(<span class="hljs-params">url, options, defaults, callback</span>) &#123;<br><span class="hljs-keyword">if</span> (!callback &amp;&amp; <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>callback = options;<br>options = &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> url !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>options = url;<br>url = options.<span class="hljs-property">url</span>;<br>&#125;<br><br>url = <span class="hljs-title function_">sanitizeUrl</span>(url, defaults);<br>options = <span class="hljs-title function_">defaultOptions</span>(options, defaults);<br><br><span class="hljs-keyword">return</span> [url,<br>options,<br>callback];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parseArguments()</code>主要解析传入的参数并且规范化<code>url</code>、<code>options</code>、<code>callback</code></p><p>具体做了以下几件事：</p><ul><li>如果没有传入 <code>callback</code> 参数且 <code>options</code> 参数为函数类型，将 <code>options</code> 参数的值赋给 <code>callback</code>，并将 <code>options</code> 对象设置为空对象。</li><li>如果传入的 <code>url</code> 参数不是字符串类型，将 <code>url</code> 的值赋给 <code>options.url</code>，并将 <code>url</code> 设置为 <code>sanitizeUrl</code> 函数处理后的值，<code>sanitizeUrl</code> 函数的作用是处理 URL，使其符合规范。</li><li>调用 <code>defaultOptions</code> 函数，将传入的 <code>options</code> 对象与默认选项进行合并。</li><li>返回一个包含 <code>url</code>、<code>options</code> 和 <code>callback</code> 的数组。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">verifyOptions</span>(<span class="hljs-params">options, allowedStandards</span>) &#123;<br><span class="hljs-keyword">if</span> (!allowedStandards.<span class="hljs-title function_">includes</span>(options.<span class="hljs-property">standard</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Standard must be one of <span class="hljs-subst">$&#123;allowedStandards.join(<span class="hljs-string">&#x27;, &#x27;</span>)&#125;</span>`</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">page</span> &amp;&amp; !options.<span class="hljs-property">browser</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;The page option must only be set alongside the browser option&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">ignoreUrl</span> &amp;&amp; !options.<span class="hljs-property">page</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;The ignoreUrl option must only be set alongside the page option&#x27;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>verifyOption()主要是检查option的合规性，主要过程如下：</p><ul><li>检查 <code>options.standard</code> 是否包含在允许的标准列表 <code>allowedStandards</code> 中</li><li>检查 <code>options.page</code> 是否存在且 <code>options.browser</code> 不存在</li><li>检查 <code>options.ignoreUrl</code> 是否存在且 <code>options.page</code> 不存在</li></ul><h2 id="五、解析-lib-action-js中核心函数runAction"><a href="#五、解析-lib-action-js中核心函数runAction" class="headerlink" title="五、解析/lib/action.js中核心函数runAction()"></a>五<strong>、解析<code>/lib/action.js</code>中核心函数<code>runAction()</code></strong></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runAction</span>(<span class="hljs-params">browser, page, options, actionString</span>) &#123;<br><br><span class="hljs-keyword">const</span> action = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">actions</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">foundAction</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> foundAction.<span class="hljs-property">match</span>.<span class="hljs-title function_">test</span>(actionString);<br>&#125;);<br><br><span class="hljs-keyword">if</span> (!action) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed action: &quot;<span class="hljs-subst">$&#123;actionString&#125;</span>&quot; cannot be resolved`</span>);<br>&#125;<br><br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`Running action: <span class="hljs-subst">$&#123;actionString&#125;</span>`</span>);<br><br><span class="hljs-keyword">await</span> action.<span class="hljs-title function_">run</span>(browser, page, options, actionString.<span class="hljs-title function_">match</span>(action.<span class="hljs-property">match</span>));<br><br>options.<span class="hljs-property">log</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`  ✔︎ Action complete: <span class="hljs-subst">$&#123;action.name&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数做了以下几件事：</p><ul><li>根据<code>actionString</code>在<code>module.exports.actions</code>数组里找到相应的模拟操作动作赋值给<code>action</code></li><li>找不到相应的<code>action</code>，则抛出错误</li><li>有相应的<code>action</code>，则执行动作的执行函数<code>run()</code></li></ul><p>接下来我们看一下<code>module.exports.actions</code>，我们拿其中两个作为参考：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">actions</span> = [<br><br><span class="hljs-comment">// Action to navigate to a url</span><br>&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;navigate-url&#x27;</span>,<br><span class="hljs-attr">match</span>: <span class="hljs-regexp">/^navigate to( url)? (.+)$/i</span>,<br><span class="hljs-attr">run</span>: <span class="hljs-title function_">async</span> (browser, page, options, matches) =&gt; &#123;<br><span class="hljs-keyword">const</span> navigateTo = matches[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(navigateTo);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed action: Could not navigate to &quot;<span class="hljs-subst">$&#123;navigateTo&#125;</span>&quot;`</span>);<br>&#125;<br>&#125;<br>&#125;,<br><br><span class="hljs-comment">// Action to click an element</span><br>&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;click-element&#x27;</span>,<br><span class="hljs-attr">match</span>: <span class="hljs-regexp">/^click( element)? (.+)$/i</span>,<br><span class="hljs-attr">run</span>: <span class="hljs-title function_">async</span> (browser, page, options, matches) =&gt; &#123;<br><span class="hljs-keyword">const</span> selector = matches[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">await</span> page.<span class="hljs-title function_">click</span>(selector);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed action: no element matching selector &quot;<span class="hljs-subst">$&#123;selector&#125;</span>&quot;`</span>);<br>&#125;<br>&#125;<br>&#125;,......]<br></code></pre></td></tr></table></figure><ul><li><code>name</code>：是动作的名称，也是模拟动作的规则</li><li><code>match</code>：用于匹配相应的动作</li><li><code>run</code>：当前名称的动作的执行函数</li></ul><p>我们看一个使用案例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runExample</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-comment">// Test http://example.com/</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pa11y</span>(<span class="hljs-string">&#x27;http://example.com/&#x27;</span>, &#123;<br><br><span class="hljs-comment">// Run some actions before the tests</span><br><span class="hljs-attr">actions</span>: [<br><span class="hljs-string">&#x27;set field #username to exampleUser&#x27;</span>,<br><span class="hljs-string">&#x27;set field #password to password1234&#x27;</span>,<br><span class="hljs-string">&#x27;click element #submit&#x27;</span>,<br><span class="hljs-string">&#x27;wait for url to be http://example.com/myaccount&#x27;</span><br>],<br><br><span class="hljs-attr">log</span>: &#123;<br><span class="hljs-attr">debug</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>,<br><span class="hljs-attr">error</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>,<br><span class="hljs-attr">info</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span><br>&#125;<br><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现<code>actions</code>里面的<code>actionString</code>都是严格按照<code>name</code>和<code>match</code>的规则编写的，只有这样才能使得<code>run</code>函数顺利执行。</p><h2 id="六、解析-lib-runner-js中核心函数runPa11y"><a href="#六、解析-lib-runner-js中核心函数runPa11y" class="headerlink" title="六、解析/lib/runner.js中核心函数runPa11y()"></a>六<strong>、解析<code>/lib/runner.js</code>中核心函数<code>runPa11y()</code></strong></h2><p><img src="/img/Untitled5423256246535.jpg"></p><p>通过上面流程图我们大致了解了runPa11y的执行过程，然后我们详细了解下processIssues函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processIssues</span>(<span class="hljs-params">issues</span>) &#123;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">rootElement</span>) &#123;<br>issues = issues.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">issue</span> =&gt;</span> <span class="hljs-title function_">isElementInTestArea</span>(issue.<span class="hljs-property">element</span>));<br>&#125;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">hideElements</span>) &#123;<br>issues = issues.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">issue</span> =&gt;</span> <span class="hljs-title function_">isElementOutsideHiddenArea</span>(issue.<span class="hljs-property">element</span>));<br>&#125;<br><span class="hljs-keyword">return</span> issues.<span class="hljs-title function_">map</span>(processIssue).<span class="hljs-title function_">filter</span>(isIssueNotIgnored);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>processIssues大致做了以下几件事情：</p><ul><li>options中是否存在rootElement元素（页面根元素），如果存在，则过滤掉issues中不在rootElement范围里的元素</li><li>options中是否存在hideElements元素（页面隐藏的元素），如果存在，则过滤掉issues不在hideElements范围里的元素</li><li>通过processIssue()格式化issues，并过滤掉issue中被ignore的元素，并返回新数组。</li></ul><p>涉及函数如下，请看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processIssue</span>(<span class="hljs-params">issue</span>) &#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">code</span>: issue.<span class="hljs-property">code</span>,<br><span class="hljs-attr">type</span>: issue.<span class="hljs-property">type</span>,<br><span class="hljs-attr">typeCode</span>: issueCodeMap[issue.<span class="hljs-property">type</span>] || <span class="hljs-number">0</span>,<br><span class="hljs-attr">message</span>: issue.<span class="hljs-property">message</span>,<br><span class="hljs-attr">context</span>: (issue.<span class="hljs-property">element</span> ? <span class="hljs-title function_">getElementContext</span>(issue.<span class="hljs-property">element</span>) : <span class="hljs-string">&#x27;&#x27;</span>),<br><span class="hljs-attr">selector</span>: (issue.<span class="hljs-property">element</span> ? <span class="hljs-title function_">getElementSelector</span>(issue.<span class="hljs-property">element</span>) : <span class="hljs-string">&#x27;&#x27;</span>),<br><span class="hljs-attr">runner</span>: issue.<span class="hljs-property">runner</span>,<br><span class="hljs-attr">runnerExtras</span>: issue.<span class="hljs-property">runnerExtras</span> || &#123;&#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIssueNotIgnored</span>(<span class="hljs-params">issue</span>) &#123;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">ignore</span>.<span class="hljs-title function_">indexOf</span>(issue.<span class="hljs-property">code</span>.<span class="hljs-title function_">toLowerCase</span>()) !== -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (options.<span class="hljs-property">ignore</span>.<span class="hljs-title function_">indexOf</span>(issue.<span class="hljs-property">type</span>) !== -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、解析axe-js中核心函数runAxeCore"><a href="#七、解析axe-js中核心函数runAxeCore" class="headerlink" title="七、解析axe.js中核心函数runAxeCore()"></a>七、解析<code>axe.js</code>中核心函数<code>runAxeCore()</code></h2><p>我们先了解下<code>axe-core</code>包的<code>API</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-number">1.</span> axe.<span class="hljs-title function_">run</span>(params, callback)：执行无障碍测试并返回测试结果。<br>返回一个对象基本结构如下：<br>&#123;<br>  <span class="hljs-string">&quot;violations&quot;</span>: [<span class="hljs-title class_">Array</span>],    <span class="hljs-comment">// 所有违规的无障碍规则对象</span><br>  <span class="hljs-string">&quot;passes&quot;</span>: [<span class="hljs-title class_">Array</span>],        <span class="hljs-comment">// 所有通过的无障碍规则对象</span><br>  <span class="hljs-string">&quot;incomplete&quot;</span>: [<span class="hljs-title class_">Array</span>],    <span class="hljs-comment">// 无障碍测试未完成的规则所在的对象</span><br>  <span class="hljs-string">&quot;inapplicable&quot;</span>: [<span class="hljs-title class_">Array</span>],  <span class="hljs-comment">// 所有无障碍测试不适用的规则对象</span><br>  <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-title class_">String</span>,            <span class="hljs-comment">// 被测试页面的URL</span><br>  <span class="hljs-string">&quot;timestamp&quot;</span>: <span class="hljs-title class_">String</span>,      <span class="hljs-comment">// 测试时间戳</span><br>  <span class="hljs-string">&quot;testEngine&quot;</span>: &#123;<span class="hljs-title class_">Object</span>&#125;,   <span class="hljs-comment">// 测试引擎信息</span><br>  <span class="hljs-string">&quot;toolOptions&quot;</span>: &#123;<span class="hljs-title class_">Object</span>&#125;   <span class="hljs-comment">// 测试工具选项</span><br>&#125;<br><span class="hljs-number">2.</span> axe.<span class="hljs-property">configure</span>：配置<span class="hljs-title class_">Axe</span> <span class="hljs-title class_">Core</span>的行为和规则。<br><span class="hljs-number">3.</span> axe.<span class="hljs-property">getRules</span>：获取<span class="hljs-title class_">Axe</span> <span class="hljs-title class_">Core</span>中定义的所有无障碍规则。<br><span class="hljs-number">4.</span> axe.<span class="hljs-property">getPlugin</span>：获取已加载的<span class="hljs-title class_">Axe</span> <span class="hljs-title class_">Core</span>插件列表。<br></code></pre></td></tr></table></figure><p>接下来我们详细了解下<code>runAxeCore()</code>函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runAxeCore</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">axe</span>.<span class="hljs-title function_">run</span>(<br><span class="hljs-title function_">getAxeContext</span>(),<br><span class="hljs-title function_">getAxeOptions</span>()<br>);<br><span class="hljs-keyword">return</span> [].<span class="hljs-title function_">concat</span>(<br>...result.<span class="hljs-property">violations</span>.<span class="hljs-title function_">map</span>(processViolation),<br>...result.<span class="hljs-property">incomplete</span>.<span class="hljs-title function_">map</span>(processIncomplete)<br>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WCAG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>pa11y</tag>
      
      <tag>WCAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向Nexus上传本地的npm依赖</title>
    <link href="/2023/08/02/%E5%90%91Nexus%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E7%9A%84npm%E4%BE%9D%E8%B5%96/"/>
    <url>/2023/08/02/%E5%90%91Nexus%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E7%9A%84npm%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="向Nexus上传本地的npm依赖"><a href="#向Nexus上传本地的npm依赖" class="headerlink" title="向Nexus上传本地的npm依赖"></a><strong>向Nexus上传本地的npm依赖</strong></h1><p>最近在公司有上传内部npm服务器的需求，需要将npm包上传到nexus中，解决这个问题，有两种思路</p><h3 id="【-方式1-】暂时开通外网权限，通过设置类型为代理-proxy-的私库来缓存相关的依赖包。"><a href="#【-方式1-】暂时开通外网权限，通过设置类型为代理-proxy-的私库来缓存相关的依赖包。" class="headerlink" title="【 方式1 】暂时开通外网权限，通过设置类型为代理(proxy)的私库来缓存相关的依赖包。"></a>【 方式1 】暂时开通外网权限，通过设置类型为代理(proxy)的私库来缓存相关的依赖包。</h3><p>首先就是新建一个私库：</p><p><img src="/img/24497001-2e026a388de29574.webp"></p><p>选择npm(proxy)</p><p><img src="/img/24497001-8f457e2ce138c04c.webp"></p><p>然后输入名称和要代理的远程仓库地址</p><p><img src="/img/24497001-8c9e6e6351bd784d.webp"></p><p>完成之后本地就可以将拉取依赖的地址设置成这个新建的私库的地址，拉取完成后相关的依赖便会缓存在这个私库中。</p><p>优点：操作方便、自动缓存</p><p>缺点：每次变更了依赖内容都需要去申请一次外网权限</p><h3 id="【-方式2-】向Nexus上传本地的npm依赖"><a href="#【-方式2-】向Nexus上传本地的npm依赖" class="headerlink" title="【 方式2 】向Nexus上传本地的npm依赖"></a>【 方式2 】向Nexus上传本地的npm依赖</h3><p>首先也是需要创建私库，和方式1不同，创建的是类型为hosted的私库：</p><p><img src="/img/24497001-b6d5036d96009acf.webp"></p><p><img src="/img/24497001-f5368221b15eb34a.webp"></p><p>之后便是需要下载本地对应依赖的tgz包并且上传到这个私库中。</p><ol><li>安装<a href="https://links.jianshu.com/go?to=https://link.segmentfault.com/?enc=lVYHAWcrhAzsGmuwSP27dw%253D%253D.tQXZgU6Azp6Dox4nqOMT9uhCDdWMqpN8aPOHyzMnbabcAZ5rQawT%252F5NgZtaExRN1niYnOgYTFCfN1GLJWQnA%252Bg%253D%253D">node-tgz-downloader</a>，用来下载依赖的tgz文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install node-tgz-downloader -g<br></code></pre></td></tr></table></figure><p>2.安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure><p>3.安装完依赖后会生成package-lock.json文件，然后可以执行下面的命令下载对应的依赖包tgz（注意：下载时一些包经常会下载失败，需要保证网络条件稳定，若失败可多尝试几次）下载的tgz文件会在项目根目录/tarballs下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">download-tgz package-lock package-lock.json<br></code></pre></td></tr></table></figure><p>ps:如果是使用yarn来安装依赖，可以将yarn.lock先转换成package-lock.json：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g synp<br><br>// 在根目录下<br>synp --source-file yarn.lock<br></code></pre></td></tr></table></figure><p>4.去重</p><p>在根目录下新建一个tgz文件夹，然后在tarballs文件夹下执行下面的shell命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&#x27;*.tgz&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cp</span> -f &#123;&#125; ../tgz \;<br></code></pre></td></tr></table></figure><p>5.创建并执行发布脚本</p><p>新建.publish.sh，内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>PACKAGE_PATH=./tgz<br>REPOSITORY= <span class="hljs-string">&quot;仓库地址&quot;</span><br>npm login --registry=<span class="hljs-variable">$REPOSITORY</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$PACKAGE_PATH</span>/*.tgz; <span class="hljs-keyword">do</span><br> npm publish <span class="hljs-variable">$file</span> --registry=<span class="hljs-variable">$REPOSITORY</span> <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>然后执行该脚本，上传速度比较慢，个人测试2000多个tgz文件，用时1小时多。</p><p>注意：查找仓库地址方法如下：</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120231012-195823.png"></p><p>如果上传后部分包缺失，可以重新上传或者采用nexus的手动上传，操作如下：</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120231012-194839.png"></p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120231012-194909.png"></p><p>正常情况下，npm服务器都会有一个npm-group虚拟仓库来将多个npm仓库组合在一起，主要是方便使用者下载时只需一个网址即可。</p><p>将我们新建的仓库加入虚拟仓库，如图：<br><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120231012-194631.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Nexus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nvm版本管理工具使用和踩坑</title>
    <link href="/2023/07/30/nvm%E7%89%88%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%92%8C%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/07/30/nvm%E7%89%88%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%92%8C%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="nvm版本管理工具使用和踩坑"><a href="#nvm版本管理工具使用和踩坑" class="headerlink" title="nvm版本管理工具使用和踩坑"></a>nvm版本管理工具使用和踩坑</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>nvm 全称 Node Version Manager，是一个 Node.js 版本管理工具，可以在同一台电脑上安装多个不同版本的 Node.js，通过 nvm 可以方便地在这些版本间进行切换，保证不同项目能够使用对应的 Node.js 版本。</p><p>nvm 可以在 Windows、macOS 和 Linux 等多个操作系统上使用，并支持在命令行上进行安装和版本管理。它可以让你方便地进行以下操作：</p><ol><li>安装多个 Node.js 版本，并在不同版本之间进行快速切换。</li><li>快速切换默认 Node.js 版本。</li><li>在同一版本下管理多个全局的 npm 包。</li><li>让多个开发者在同一台电脑上使用不同的 Node.js 版本。</li><li>一键安装当前最新版本的 Node.js。</li></ol><h1 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h1><h2 id="1-windows系统"><a href="#1-windows系统" class="headerlink" title="1. windows系统"></a>1. windows系统</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>nvm for window</p><h3 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3 安装"></a>1.3 安装</h3><p>官网提供两个版本：</p><ul><li><code>nvm-noinstall.zip</code> 这个是绿色免安装版本，但是使用之前需要配置</li><li><code>nvm-setup.zip</code>这是一个安装包，下载之后点击安装，无需配置就可以使用</li></ul><p><strong>注意：在安装nvm之前一定要把之前的node卸载！！！</strong></p><p><strong>【方式一】通过<code>nvm-noinstall.zip</code>安装：</strong></p><ol><li>把 nvm_noinstall.zip 解压到比如<code>D:\nvm</code> 中；</li><li>右键以管理员的身份运行<code>install.cmd</code>文件 ，直接按回车,会在解压的根目录生成一个<code>setting.txt</code>，以我的为例就是生成在<code>D盘</code>，将<code>setting.txt</code>复制到nvm下面方便管理，然后配置setting.text。</li><li>setting.text配置如下： <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//指定 nvm 的根目录路径，如果不配置，nvm 将采用默认的根目录</span><br><span class="hljs-attr">root</span>: <span class="hljs-attr">D</span>:\nvm<br><br><span class="hljs-comment">//指定当前系统使用的node所在的目录路径</span><br><span class="hljs-attr">path</span>: <span class="hljs-attr">D</span>:\nodejs<br><br><span class="hljs-comment">//指定当前系统的 CPU 架构，它有两个可选值分别是 &quot;x86&quot; 和 &quot;x64&quot;。如果不配置，nvm 将自动检测当前系统的 CPU 架构。</span><br><span class="hljs-attr">arch</span>: <span class="hljs-number">64</span><br><br><span class="hljs-comment">//指定 nvm 在下载 Node.js 安装包时所需要使用的代理服务器地址</span><br><span class="hljs-attr">proxy</span>: none<br><br><span class="hljs-comment">//指定 Node.js 安装文件的下载地址，如果不配置，nvm 将采用默认的下载地址:https://nodejs.org/dist/。</span><br><span class="hljs-attr">node_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/node/</span><br><br><span class="hljs-comment">//指定 npm 安装包的下载地址，如果不配置，将采用默认的下载地址:https://registry.npmjs.org/。</span><br><span class="hljs-attr">npm_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/npm/</span><br></code></pre></td></tr></table></figure><blockquote><p>一般情况下path里的路径自动生成，但是我们可以手动改成我们想要的路径</p></blockquote></li><li>然后配置nvm的环境变量 打开<code>‘控制面板主页-&gt;高级系统设置-&gt;高级-&gt;环境变量’</code>后会有<code>‘用户变量’</code>和<code>‘系统变量’</code>两个选项，建议这<strong>两个里面都加上</strong>：<ul><li>新增 NVM_HOME: D:\nvm</li><li>新增 NVM_SYMLINK: D:\nodejs</li><li>在PATH里增加两项<ul><li>%NVM_HOME%</li><li>%NVM_SYMLINK%</li></ul></li></ul></li><li>在powershell 输入<code>nvm -v</code>，如果显示nvm配置成功。</li><li>通过<code>nvm install 版本号</code>安装 node 环境，然后通过<code>nvm use 版本号</code>使用这个版本node （安装第一个node版本一定要<code>nvm use 版本号</code>，不然步骤7可能操作失败）</li><li>通过<code>node -v</code>和<code>npm -v</code>查看能否显示出对应版本。</li></ol><p><strong>【方式二】通过nvm-setup.zip安装</strong></p><ol><li>双击 <code>nvm-setup.exe</code>安装，点击accept，然后next</li><li>选择nvm的安装路径，点击next</li><li>选择系统使用node的环境路径，建议和nvm同一个盘（单纯后期方便找）</li><li>确认安装：打开powershell，输入nvm -v </li><li>检查环境变量（一般情况下环境变量都已经自动添加好了，至于添加的内容和<code>方式一</code>一样）</li><li>配置node和npm的下载镜像</li></ol><p><strong>注意：可能个人原因</strong>，我安装包安装后的nvm目录只有两个文件夹，没有setting.txt文件，安装的node包在这里也看不见，所以，这种方式只能通过命令配置镜像。个人推荐「<strong>方式一」，配置更加自由！</strong></p><h2 id="2-mac系统"><a href="#2-mac系统" class="headerlink" title="2. mac系统"></a>2. mac系统</h2><p>通过brew安装nvm即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">brew install nvm<br></code></pre></td></tr></table></figure><p>安装过程中可能会遇到报错</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">==&gt; Fetching nvm<br>==&gt; Downloading https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/homebrew-bottles/nvm-0.39.4.arm64_ve</span><br>Already downloaded<span class="hljs-punctuation">:</span> /Users/zhangwei/Library/Caches/Homebrew/downloads/dc96936aeec84a5d727a170130b7480c48f6d414f94f907ad5526b0b2418aef3--nvm<span class="hljs-number">-0.39</span><span class="hljs-number">.4</span>.arm64_ventura.bottle.tar.gz<br>==&gt; Reinstalling nvm <br>==&gt; Pouring nvm<span class="hljs-number">-0.39</span><span class="hljs-number">.4</span>.arm64_ventura.bottle.tar.gz<br>==&gt; Caveats<br>Please note that upstream has asked us to make explicit managing<br>nvm via Homebrew is unsupported by them and you should check any<br>problems against the standard nvm install method prior to reporting.<br><br>You should create NVM&#x27;s working directory if it doesn&#x27;t exist<span class="hljs-punctuation">:</span><br>  mkdir ~/.nvm<br><br>Add the following to your shell profile e.g. ~/.profile or ~/.zshrc<span class="hljs-punctuation">:</span><br>  export NVM_DIR=<span class="hljs-string">&quot;$HOME/.nvm&quot;</span><br>  <span class="hljs-punctuation">[</span> -s <span class="hljs-string">&quot;/opt/homebrew/opt/nvm/nvm.sh&quot;</span> <span class="hljs-punctuation">]</span> &amp;&amp; \. <span class="hljs-string">&quot;/opt/homebrew/opt/nvm/nvm.sh&quot;</span>  # This loads nvm<br>  <span class="hljs-punctuation">[</span> -s <span class="hljs-string">&quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;</span> <span class="hljs-punctuation">]</span> &amp;&amp; \. <span class="hljs-string">&quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;</span>  # This loads nvm bash_completion<br><br>You can set $NVM_DIR to any location<span class="hljs-punctuation">,</span> but leaving it unchanged from<br>/opt/homebrew/Cellar/nvm/<span class="hljs-number">0.39</span><span class="hljs-number">.4</span> will destroy any nvm-installed Node installations<br>upon upgrade/reinstall.<br><br>Type `nvm help` for further information.<br>==&gt; Summary<br>🍺  /opt/homebrew/Cellar/nvm/<span class="hljs-number">0.39</span><span class="hljs-number">.4</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span> files<span class="hljs-punctuation">,</span> <span class="hljs-number">191.5</span>KB<br>==&gt; Running `brew cleanup nvm`...<br>Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.<br>Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).<br>zhangwei@loaclhost ~ % <br>zhangwei@loaclhost ~ % brew install nvm <br>Running `brew update --auto-update`...<br>To restore the stashed changes to /opt/homebrew/Library/Taps/mongodb/homebrew-brew<span class="hljs-punctuation">,</span> run<span class="hljs-punctuation">:</span><br>  cd /opt/homebrew/Library/Taps/mongodb/homebrew-brew &amp;&amp; git stash pop<br>==&gt; Auto-updated Homebrew!<br>Updated <span class="hljs-number">1</span> tap (mongodb/brew).<br><br>You have <span class="hljs-number">4</span> outdated formulae installed.<br></code></pre></td></tr></table></figure><p>报错原因是我们没有配置nvm环境变量</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">提示的原因是因为没有配置nvm的环境变量<br>建议用 brew info nvm 查看包安装的介绍，有些会提示怎么设置环境变量<br><br><span class="hljs-number">1</span>、查看用户目录下有没有 .nvm<span class="hljs-punctuation">,</span> 没有则创建<br>mkdir ~/.nvm<br><span class="hljs-number">2</span>、打开.bash_profile<span class="hljs-punctuation">,</span>添加如下<br>export NVM_DIR=<span class="hljs-string">&quot;$HOME/.nvm&quot;</span><br>  <span class="hljs-punctuation">[</span> -s <span class="hljs-string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span> <span class="hljs-punctuation">]</span> &amp;&amp; . <span class="hljs-string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span>  # This loads nvm<br>  <span class="hljs-punctuation">[</span> -s <span class="hljs-string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span> <span class="hljs-punctuation">]</span> &amp;&amp; . <span class="hljs-string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span>  # This loads nvm <br><br><span class="hljs-number">3</span>、brew 查看已经安装的包<br>brew list<br></code></pre></td></tr></table></figure><h1 id="三、nvm常用命令"><a href="#三、nvm常用命令" class="headerlink" title="三、nvm常用命令"></a>三、nvm常用命令</h1><h3 id="1-查看nvm版本"><a href="#1-查看nvm版本" class="headerlink" title="1. 查看nvm版本"></a>1. 查看nvm版本</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm -v<br></code></pre></td></tr></table></figure><h3 id="2-显示node版本列表"><a href="#2-显示node版本列表" class="headerlink" title="2. 显示node版本列表"></a>2. 显示node版本列表</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm list <span class="hljs-comment">//显示已经的安装node版本</span><br><br>nvm list available <span class="hljs-comment">//显示所有可下载的版本</span><br></code></pre></td></tr></table></figure><h3 id="3-安装指定node版本"><a href="#3-安装指定node版本" class="headerlink" title="3. 安装指定node版本"></a>3. 安装指定node版本</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm install <span class="hljs-number">14.5</span><span class="hljs-number">.0</span> <span class="hljs-comment">// 安装 14.5.0 版本的 node.js</span><br><br>nvm install latest <span class="hljs-comment">// 安装最新版本</span><br></code></pre></td></tr></table></figure><h3 id="4-切换指定node版本"><a href="#4-切换指定node版本" class="headerlink" title="4. 切换指定node版本"></a>4. 切换指定node版本</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm use <span class="hljs-number">14.5</span><span class="hljs-number">.0</span> <span class="hljs-comment">// 切换到 14.5.0 版本的 node.js</span><br><br>nvm use <span class="hljs-number">14</span> <span class="hljs-comment">//切换当前列表为14开头的版本</span><br></code></pre></td></tr></table></figure><h3 id="5-卸载指定node版本"><a href="#5-卸载指定node版本" class="headerlink" title="5. 卸载指定node版本"></a>5. 卸载指定node版本</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm uninstall <span class="hljs-number">14.5</span><span class="hljs-number">.0</span> <span class="hljs-comment">// 安装 14.5.0 版本的 node.js</span><br></code></pre></td></tr></table></figure><h3 id="6-设置node-npm镜像"><a href="#6-设置node-npm镜像" class="headerlink" title="6. 设置node/ npm镜像"></a>6. 设置node/ npm镜像</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm node_mirror [url] <span class="hljs-comment">//设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。</span><br>nvm npm_mirror [url]  <span class="hljs-comment">//设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。</span><br></code></pre></td></tr></table></figure><h3 id="7-nvm缓存"><a href="#7-nvm缓存" class="headerlink" title="7. nvm缓存"></a>7. <strong>nvm缓存</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm cache dir <span class="hljs-comment">// 显示nvm的缓存目录</span><br>nvm cache clear <span class="hljs-comment">// 清除nvm的缓存目录</span><br></code></pre></td></tr></table></figure><h3 id="8-帮助"><a href="#8-帮助" class="headerlink" title="8.帮助"></a>8.帮助</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nvm --help <span class="hljs-comment">//显示命令行帮助信息</span><br></code></pre></td></tr></table></figure><h1 id="四、踩坑记录"><a href="#四、踩坑记录" class="headerlink" title="四、踩坑记录"></a>四、踩坑记录</h1><ol><li>在安装nvm之前没有卸载node，导致使用<code>nvm use 版本</code>命令时，切换版本失败</li></ol><p>【解决】将node和nvm都卸载，重新安装。</p><ol start="2"><li>后期下载node版本没有通过nvm install命令安装，而是通过node官网的安装程序安装，导致<code>nvm use 版本</code>命令切换失败。</li></ol><p>【解决】这个问题的关键之处是node安装时路径没有安装在nvm的根目录上。我们去官网下载node版本时，不要下载<code>xxx.msi</code>，这是安装程序，他会直接控制我们全局的node，我们要下载完整装好的压缩包。如下：</p><p><img src="/img/81688718460_.pic.jpg"></p><p>然后直接解压到nvm的根目录上，并且修改文件名字为<code>v版本号</code></p><p><img src="img/71688718418_.pic.jpg"></p><p>此时在查看当前安装的版本应该就显示了，然后再切换到这个版本即可</p><p><strong>3. nvm下载node成功但是npm下载失败</strong></p><p>【解决】主要原因一般是我们的镜像里没有对应node版本的npm</p><p>我们的解决办法有两个：</p><ul><li>直接从官网下载node压缩包，然后解压在nvm根目录，并重命名<code>v+版本号</code>，步骤同<strong>问题2</strong></li><li>修改我们的nvm中的node镜像和npm镜像<ul><li>方式一：通过修改setting.txt文件内容  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">node_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/node/</span><br><span class="hljs-attr">npm_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/npm/</span><br></code></pre></td></tr></table></figure></li><li>方式二：通过nvm命令修改镜像地址  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//设置 Node.js 下载镜像地址</span><br>nvm node_mirror <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/node/</span><br><span class="hljs-comment">//设置 npm 下载镜像地址</span><br>nvm npm_mirror <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/npm/</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>4. nvm install 卡顿</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么选择首选pnpm</title>
    <link href="/2023/07/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E9%A6%96%E9%80%89pnpm/"/>
    <url>/2023/07/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E9%A6%96%E9%80%89pnpm/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么选择首选pnpm"><a href="#为什么选择首选pnpm" class="headerlink" title="为什么选择首选pnpm?"></a>为什么选择首选pnpm?</h1><p>这篇文章给大家分享一个业内一款出色的包管理器——<code>pnpm</code>。目前 GitHub 已经有 star 9.8k，现在已经相对成熟且稳定了。它由 npm/yarn 衍生而来，但却解决了 npm/yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。下面是本文的思维导图:</p><p><img src="/img/1313648-20210225174230334-853579081.png"></p><h2 id="一、什么是-pnpm"><a href="#一、什么是-pnpm" class="headerlink" title="一、什么是 pnpm ?"></a><strong>一、什么是 pnpm ?</strong></h2><p>pnpm 的官方文档(<a href="https://pnpm.js.org/en/)%E6%98%AF%E8%BF%99%E6%A0%B7%E8%AF%B4%E7%9A%84">https://pnpm.js.org/en/)是这样说的</a>:</p><blockquote><p>Fast, disk space efficient package manager</p></blockquote><p>因此，pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它作为杀手锏的两个优势在于:</p><ul><li>包安装速度极快；</li><li>磁盘空间利用非常高效。</li></ul><p>它的安装也非常简单。可以有多简单?</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm i <span class="hljs-literal">-g</span> pnpm<br></code></pre></td></tr></table></figure><h2 id="二、特性概览"><a href="#二、特性概览" class="headerlink" title="二、特性概览"></a><strong>二、特性概览</strong></h2><h3 id="1-速度快"><a href="#1-速度快" class="headerlink" title="1. 速度快"></a><strong>1. 速度快</strong></h3><p>pnpm 安装包的速度究竟有多快？先以 React 包为例来对比一下:</p><p><img src="/img/1313648-20210225174301546-870504832.png"></p><p>可以看到，作为黄色部分的 pnpm，在绝多大数场景下，包安装的速度都是明显优于 npm/yarn，速度会比 npm/yarn 快 2-3 倍。</p><p>对 yarn 比较熟悉的同学可能会说，yarn 不是有 <code>PnP 安装模式</code>(<a href="https://classic.yarnpkg.com/en/docs/pnp/)%E5%90%97%EF%BC%9F%E7%9B%B4%E6%8E%A5%E5%8E%BB%E6%8E%89">https://classic.yarnpkg.com/en/docs/pnp/)吗？直接去掉</a> node_modules，将依赖包内容写在磁盘，节省了 node 文件 I/O 的开销，这样也能提升安装速度。（具体原理见这篇文章(<a href="https://loveky.github.io/2019/02/11/yarn-pnp/)%EF%BC%89">https://loveky.github.io/2019/02/11/yarn-pnp/)）</a></p><p>接下来，我们以这样一个仓库(<a href="https://github.com/pnpm/benchmarks-of-javascript-package-managers)%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E4%B8%80%E7%9C%8B">https://github.com/pnpm/benchmarks-of-javascript-package-managers)为例，我们来看一看</a> benchmark 数据，主要对比一下 <code>pnpm</code> 和 <code>yarn PnP</code>:</p><p><img src="/img/1313648-20210225174325371-2122926684.png"></p><p>从中可以看到，总体而言，<code>pnpm</code> 的包安装速度还是明显优于 <code>yarn PnP</code>的。</p><h3 id="2-高效利用磁盘空间"><a href="#2-高效利用磁盘空间" class="headerlink" title="2. 高效利用磁盘空间"></a><strong>2. 高效利用磁盘空间</strong></h3><p>pnpm 内部使用<code>基于内容寻址</code>的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:</p><ul><li>不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 <code>hardlink</code>(硬链接，不清楚的同学详见这篇文章(<a href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html))%E3%80%82">https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html))。</a></li><li>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 <code>hardlink</code>，仅仅写入那<code>一个新增的文件</code>。</li></ul><h3 id="3-支持-monorepo"><a href="#3-支持-monorepo" class="headerlink" title="3. 支持 monorepo"></a><strong>3. 支持 monorepo</strong></h3><p>随着前端工程的日益复杂，越来越多的项目开始使用 <code>monorepo</code>。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 <code>monorepo</code> 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的<code>packages</code>目录下，那么一个子项目就代表一个<code>package</code>。如果你之前没接触过 <code>monorepo</code> 的概念，建议仔细看看这篇文章(<a href="https://www.perforce.com/blog/vcs/what-monorepo)%E4%BB%A5%E5%8F%8A%E5%BC%80%E6%BA%90%E7%9A%84">https://www.perforce.com/blog/vcs/what-monorepo)以及开源的</a> <code>monorepo</code> 管理工具<code>lerna</code>(<a href="https://github.com/lerna/lerna#readme)%EF%BC%8C%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%B8%80%E4%B8%8B">https://github.com/lerna/lerna#readme)，项目目录结构可以参考一下</a> <code>babel 仓库</code>(<a href="https://github.com/babel/babel)%E3%80%82">https://github.com/babel/babel)。</a></p><p><code>pnpm</code> 与 <code>npm/yarn</code> 另外一个很大的不同就是支持了 <code>monorepo</code>，体现在各个子命令的功能上，比如在根目录下 <code>pnpm add A -r</code>, 那么所有的 <code>package</code> 中都会被添加 A 这个依赖，当然也支持 <code>--filter</code>字段来对 package 进行过滤。</p><h3 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a><strong>4. 安全性高</strong></h3><p>之前在使用 npm/yarn 的时候，由于 <code>node_module</code> 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。但 pnpm 脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性，具体怎么体现<code>安全</code>、规避非法访问依赖的<code>风险</code>的，后面再来详细说说。</p><h2 id="三、依赖管理"><a href="#三、依赖管理" class="headerlink" title="三、依赖管理"></a><strong>三、依赖管理</strong></h2><h3 id="npm-yarn-install-原理"><a href="#npm-yarn-install-原理" class="headerlink" title="npm/yarn install 原理"></a><strong>npm/yarn install 原理</strong></h3><p>主要分为两个部分, 首先，执行 npm/yarn install之后，<code>包如何到达项目 node_modules 当中</code>。其次，node_modules <code>内部如何管理依赖</code>。</p><p>执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:</p><ul><li><ol><li>将依赖包的版本区间解析为某个具体的版本号</li></ol></li><li><ol start="2"><li>下载对应版本依赖的 tar 包到本地离线镜像</li></ol></li><li><ol start="3"><li>将依赖从离线镜像解压到本地缓存</li></ol></li><li><ol start="4"><li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li></ol></li></ul><p>然后，对应的包就会到达项目的<code>node_modules</code>当中。</p><p>那么，这些依赖在<code>node_modules</code>内部是什么样的目录结构呢，换句话说，项目的依赖树是什么样的呢？</p><p>在 <code>npm1</code>、<code>npm2</code> 中呈现出的是嵌套结构，比如下面这样:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">node_modules<br>└─ foo<br>   ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>   ├─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>   └─ node_modules<br>      └─ <span class="hljs-keyword">bar</span><br><span class="hljs-keyword"></span>         ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>         └─ package.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure><p>如果 <code>bar</code> 当中又有依赖，那么又会继续嵌套下去。试想一下这样的设计存在什么问题:</p><ol><li>依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下。</li><li>大量重复的包被安装，文件体积超级大。比如跟 <code>foo</code> 同级目录下有一个<code>baz</code>，两者都依赖于同一个版本的<code>lodash</code>，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。</li><li>模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。</li></ol><p>接着，从 npm3 开始，包括 yarn，都着手来通过<code>扁平化依赖</code>的方式来解决这个问题。相信大家都有这样的体验，我明明就装个 <code>express</code>，为什么 <code>node_modules</code>里面多了这么多东西？</p><p><img src="/img/1313648-20210225174423589-1848330844.png"></p><p>没错，这就是<code>扁平化</code>依赖管理的结果。相比之前的<code>嵌套结构</code>，现在的目录结构类似下面这样:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">node_modules<br>├─ foo<br>|  ├─ <span class="hljs-keyword">index</span>.js<br>|  └─ package.json<br>└─ bar<br>   ├─ <span class="hljs-keyword">index</span>.js<br>   └─ package.json<br></code></pre></td></tr></table></figure><p>所有的依赖都被拍平到<code>node_modules</code>目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的<code>node_modules</code>当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p><p>之前的问题是解决了，但仔细想想这种<code>扁平化</code>的处理方式，它真的就是无懈可击吗？并不是。它照样存在诸多问题，梳理一下:</p><ol><li>依赖结构的<strong>不确定性</strong>。</li><li>扁平化算法本身的<strong>复杂性</strong>很高，耗时较长。</li><li>项目中仍然可以<strong>非法访问</strong>没有声明过依赖的包</li></ol><p>后面两个都好理解，那第一点中的<code>不确定性</code>是什么意思？这里来详细解释一下。</p><p>假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的:</p><p><img src="/img/1313648-20210225174453543-1691727439.png"></p><p>那么 npm/yarn install 的时候，通过扁平化处理之后，究竟是这样</p><p><img src="/img/1313648-20210225174508815-583671864.png"></p><p>还是这样？</p><p><img src="/img/1313648-20210225174526027-1148614674.png"></p><p>答案是: 都有可能。取决于 foo 和 bar 在 <code>package.json</code>中的位置，如果 foo 声明在前面，那么就是前面的结构，否则是后面的结构。</p><p>这就是为什么会产生依赖结构的<code>不确定</code>问题，也是 <code>lock 文件</code>诞生的原因，无论是<code>package-lock.json</code>(npm 5.x才出现)还是<code>yarn.lock</code>，都是为了保证 install 之后都产生确定的<code>node_modules</code>结构。</p><p>尽管如此，npm/yarn 本身还是存在<code>扁平化算法复杂</code>和<code>package 非法访问</code>的问题，影响性能和安全。</p><h3 id="pnpm-依赖管理"><a href="#pnpm-依赖管理" class="headerlink" title="pnpm 依赖管理"></a><strong>pnpm 依赖管理</strong></h3><p>pnpm 的作者<code>Zoltan Kochan</code>发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器，开创了一套新的依赖管理机制，现在就让我们去一探究竟。</p><p>还是以安装 <code>express</code> 为例，我们新建一个目录，执行:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm init <span class="hljs-literal">-y</span><br></code></pre></td></tr></table></figure><p>然后执行:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm install express<br></code></pre></td></tr></table></figure><p>我们再去看看<code>node_modules</code>:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.pnpm<br>.modules.yaml<br>express<br></code></pre></td></tr></table></figure><p>我们直接就看到了<code>express</code>，但值得注意的是，这里仅仅只是一个<code>软链接</code>，不信你打开看看，里面并没有 node_modules 目录，如果是真正的文件位置，那么根据 node 的包加载机制，它是找不到依赖的。那么它真正的位置在哪呢？</p><p>我们继续在 .pnpm 当中寻找:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs powershell">▾ node_modules<br>  ▾ .pnpm<br>    ▸ accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span><br>    ▸ array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span><br>    ...<br>    ▾ express@<span class="hljs-number">4.17</span>.<span class="hljs-number">1</span><br>      ▾ node_modules<br>        ▸ accepts<br>        ▸ array<span class="hljs-literal">-flatten</span><br>        ▸ body<span class="hljs-literal">-parser</span><br>        ▸ content<span class="hljs-literal">-disposition</span><br>        ...<br>        ▸ etag<br>        ▾ express<br>          ▸ lib<br>            History.md<br>            index.js<br>            LICENSE<br>            package.json<br>            Readme.md<br></code></pre></td></tr></table></figure><p>好家伙！竟然在 <code>.pnpm/express@4.17.1/node_modules/express</code>下面找到了!</p><p>随便打开一个别的包:</p><p><img src="/img/1313648-20210225174630884-216606871.png"></p><p>好像也都是一样的规律，都是<code>&lt;package-name&gt;@version/node_modules/&lt;package-name&gt;</code>这种目录结构。并且 express 的依赖都在<code>.pnpm/express@4.17.1/node_modules</code>下面，这些依赖也全都是<strong>软链接</strong>。</p><p>再看看<code>.pnpm</code>，<code>.pnpm</code>目录下虽然呈现的是扁平的目录结构，但仔细想想，顺着<code>软链接</code>慢慢展开，其实就是嵌套的结构！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">▾ node_modules<br>  ▾ .pnpm<br>    ▸ accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span><br>    ▸ array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span><br>    ...<br>    ▾ express@<span class="hljs-number">4.17</span>.<span class="hljs-number">1</span><br>      ▾ node_modules<br>        ▸ accepts  -&gt; ../accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span>/node_modules/accepts<br>        ▸ array<span class="hljs-literal">-flatten</span> -&gt; ../array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>/node_modules/array<span class="hljs-literal">-flatten</span><br>        ...<br>        ▾ express<br>          ▸ lib<br>            History.md<br>            index.js<br>            LICENSE<br>            package.json<br>            Readme.md<br></code></pre></td></tr></table></figure><p>将<code>包本身</code>和<code>依赖</code>放在同一个<code>node_module</code>下面，与原生 Node 完全兼容，又能将 package 与相关的依赖很好地组织到一起，设计十分精妙。</p><p>现在我们回过头来看，根目录下的 node_modules 下面不再是眼花缭乱的依赖，而是跟 <code>package.json</code> 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 <code>node_modules</code> 当中，但整体上，根目录的<code>node_modules</code>比以前还是清晰和规范了许多。</p><h2 id="四、再谈安全"><a href="#四、再谈安全" class="headerlink" title="四、再谈安全"></a><strong>四、再谈安全</strong></h2><p>不知道你发现没有，pnpm 这种依赖管理的方式也很巧妙地规避了<code>非法访问依赖</code>的问题，也就是只要一个包未在 package.json 中声明依赖，那么在项目中是无法访问的。</p><p>但在 npm/yarn 当中是做不到的，那你可能会问了，如果 A 依赖 B， B 依赖 C，那么 A 就算没有声明 C 的依赖，由于有依赖提升的存在，C 被装到了 A 的<code>node_modules</code>里面，那我在 A 里面用 C，跑起来没有问题呀，我上线了之后，也能正常运行啊。不是挺安全的吗？</p><p>还真不是。</p><p>第一，你要知道 B 的版本是可能随时变化的，假如之前依赖的是<code>C@1.0.1</code>，现在发了新版，新版本的 B 依赖 <code>C@2.0.1</code>，那么在项目 A 当中 <code>npm/yarn install</code> 之后，装上的是 2.0.1 版本的 C，而 A 当中用的还是 C 当中旧版的 API，可能就直接报错了。</p><p>第二，如果 B 更新之后，可能不需要 C 了，那么安装依赖的时候，C 都不会装到<code>node_modules</code>里面，A 当中引用 C 的代码直接报错。</p><p>还有一种情况，在 monorepo 项目中，如果 A 依赖 X，B 依赖 X，还有一个 C，它不依赖 X，但它代码里面用到了 X。由于依赖提升的存在，npm/yarn 会把 X 放到根目录的 node_modules 中，这样 C 在本地是能够跑起来的，因为根据 node 的包加载机制，它能够加载到 monorepo 项目根目录下的 node_modules 中的 X。但试想一下，一旦 C 单独发包出去，用户单独安装 C，那么就找不到 X 了，执行到引用 X 的代码时就直接报错了。</p><p>这些，都是依赖提升潜在的 bug。如果是自己的业务代码还好，试想一下如果是给很多开发者用的工具包，那危害就非常严重了。</p><p><code>npm</code> 也有想过去解决这个问题，指定<code>--global-style</code>参数即可禁止变量提升，但这样做相当于回到了当年嵌套依赖的时代，一夜回到解放前，前面提到的嵌套依赖的缺点仍然暴露无遗。</p><p><code>npm/yarn</code> 本身去解决依赖提升的问题貌似很难完成，不过社区针对这个问题也已经有特定的解决方案: <strong>dependency-check</strong>，地址: <a href="https://github.com/dependency-check-team/dependency-check">https://github.com/dependency-check-team/dependency-check</a></p><p>但不可否认的是，pnpm 做的更加彻底，独创的一套依赖管理方式不仅解决了依赖提升的安全问题，还大大优化了时间和空间上的性能。</p><h2 id="五、日常使用"><a href="#五、日常使用" class="headerlink" title="五、日常使用"></a><strong>五、日常使用</strong></h2><p>说了这么多，估计你会觉得 <code>pnpm</code> 挺复杂的，是不是用起来成本很高呢？</p><p>恰好相反，pnpm 使用起来十分简单，如果你之前有 <code>npm/yarn</code> 的使用经验，甚至可以无缝迁移到 pnpm 上来。不信我们来举几个日常使用的例子。</p><h3 id="1-pnpm-install"><a href="#1-pnpm-install" class="headerlink" title="1. pnpm install"></a><strong>1. pnpm install</strong></h3><p>跟 npm install 类似，安装项目下所有的依赖。但对于 monorepo 项目，会安装 workspace 下面所有 packages 的所有依赖。不过可以通过 –filter 参数来指定 package，只对满足条件的 package 进行依赖安装。</p><p>当然，也可以这样使用，来进行单个包的安装:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// 安装 axios<br>pnpm install axios<br>// 安装 axios 并将 axios 添加至 devDependencies<br>pnpm install axios <span class="hljs-literal">-D</span><br>// 安装 axios 并将 axios 添加至 dependencies<br>pnpm install axios <span class="hljs-literal">-S</span><br></code></pre></td></tr></table></figure><p>当然，也可以通过 –filter 来指定 package。</p><h3 id="2-pnpm-update"><a href="#2-pnpm-update" class="headerlink" title="2. pnpm update"></a><strong>2. pnpm update</strong></h3><p>根据指定的范围将包更新到最新版本，monorepo 项目中可以通过 –filter 来指定 package。</p><h3 id="3-pnpm-uninstall"><a href="#3-pnpm-uninstall" class="headerlink" title="3. pnpm uninstall"></a><strong>3. pnpm uninstall</strong></h3><p>在 node_modules 和 package.json 中移除指定的依赖。monorepo 项目同上。举例如下:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// 移除 axios<br>pnpm uninstall axios <span class="hljs-literal">--filter</span> package<span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><h3 id="4-pnpm-link"><a href="#4-pnpm-link" class="headerlink" title="4. pnpm link"></a><strong>4. pnpm link</strong></h3><p>将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链接。如:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm link ../../axios<br></code></pre></td></tr></table></figure><p>另外，对于我们经常用到<code>npm run/start/test/publish</code>，这些直接换成 pnpm 也是一样的，不再赘述。更多的使用姿势可参考官方文档: <a href="https://pnpm.js.org/en/">https://pnpm.js.org/en/</a></p><p>可以看到，虽然 pnpm 内部做了非常多复杂的设计，但实际上对于用户来说是无感知的，使用起来非常友好。并且，现在作者现在还一直在维护，目前 npm 上周下载量已经有 10w +，经历了大规模用户的考验，稳定性也能有所保障。</p><p>因此，综合来看，pnpm 是一个相比 npm/yarn 更优的方案，期待未来 pnpm 能有更多的落地。</p><p>转自：<a href="https://www.cnblogs.com/cangqinglang/p/14448329.html">https://www.cnblogs.com/cangqinglang/p/14448329.html</a></p>]]></content>
    
    
    <categories>
      
      <category>包管理工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>包管理工具</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yapi部署踩坑总结</title>
    <link href="/2023/07/10/yapi%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/07/10/yapi%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="yapi部署踩坑总结"><a href="#yapi部署踩坑总结" class="headerlink" title="yapi部署踩坑总结"></a>yapi部署踩坑总结</h1><h2 id="一、mac本地部署yapi"><a href="#一、mac本地部署yapi" class="headerlink" title="一、mac本地部署yapi"></a>一、mac本地部署yapi</h2><h3 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1. 环境要求"></a>1. 环境要求</h3><ul><li>nodejs（7.6+)</li><li>mongodb（2.6+）  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 我们通过brew工具来下载mongo</span><br><span class="hljs-comment">//第一步</span><br>brew tap mongodb/brew<br><br><span class="hljs-comment">//第二步</span><br>brew install mongodb-community@<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h3><p>我们使用官方推荐的<a href="https://hellosean1025.github.io/yapi/devops/index.html"><strong>方式一</strong></a> （可视化部署）</p><p>执行 yapi server 启动可视化部署程序，输入相应的配置和点击开始部署，就能完成整个网站的部署。</p><h3 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h3><p>部署完成之后，可按照提示信息，执行 <code>node/&#123;网站路径/server/app.js&#125;</code> 启动服务器。</p><p>在浏览器打开指定<code>url</code>, 点击登录输入您刚才设置的管理员邮箱，默认密码([<code>ymfe.org](http://ymfe.org/))</code> 登录系统（默认密码可在个人中心修改）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g yapi-cli --registry https://registry.npm.taobao.org<br>yapi server<br></code></pre></td></tr></table></figure><h3 id="2-遇到的报错："><a href="#2-遇到的报错：" class="headerlink" title="2. 遇到的报错："></a>2. 遇到的报错：</h3><p><strong>2.1 执行命令</strong> <code>npm install -g yapi-cli --registry https://registry.npm.taobao.org</code> </p><p>【报错】npm Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules‘</p><p>【原因】权限不足</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_7a485250-3882-497f-a7a6-1ce11519f494.png"></p><p>【解决】在命令前加上sudo，完整命令 <code>sudo npm install -g yapi-cli --registry https://registry.npm.taobao.org</code> </p><p><strong>2.2 页面一键部署yapi报错</strong></p><p>【报错】解决mongodb ：failed to connect to server [127.0.0.1:27017] on first connect</p><p>【原因】没有启动或者安装mongodb</p><p><strong>2.3 安装mogodb命令</strong><code>brew tap mongodb/brew</code></p><p>【报错】</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_5368f4d4-b895-4656-a149-3d2e69099e18.png"></p><p>【原因】操作系统的权限问题</p><p>【解决】确保/opt/homebrew/Library/Taps/目录存在，检查Taps目录以及子目录的具有读写权限</p><p><strong>2.4 安装成功后执行 mongo –version出现</strong> <code>zsh: command not found: mongo</code></p><p>【原因】全局变量没有注册</p><p>【解决】需执行<code>echo &#39;export PATH=&quot;/opt/homebrew/opt/mongodb-community@5.0/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc</code>，然后再执行<code>source ~/.zshrc</code>来立即生效</p><p><strong>2.5 启动mongodb 服务</strong><code>brew services start mongodb-community@5.0</code></p><p>【报错】Permission denied @ rb_sysopen - /Users/zhangwei/Library/LaunchAgents/<a href="mailto:&#104;&#x6f;&#109;&#x65;&#x62;&#x72;&#x65;&#119;&#x2e;&#109;&#x78;&#x63;&#108;&#46;&#109;&#x6f;&#x6e;&#x67;&#x6f;&#100;&#98;&#45;&#99;&#111;&#109;&#x6d;&#117;&#110;&#105;&#x74;&#121;&#x40;&#53;&#x2e;&#48;&#x2e;&#x70;&#x6c;&#x69;&#x73;&#x74;">&#104;&#x6f;&#109;&#x65;&#x62;&#x72;&#x65;&#119;&#x2e;&#109;&#x78;&#x63;&#108;&#46;&#109;&#x6f;&#x6e;&#x67;&#x6f;&#100;&#98;&#45;&#99;&#111;&#109;&#x6d;&#117;&#110;&#105;&#x74;&#121;&#x40;&#53;&#x2e;&#48;&#x2e;&#x70;&#x6c;&#x69;&#x73;&#x74;</a></p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_f438d224-2304-46cd-9d64-2efab9948896.png"></p><p>【原因】权限问题</p><p>【解决】命令前加sudo</p><p>2.6 报错：Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_47220176-f6b9-48ff-a455-dcbbb5fefa7b.png"></p><p>【原因】node版本不匹配</p><p>【解决】node改为@12.18.2版本</p><p>2.7 一键部署yapi</p><p>【报错】</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_ead1b2cc-d1f5-4d51-9903-859ccbc2249d.png"></p><p>【原因】部署版本过低</p><p>【解决】改为1.10.1就没有这个问题了</p><p><strong>2.8 在执行node vendors/server/app.js出现的报错</strong></p><p>【报错】</p><p><img src="/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_445a3862-d432-4889-8467-94903d7a0b33.png"></p><p>【原因】还是权限问题，先命令前加sudo</p><h3 id="3-总结："><a href="#3-总结：" class="headerlink" title="3. 总结："></a>3. 总结：</h3><p>如果是权限不足就可以通过命令前加sudo方式解决，如果不行就通过到对应文件夹里将文件夹对应的权限打开。</p><p>tips：mac可以通过**<code>command + shift + .</code>**开启隐藏文件夹</p><h2 id="二、服务器端部署yapi"><a href="#二、服务器端部署yapi" class="headerlink" title="二、服务器端部署yapi"></a>二、服务器端部署yapi</h2><p>docker地址：<a href="https://hub.docker.com/r/yapipro/yapi">yapipro/yapi - Docker Image | Docker Hub</a></p><h3 id="部署常用的命令"><a href="#部署常用的命令" class="headerlink" title="部署常用的命令"></a>部署常用的命令</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-comment">// 载入docker</span><br>docker load -i ./yapi+mongo.<span class="hljs-property">tar</span> <br><br><span class="hljs-comment">//查看load的imgage</span><br> dockr images ｜ grep mongo<br><br><span class="hljs-comment">//创建容器之间网络</span><br>docker network create yapi_mongo<br><br><span class="hljs-comment">// 运行mongo镜像</span><br>docker run -d -p <span class="hljs-number">31666</span>:<span class="hljs-number">27017</span> --name=<span class="hljs-title function_">mongozw</span>(容器名) --network <span class="hljs-title function_">yapi_mongo</span>(网络名) <span class="hljs-attr">mongo</span>:<span class="hljs-title function_">latest</span>(版本)<br><br><span class="hljs-comment">//过滤并查看mongo启动情况</span><br>docker ps ｜ grep <span class="hljs-title function_">mongozw</span>(容器名)<br><br><span class="hljs-comment">// 进入容器里面</span><br>docker exec -it <span class="hljs-title function_">mongozw</span>(容器名) bash<br><br><span class="hljs-comment">//启动容器</span><br>docker start f7dd（容器名或者id）<br><br><span class="hljs-comment">//关闭容器</span><br>docker stop f7dd（容器名或者id）<br><br><span class="hljs-comment">//将config.js文件添加到项目里</span><br>docker run -d --rm --name yapi-init --link <span class="hljs-attr">mongozw</span>:mongo --network yapi_mongo -v $PWD/config.<span class="hljs-property">json</span>:<span class="hljs-regexp">/yapi/</span>config.<span class="hljs-property">json</span> yapipro/yapi server/install.<span class="hljs-property">js</span><br><br><span class="hljs-comment">//运行yapi镜像</span><br>docker run -d --name yapi --link <span class="hljs-attr">mongozw</span>:mongo --network yapi_mongo -p <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span> -v $PWD/config.<span class="hljs-property">json</span>:<span class="hljs-regexp">/yapi/</span>config.<span class="hljs-property">json</span> yapipro/yapi server/app.<span class="hljs-property">js</span><br><br><span class="hljs-comment">//查看服务能否访问</span><br>curl localhost：<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3000&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;adminAccount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexiaohei1024@gmail.com&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">120000</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;db&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;servername&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mongo&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;DATABASE&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yapi&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">27017</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yapi&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;pass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yapi123456&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;authSource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;mail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;smtp.gmail.com&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">465</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexiaohei1024@gmail.com&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;pass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br>     <span class="hljs-punctuation">&#125;</span><br>   <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs json">#!/bin/bash<br><br>echo “脚本开始”<br><br>docker load -i ./yapi+mongo.tar <br><br>docker network create yapi_mongo<br><br>docker run -d --name mongodb --network yapi_mongo -p <span class="hljs-number">27017</span><span class="hljs-punctuation">:</span><span class="hljs-number">27017</span> -v mongo-data<span class="hljs-punctuation">:</span>/data/db -e MONGO_INITDB_DATABASE=yapi -e MONGO_INITDB_ROOT_USERNAME=yapipro -e MONGO_INITDB_ROOT_PASSWORD=yapipro1024 mongo<span class="hljs-punctuation">:</span>latest<br><br>docker exec -it mongozw bash<br><br>mongo localhost：<span class="hljs-number">27017</span><br><br>use admin;<br><br>db.auth(<span class="hljs-string">&quot;yapipro&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;yapipro1024&quot;</span>);<br><br>use yapi;<br><br>db.createUser(<span class="hljs-punctuation">&#123;</span><br>  user<span class="hljs-punctuation">:</span> &#x27;yapi&#x27;<span class="hljs-punctuation">,</span><br>  pwd<span class="hljs-punctuation">:</span> &#x27;yapi123456&#x27;<span class="hljs-punctuation">,</span><br>  roles<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br> <span class="hljs-punctuation">&#123;</span> role<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dbAdmin&quot;</span><span class="hljs-punctuation">,</span> db<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yapi&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-punctuation">&#123;</span> role<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;readWrite&quot;</span><span class="hljs-punctuation">,</span> db<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yapi&quot;</span> <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span>);<br><br>exit<br><br>exit<br><br>docker run -d --rm --name yapi-init --link mongozw<span class="hljs-punctuation">:</span>mongo --network yapi_mongo -v $PWD/config.json<span class="hljs-punctuation">:</span>/yapi/config.json yapipro/yapi server/install.js<br><br>docker run -d --name yapi --link mongozw<span class="hljs-punctuation">:</span>mongo --network yapi_mongo -p <span class="hljs-number">3000</span><span class="hljs-punctuation">:</span><span class="hljs-number">3000</span> -v $PWD/config.json<span class="hljs-punctuation">:</span>/yapi/config.json yapipro/yapi server/app.js<br><br>curl localhost：<span class="hljs-number">3000</span><br><br>echo “脚本结束”<br><br></code></pre></td></tr></table></figure><p>参考：</p><p><a href="https://juejin.cn/post/6844903845496094727">Docker构建YApi镜像, Docker安装YApi, Docker部署YApi - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>yapi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commander入门学习</title>
    <link href="/2023/06/10/commander%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/06/10/commander%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="commander入门学习"><a href="#commander入门学习" class="headerlink" title="commander入门学习"></a>commander入门学习</h1><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>commander 是做命令行工具的， 简单来说， 这东西主要是做参数解析，而<strong>不是</strong>做交互式命令行（跟 vue-cli 那种询问式的一样）</p><p>如果要做交互式命令行， 可以试试 <code>inquirer</code>，拿到参数之后， 你还是要编写自己的具体功能实现</p><p>可以直接跳到 示例 来查看效果</p><h1 id="二、命令行是怎么运行的"><a href="#二、命令行是怎么运行的" class="headerlink" title="二、命令行是怎么运行的"></a><strong>二、命令行是怎么运行的</strong></h1><p><strong>以 <code>zip</code> 为例：</strong></p><p>一般命令行执行的时候，都是带选项的， 比如输入<code>zip -h</code>会输出 <code>zip</code> 命令的帮助信息</p><p>一般来说，压缩一个文件夹一般这么写的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx">zip /home/output/dist.<span class="hljs-property">zip</span> .<span class="hljs-comment">/* -r</span><br></code></pre></td></tr></table></figure><p>表示将当前文件夹下所有文件/夹都添加到压缩文件中，并且输出到 <code>/home/output/dist.zip</code> 这个文件中， <code>-r</code> 是选项， 表示包括递归的文件夹</p><p> 在commander 中， <code>/home/output/dist.zip</code> 和  <code>./*</code> 是 arguments，<code>-r</code> 是 options</p><ul><li>arguments 是可以有任意多个。格式是字符串， 需要特定的格式， 可以加校验器做类型转换。</li><li>option 也是可以有任意多个， 而且 option 可以带参数， 参数同样可以是任意多个，其值一般是 <code>true/false</code>， 如果带了参数，则是字符串、字符串数组（多个参数的话）</li></ul><h1 id="三、commander-入门"><a href="#三、commander-入门" class="headerlink" title="三、commander 入门"></a><strong>三、commander 入门</strong></h1><p>首先， 要安装 commander</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">npm install commander<br></code></pre></td></tr></table></figure><p>安装好之后， 可以写一个写一个脚本试一试</p><h2 id="1-解析-arguments"><a href="#1-解析-arguments" class="headerlink" title="1. 解析 arguments"></a><strong>1. 解析 arguments</strong></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Command</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;commander&#x27;</span>)<br><span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>()<br>program<br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;&lt;name&gt;&#x27;</span>, <span class="hljs-string">&#x27;name discription&#x27;</span>) <br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;[password]&#x27;</span>, <span class="hljs-string">&#x27;pass discription&#x27;</span>)<br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;[other...]&#x27;</span>, <span class="hljs-string">&#x27;other discription&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>参数为必传， 用 <code>&lt;&gt;</code> 包起来；</li><li>参数为选填， 则用 <code>[]</code> 包起来；</li><li>变长参数， 在参数名后面加上 <code>...</code> ；</li></ul><p>注意：【变长参数】就是把前面两个参数填充好了之后， 剩下的参数都会扔到 other 里头去，不过，只有最后一个参数支持变长。</p><h2 id="2-解析-option"><a href="#2-解析-option" class="headerlink" title="2. 解析 option"></a><strong>2. 解析 option</strong></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Command</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;commander&#x27;</span>)<br><span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>()<br>program *<span class="hljs-comment">//*</span><br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-r --reload&#x27;</span>, <span class="hljs-string">&#x27;reload description&#x27;</span>)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-r --no-immediate&#x27;</span>, <span class="hljs-string">&#x27;reload description&#x27;</span>)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-o --output [output]&#x27;</span>, <span class="hljs-string">&#x27;output description&#x27;</span>)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-s --sendto &lt;user...&gt;&#x27;</span>, <span class="hljs-string">&#x27;sendto description&#x27;</span>)<br>  <br><span class="hljs-comment">// 同arguments参数， 必填非必填， 用[] 和 &lt;&gt; 来标注</span><br><span class="hljs-comment">// 同`arguments`参数，如果有变长参数， 用`...`来表示</span><br></code></pre></td></tr></table></figure><p>如上所示， 可以有多个选项，每个选项都可以有参数， 如果没有参数则：</p><ol><li>给了选项即为 true， 没有这个选项则为false</li><li>需要默认为 true 的话， 则定义成 <code>-no-xxx</code> ，这样， 则用户给了选项即为 false， 没有该选项值为 true 在这个例子中，选项 “–no-immediate” 如果没有被用户在命令行中指定，那么 “immediate mode” 将被认为是开启的（值为 <code>true</code>）。如果用户指定了 “–no-immediate”，那么 “immediate mode” 将被关闭（值为 <code>false</code>）</li></ol><h2 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3. 数据校验"></a><strong>3. 数据校验</strong></h2><h3 id="3-1-单参数"><a href="#3-1-单参数" class="headerlink" title="3.1 单参数"></a>3.1 单参数</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Command</span>, <span class="hljs-title class_">InvalidArgumentError</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;commander&#x27;</span><br><span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">val: string</span>) &#123;<br>  <span class="hljs-comment">// 在这里做校验</span><br>  <span class="hljs-keyword">let</span> pass = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span> (!pass) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidArgumentError</span>(<span class="hljs-string">&#x27;参数不正确&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br>program.<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;&lt;name&gt;&#x27;</span>, <span class="hljs-string">&#x27;name discription&#x27;</span>, validator)<br></code></pre></td></tr></table></figure><h3 id="3-2-多参数"><a href="#3-2-多参数" class="headerlink" title="3.2 多参数"></a>3.2 多参数</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Command</span>, <span class="hljs-title class_">InvalidArgumentError</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;commander&#x27;</span><br><span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">val: string, pre: string[]</span>) &#123;<br>  *<span class="hljs-comment">// 在这里做校验*</span><br>  <span class="hljs-keyword">let</span> pass = <span class="hljs-title function_">trueif</span> (!pass) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidArgumentError</span>(<span class="hljs-string">&#x27;参数不正确&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (pre) &#123;<br>    <span class="hljs-keyword">return</span> [...pre, val]<br>  &#125;<br>  <span class="hljs-keyword">return</span> [val]<br>&#125;<br>program *<span class="hljs-comment">//*</span><br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;&lt;name...&gt;&#x27;</span>, <span class="hljs-string">&#x27;name discription&#x27;</span>, validator, [])<br>  *<span class="hljs-comment">// 这里可以用同一个校验， 也可以用不同的校验*</span><br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-s --sendto &lt;user...&gt;&#x27;</span>, <span class="hljs-string">&#x27;sendto discription&#x27;</span>, validator, [])<br></code></pre></td></tr></table></figure><p>多参数， 会将每个参数都放到这个校验函数<code>validator</code>里头来执行一遍</p><p>最后， 再坠上一个默认参数<code>[]</code> (单参数的也可以有默认参数)， 调用的时候， 就只用判断 length， 而不用判断参数本身不存在的情况了</p><h2 id="4-解析用户输入，-以及执行功能"><a href="#4-解析用户输入，-以及执行功能" class="headerlink" title="4. 解析用户输入， 以及执行功能"></a><strong>4. 解析用户输入， 以及执行功能</strong></h2><p>前面是定义一些参数， 如果参数不符合要求 commander 会直接报错， 不会进入调用流程。</p><p>实际执行功能的话， 还需要定义一个回调：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">*<span class="hljs-comment">// 设置一个回调， 如果parse都通过了， 则进入这里开始执行回调</span><br><span class="hljs-comment">//  这里的参数，跟用argument定义的参数是一一对应的， 而option则被集合成了一个*</span><br>program.<span class="hljs-title function_">action</span>((<span class="hljs-attr">arg1</span>: **string**, <span class="hljs-attr">arg2</span>: **string**, <span class="hljs-attr">option</span>: **any**) **=&gt;** &#123;<br>  *<span class="hljs-comment">// 这里开始拿到用户输入的参数值， 和选项值， 然后进行一些判断，配置， 之后开始执行*</span><br>&#125;)<br>*<span class="hljs-comment">// program.parse(process.argv) // process.argv 这个参数给和不给， 在node环境下是一致的*</span><br>program.<span class="hljs-title function_">parse</span>()<br></code></pre></td></tr></table></figure><p>注意：commander 会待解析成功之后， 再调用这个回调 来执行功能</p><p>以上所有的代码示例， 都是可以链式调用的， 整合一下，如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Command</span>, <span class="hljs-title class_">InvalidArgumentError</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;commander&#x27;</span>)<br><br><span class="hljs-keyword">const</span> program = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opValidate</span>(<span class="hljs-params">value, dummyPrevious</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value != <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidArgumentError</span>(<span class="hljs-string">&#x27;必须输入正确的字符串&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opArrValidate</span>(<span class="hljs-params">value, dummyPrevious</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value != <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidArgumentError</span>(<span class="hljs-string">&#x27;必须输入正确的字符串&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (dummyPrevious) &#123;<br>    <span class="hljs-keyword">return</span> [...dummyPrevious, value]<br>  &#125;<br>  <span class="hljs-keyword">return</span> [value]<br>&#125;<br><br>program<br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;&lt;name&gt;&#x27;</span>, <span class="hljs-string">&#x27;登录用户名&#x27;</span>)<br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;[password]&#x27;</span>, <span class="hljs-string">&#x27;登录密码， 默认密码123456&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br>  .<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;[other...]&#x27;</span>, <span class="hljs-string">&#x27;其他参数&#x27;</span>, opArrValidate, [<span class="hljs-string">&#x27;other初始值&#x27;</span>])<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-o, --output &lt;output&gt;&#x27;</span>, <span class="hljs-string">&#x27;文件生成位置&#x27;</span>, opValidate)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-l, --no-log &#x27;</span>, <span class="hljs-string">&#x27;是否输出日志&#x27;</span>)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&#x27;-s, --sendto &lt;user...&gt; &#x27;</span>, <span class="hljs-string">&#x27;发送到用户&#x27;</span>, opArrValidate)<br>  .<span class="hljs-title function_">action</span>(<span class="hljs-title function_">async</span> (url, password, other, option) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url, password, other, option)<br>    <span class="hljs-keyword">try</span> &#123;<br>      *<span class="hljs-comment">// 这里执行代码*</span><br>      *<span class="hljs-comment">// await wat??*</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>      process.<span class="hljs-title function_">exit</span>(-<span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">parse</span>()<br></code></pre></td></tr></table></figure><p>将以上代码保存为 <code>commander.test.js</code></p><p>在 cmd/SHELL 中， 用户输入如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node commander**.**<span class="hljs-built_in">test</span>**.**js username userpassword other1 other2 other3 **-**o outputvalue **-**l **-**s username1 **-**s username2 **-**s username3<br></code></pre></td></tr></table></figure><p>得到输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">username userpassword [ <span class="hljs-string">&#x27;other初始值&#x27;</span>, <span class="hljs-string">&#x27;other1&#x27;</span>, <span class="hljs-string">&#x27;other2&#x27;</span>, <span class="hljs-string">&#x27;other3&#x27;</span> ] &#123;<br>  <span class="hljs-built_in">log</span>: <span class="hljs-literal">false</span>,<br>  output: <span class="hljs-string">&#x27;outputvalue&#x27;</span>,<br>  sendto: [ <span class="hljs-string">&#x27;username1&#x27;</span>, <span class="hljs-string">&#x27;username2&#x27;</span>, <span class="hljs-string">&#x27;username3&#x27;</span> ]<br>&#125;<br></code></pre></td></tr></table></figure><p>由于上面的代码中， 变长参数和多参数选项同时存在， 所以给多参数选项赋值参数的时候，要每个参数都写<code>-s</code>。如果没有变长参数，并且你确定在这种情况下用户不会输入多个<code>-s</code>选项对应的参数，那么可以不写多个<code>-s</code>。</p><h2 id="5-其他-program-选项"><a href="#5-其他-program-选项" class="headerlink" title="5. 其他 program 选项"></a><strong>5. 其他 program 选项</strong></h2><ol><li><code>program.version(version)</code> 用来标记当前工具版本， 对于功能不影响</li><li><code>program.usage(&#39;作用&#39;)</code> 用来做提示输出用的， 对于功能不影响</li><li><code>program.helpOption(&#39;-h, --help&#39;, &#39;帮助信息&#39;)</code> 可以用来将这一行信息汉化，默认是英文的</li></ol><h2 id="6-提示信息参考"><a href="#6-提示信息参考" class="headerlink" title="6. 提示信息参考"></a><strong>6. 提示信息参考</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: commander.test [options] &lt;name&gt; [password] [other...]<br><br>Arguments:<br>  name                     登录用户名<br>  password                 登录密码， 默认密码123456 (default: <span class="hljs-string">&quot;123456&quot;</span>)<br>  other                    其他参数 (default: [<span class="hljs-string">&quot;other默认值&quot;</span>])<br><br>Options:<br>  -o, --output &lt;output&gt;    文件生成位置<br>  -l, --no-log             是否输出日志<br>  -s, --sendto &lt;user...&gt;   发送到用户<br>  -h, --<span class="hljs-built_in">help</span>               display <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><h2 id="7-使用你的命令行"><a href="#7-使用你的命令行" class="headerlink" title="7.使用你的命令行"></a><strong>7.使用你的命令行</strong></h2><p>最后， 如果你的代码希望能够在命令行直接使用， 那么写完这些还是不够的</p><h3 id="7-1-linux-环境"><a href="#7-1-linux-环境" class="headerlink" title="7.1  linux 环境"></a>7.1  linux 环境</h3><ul><li>在文件顶部加上  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx">#/usr/bin/env node<br></code></pre></td></tr></table></figure></li><li>给这个脚本赋一个执行权限  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx">chmod +x <span class="hljs-title function_">XXX</span>(文件名)<br></code></pre></td></tr></table></figure></li><li>将该文件所在目录添加到 <code>PATH</code> 环境变量中，或者将文件移动到已在 <code>PATH</code> 中的目录中。</li></ul><p>注意： 建议把文件 <code>.js</code> 后缀删掉， 不然每次还得输入一个 xxx.js 多讨厌</p><h3 id="7-2-windows-环境"><a href="#7-2-windows-环境" class="headerlink" title="7.2  windows 环境"></a>7.2  windows 环境</h3><ol><li><strong>找到 npm 的全局安装目录</strong>：<ul><li><code>C:\Users\&lt;username&gt;\AppData\Roaming\npm</code>是通常情况下 npm 的全局安装目录。这个目录用于存放全局安装的 Node.js 包。</li></ul></li><li><strong>创建目录并放入代码</strong>：<ul><li>在 <code>node_modules</code> 目录下创建一个新目录，比如 <code>commander.test</code>。</li><li>将编写好的代码复制到这个目录中。如果代码有依赖项并且是经过打包的，可以将打包后的文件放入；如果没有打包，也可以将全部代码放入。如果使用了打包工具，可能需要在这个目录中放置一个 <code>package.json</code> 文件，并安装运行时依赖项。</li></ul></li><li><strong>创建可执行文件</strong>：<ul><li>在上级目录中（通常是 <code>C:\Users\&lt;username&gt;\AppData\Roaming\npm</code>），找到一个文件进行复制并改名。这里以 <code>yarn.cmd</code> 为例，复制一份并改名为 <code>commander.test</code>。</li><li>然后编辑这个新创建的文件，将其中指向 <code>yarn.js</code> 的路径改为指向刚才放入的命令行工具的入口文件。例如，如果命令行工具的入口文件是 <code>commander.test.js</code>，则将 <code>&quot;%_prog%&quot; &quot;%dp0%\node_modules\yarn\bin\yarn.js&quot;</code> 改为 <code>&quot;%_prog%&quot; &quot;%dp0%\node_modules\commander.test\commander.test.js&quot;</code>。</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@<span class="hljs-variable constant_">ECHO</span> off<br><span class="hljs-variable constant_">SETLOCAL</span><br><span class="hljs-variable constant_">CALL</span> :find_dp0<br><br><span class="hljs-variable constant_">IF</span> <span class="hljs-variable constant_">EXIST</span> <span class="hljs-string">&quot;%dp0%\node.exe&quot;</span> (<br>  <span class="hljs-variable constant_">SET</span> <span class="hljs-string">&quot;_prog=%dp0%\node.exe&quot;</span><br>) <span class="hljs-title function_">ELSE</span> (<br>  <span class="hljs-variable constant_">SET</span> <span class="hljs-string">&quot;_prog=node&quot;</span><br>  <span class="hljs-variable constant_">SET</span> <span class="hljs-variable constant_">PATHEXT</span>=%<span class="hljs-attr">PATHEXT</span>:;.<span class="hljs-property">JS</span>;=;%<br>)<br><br><span class="hljs-string">&quot;%_prog%&quot;</span>  <span class="hljs-string">&quot;%dp0%\node_modules\yarn\bin\yarn.js&quot;</span> %*  <span class="language-xml">&lt;--- 改这里</span><br><span class="language-xml">ENDLOCAL</span><br><span class="language-xml">EXIT /b %errorlevel%</span><br><span class="language-xml">:find_dp0</span><br><span class="language-xml">SET dp0=%~dp0</span><br><span class="language-xml">EXIT /b</span><br></code></pre></td></tr></table></figure><p>这样修改后，在命令行中直接输入 <code>commander.test</code> 就可以运行这个命令行工具了。</p><p>注意：名称和路径， 需要按照你的实际情况来修改</p><h3 id="7-3-npm包"><a href="#7-3-npm包" class="headerlink" title="7.3 npm包"></a>7.3 npm包</h3><p>把它发布到 npm 上， 然后通过 npm install -g 来安装， 安装之后就可以直接使用了</p>]]></content>
    
    
    <categories>
      
      <category>commander</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES Modules原理浅析</title>
    <link href="/2023/05/05/ES%20Modules%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2023/05/05/ES%20Modules%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ES-Modules原理浅析"><a href="#ES-Modules原理浅析" class="headerlink" title="ES Modules原理浅析"></a><strong>ES Modules原理浅析</strong></h1><h1 id="一、浏览器对ES-Modules的支持"><a href="#一、浏览器对ES-Modules的支持" class="headerlink" title="一、浏览器对ES Modules的支持"></a><strong>一、浏览器对ES Modules的支持</strong></h1><p><code>ES Modules</code>是浏览器原生支持的模块系统。而在之前，常用的是<code>CommonJS</code>和基于 <code>AMD</code> 的其他模块系统 如 <code>RequireJS</code>。</p><p>来看下目前浏览器对其的支持：</p><p><img src="/img/34039f1c-014a-477c-9b88-1edfa3c368fc.png"></p><p>主流的浏览器（IE11 除外）均已经支持，其最大的特点是在浏览器端使用 <code>export</code>、 <code>import</code>的方式导入和导出模块，在 <code>script</code> 标签里设置 <code>type=&quot;module&quot;</code>，然后使用模块内容:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">import</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br>&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="二、ES-Modules如何工作"><a href="#二、ES-Modules如何工作" class="headerlink" title="二、ES Modules如何工作"></a>二、ES Modules如何工作</h1><p>当我们使用<code>ES Modules</code>进行开发时，实际上是在构建一个依赖关系图。不同依赖项之间通过导入语句来进行关联。</p><p>浏览器或 Node通过这些import语句判断加载哪些代码。从入口文件开始查找其余问价代码。</p><p><img src="/img/16e1dc10-d5b7-492f-b614-2f00f10820bc.png"></p><p>但是浏览器不可以直接使用文件本身。需要将这些文件转换为模块记录。</p><p>之后，需要将模块记录转化为模块实例，<strong>模块实例包含两部分：代码和状态。</strong></p><p><img src="/img/157c18fa-3a4f-4bf1-a888-42edd7d0fff5.png"></p><p>我们需要的就是最后生成的模块实例。</p><h2 id="1-模块的加载"><a href="#1-模块的加载" class="headerlink" title="1. 模块的加载"></a>1. 模块的加载</h2><p>模块加载的过程就是从入口文件到拥有一个完整的模块实例图的过程。</p><p>对于 ES 模块来说，分三步进行：</p><ul><li><code>构造</code>——查找、下载并解析所有文件到模块记录中</li><li><code>实例化</code>——在内存中寻找一块区域来存储所有导出的变量（但还没有填充值）。然后让 export 和 import 都指向这些内存块。这个过程叫做链接（linking）</li><li><code>求值</code>——在内存块中填入变量的实际值。</li></ul><p><img src="/img/6616e3d5-95c3-4e8b-9176-693c5d50041f.png"></p><h2 id="2-构造阶段（Construction）"><a href="#2-构造阶段（Construction）" class="headerlink" title="2. 构造阶段（Construction）"></a>2. 构造阶段（Construction）</h2><p>在构造阶段，每个模块都会经历三件事情：</p><ul><li>Find：找出从哪里下载包含该模块的文件（也称为模块解析）</li><li>Download：获取文件（从 URL 下载或从文件系统加载）</li><li>Parse：将文件解析为模块记录</li></ul><h3 id="2-1-Find-查找"><a href="#2-1-Find-查找" class="headerlink" title="2.1 Find 查找"></a>2.1 Find 查找</h3><p>通常我们会有一个入口文件main.js：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script src=<span class="hljs-string">&quot;main.js&quot;</span> type=<span class="hljs-string">&quot;module&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>然后通过如下代码去寻找与之关联的其他模块。</p><p><img src="/img/3382952b-a6af-4ac0-a7fc-e1336ec2bb9a.png"></p><p>import 语句中的一部分称为 Module Specifier。它告诉 Loader 在哪里可以找到引入的模块。</p><p>关于模块标识符有一点需要注意：它们有时需要在浏览器和Node之间进行不同的处理。每个宿主都有自己的解释模块标识符字符串的方式。</p><p>目前在浏览器中只能使用 URL 作为 Module Specifier，也就是使用 URL 去加载模块。</p><h3 id="2-2-Download-下载"><a href="#2-2-Download-下载" class="headerlink" title="2.2 Download 下载"></a>2.2 Download 下载</h3><p>而有个问题也随之而来，浏览器在解析文件前并不知道文件依赖哪些模块，当然获取文件之前更无法解析文件。这意味着我们必须一层一层地遍历树，解析一个文件，然后找出它的依赖项，然后找到并加载这些依赖项，如下，一层层的去解析。</p><p><img src="/img/44335055-8918-41c4-b33c-5c0fb1fe7adf.png"></p><p>如果主线程要等待这些文件中的每一个下载，那么许多其他任务将堆积在其队列中。</p><p>这将导致整个解析依赖关系的流程是阻塞的。</p><p><img src="/img/907f5b92-a13a-45aa-9d99-8e495c0ddd2b.png"></p><p>像这样阻塞主线程会让采用了模块的应用程序速度太慢而无法使用。这是 <code>ES</code> 模块规范将算法分为多个阶段的原因之一。将构造过程单独分离出来，使得浏览器在执行同步的初始化过程前可以自行下载文件并建立自己对于模块图的理解。</p><p>但是在commonJs中，加载文件是直接从系统中加载的，这比从浏览器下载快很多。因为Node使用commonJs,所以这也造成了其在加载过程中可能会阻塞主线程。</p><p><img src="/img/ce68c258-3256-43fb-8ae3-dc0b47aa0117.png"></p><p>因为commonJs是同步的，值执行之前，可以知道变量的值，所以在模块标识符中可以使用变量。</p><p>但对于 <code>ES</code> 模块，先构建整个模块图在前，此时还未进行求值。所以模块标识符中不能有变量，因为这些变量还没有值。</p><p><img src="/img/83b00c86-f11a-4ebe-8d9c-395bbd8db27d.png"></p><p>但有时候在模块路径使用变量确实非常有用。例如，你可能需要根据代码的运行情况或运行环境来切换加载某个模块。</p><p>为了让 <code>ES</code> 模块支持这个，有一个名为 <code>动态导入</code> 的提案。有了它，你可以像 <code>import($&#123;path&#125; /foo.js</code> 这样使用 <code>import</code> 语句。</p><p>它的原理是，任何通过 <code>import()</code> 加载的的文件都会被作为一个独立的依赖图的入口。动态导入的模块开启一个新的依赖图，并单独处理。</p><p><img src="/img/d29242de-fe10-4b62-8bbd-4cb4aec2ed4d.png"></p><p>不过需要注意的一点是——这两个图中的任何模块都将共享一个模块实例。这是因为加载器缓存了模块实例。对于特定全局范围内的每个模块，将只有一个模块实例。</p><p><img src="/img/10f44e41-b679-4a88-b6b7-51998b31eecc.png"></p><h3 id="2-3-Parse-解析"><a href="#2-3-Parse-解析" class="headerlink" title="2.3 Parse 解析"></a>2.3 Parse 解析</h3><p>我们把它解析出来的模块构成表 称为 <code>Module Record</code> 模块记录</p><p><img src="/img/0ce5d3eb-d494-413e-8153-650803bb793b.png"></p><p>模块记录包含了当前模块的 <code>AST</code>，引用了哪些模块的变量，以前一些特定属性和方法。</p><p>一旦模块记录被创建，它会被记录在模块映射<code>Module Map</code>中。被记录后，如果再有对相同 <code>URL</code> 的请求，<code>Loader</code> 将直接采用 <code>Module Map</code> 中 <code>URL</code> 对应的<code>Module Record</code>。</p><p><img src="/img/3c0cbca5-fbde-4d30-866d-974b50075b0b.png"></p><p>解析中有一个细节可能看起来微不足道，但实际上有很大的影响。所有的模块都被当作在顶部使用了 <code>&quot;use strict&quot;</code> 来解析。还有一些其他细微差别。例如，关键字 <code>await</code> 保留在模块的顶层代码中，<code>this</code> 的值是 <code>undefined</code>。</p><p>这种不同的解析方式被称为<code>解析目标</code>。如果你使用不同的目标解析相同的文件，你会得到不同的结果。所以在开始解析前你要知道正在解析的文件的类型：它是否是一个模块？</p><p>在浏览器中只需在 <code>script</code> 标记中设置 <code>type=&quot;module&quot;</code>,告诉浏览器此文件应该被解析为一个模块。</p><p>但在 <code>Node</code> 中，是没有 <code>HTML</code> 标签的，所以需要其他的方式来辨别，社区目前的主流解决方式是修改文件的后缀为 <code>.mjs</code>，来告诉 <code>Node</code> 这将是一个模块。不过还没有标准化，而且还存在很多兼容问题。</p><p>到这里，在加载过程结束时，从普通的主入口文件变成了一堆模块记录<code>Module Record</code>。</p><p><img src="/img/d63b786d-9505-437c-b630-2b527c3a4f29.png"></p><p>下一步是实例化此模块并将所有实例链接在一起。</p><h2 id="3-实例化阶段"><a href="#3-实例化阶段" class="headerlink" title="3. 实例化阶段"></a>3. 实例化阶段</h2><p>就像我之前提到的，实例结合了代码和状态。该状态存在于内存中，因此实例化步骤就是写入内存。</p><p>首先，JS引擎创建一个模块环境记录来管理模块记录的变量。然后它在内存中找到所有导出内容对应的位置。模块环境记录将跟踪内存中导出内容对应的位置与导出内容间的联系。</p><p>此时内存中的这些位置中还不会存放值，只有在计算后才会有值。此规则有一个警告：此阶段初始化所有导出的函数声明。</p><p>为了实例化模块图，引擎将执行深度优先后序遍历。这意味着它将深入到图的底部——因为底部不依赖任何其他东西——并设置它们的导出。</p><p><img src="/img/5610b2fe-39bc-4075-a1c7-41bf49866135.png"></p><p>请注意，导出和导入都指向内存中的同一位置。首先连接导出可确保所有导入都可以连接到匹配的导出。</p><p>ES Modules 的这种连接方式被称为 Live Bindings（动态绑定）</p><p><img src="/img/de6ceb4e-725f-4242-b340-74da3ca2a413.png"></p><p>这与 CommonJS 模块不同。在 CommonJS 中，整个导出对象在导出时被复制。这意味着导出的任何值（如数字）都是副本。</p><p>这意味着如果导出模块稍后更改该值，则导入模块不会看到该更改。</p><p><img src="/img/0a98598b-f312-472d-9aff-54310d9566e4.png"></p><p>相反，ES 模块使用称为实时绑定的东西。两个模块都指向内存中的相同位置。这意味着当导出模块更改值时，该更改将显示在导入模块中。导出值的模块可以随时更改这些值，但导入模块不能更改其导入的值。话虽如此，如果一个模块导入一个对象，它可以更改该对象上的属性值。</p><p><img src="/img/640b4220-dea6-4ec4-b721-d49169e98c62.png"></p><p>拥有这样的实时绑定可以使我们在不运行任何代码的情况下连接所有模块。</p><p>所以在这一步结束时，我们已经连接了导出/导入变量的所有实例和内存位置。</p><h2 id="4-求值阶段（evaluate）"><a href="#4-求值阶段（evaluate）" class="headerlink" title="4. 求值阶段（evaluate）"></a>4. 求值阶段（evaluate）</h2><p>最后一步是在内存区中填充这些值。JS 引擎通过执行顶层代码（函数之外的代码）来实现这一点。</p><p>Evaluation代码还会引发副作用。例如，模块可能会调用服务器。</p><p><img src="/img/4252325b-d040-45d6-8ec2-b08950462119.png"></p><p>由于潜在的副作用，您只想Evaluation模块一次。与实例化中发生的链接相反，链接可以多次执行并获得完全相同的结果，Evaluation可能会产生不同的结果，具体取决于您执行的次数。</p><p>这是拥有模块映射（ module map）的原因之一。模块映射通过规范 URL 缓存模块，以便每个模块只有一个模块记录。这确保每个模块只执行一次。就像实例化一样，这是作为深度优先后序遍历完成的。</p><p>我们之前谈到的那些循环依赖周期呢？</p><p>在循环依赖中，最终会在图中出现一个循环。通常，这是一个长循环。但是为了解释这个问题，我将使用一个带有短循环的人为示例。</p><p><img src="/img/df4b9e49-e8d2-4bc0-8456-204397b8863f.png"></p><p>让我们看看这将如何与 CommonJS 模块一起工作。首先，主模块将执行到 require 语句。然后它会去加载计数器模块。</p><p><img src="/img/46895d57-225f-4c96-9bd3-d8765a8b7084.png"></p><p>然后计数器模块将尝试<code>message</code>从导出对象进行访问。但是由于这还没有在主模块中进行评估，这将返回 undefined。JS 引擎会在内存中为局部变量分配空间并将值设置为 undefined。</p><p><img src="/img/1faa028c-5e5c-4aca-b9bd-c30d162d3a2b.png"></p><p>评估一直持续到计数器模块的顶层代码结束。我们想看看我们最终是否会得到 message 的正确值（在 main.js 评估之后），所以我们设置了一个超时。然后评估在 上继续<code>main.js</code>。</p><p><img src="/img/ce4a8850-a200-4de9-9485-2b20592196d7.png"></p><p>消息变量将被初始化并添加到内存中。但由于两者之间没有联系，它将在所需的模块中保持undefined状态。</p><p><img src="/img/4f4fc69e-8b96-4549-ab24-7cf426822faa.png"></p><p>如果导出是使用实时绑定（live bindings）处理的，计数器模块最终会看到正确的值。到超时运行时，<code>main.js</code>的评估将完成并填充值。支持这些循环是 ES 模块设计背后的一个重要基本原理。</p><p>转自：<a href="https://www.jianshu.com/p/2023ba7d1747">https://www.jianshu.com/p/2023ba7d1747</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础篇：Linux常用命令总结</title>
    <link href="/2023/04/20/%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/20/%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="基础篇：Linux常用命令总结"><a href="#基础篇：Linux常用命令总结" class="headerlink" title="基础篇：Linux常用命令总结"></a>基础篇：Linux常用命令总结</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h1><h2 id="为什么要学习Linux命令？"><a href="#为什么要学习Linux命令？" class="headerlink" title="为什么要学习Linux命令？"></a><strong>为什么要学习Linux命令？</strong></h2><p>目前企业有超过80%甚至更多的系统都是Linux操作系统，所以不管是做开发还是运维，不会点Linux知识肯定是无法进入到企业里工作。而且，很多企业的岗位职责里写要需要精通Linux。Linux的从业方向也比较广，主要分为运维和开发，细分下来就数不胜数了，基本都会涉及，因此学好Linux刻不容缓。本文将列出我工作多年所学的Linux常用命令的汇总！超全面！超详细！包学包会！</p><h1 id="二、命令汇总"><a href="#二、命令汇总" class="headerlink" title="二、命令汇总"></a><strong>二、命令汇总</strong></h1><h2 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1. 文件管理"></a><strong>1. 文件管理</strong></h2><h3 id="【ls命令】–显示指定工作目录下的内容及属性信息"><a href="#【ls命令】–显示指定工作目录下的内容及属性信息" class="headerlink" title="【ls命令】–显示指定工作目录下的内容及属性信息"></a><strong>【ls命令】–显示指定工作目录下的内容及属性信息</strong></h3><p>ls命令为英文单词list的缩写，正如英文单词list的意思，其功能是列出指定目录下的内容及其相关属性信息。</p><p>默认状态下，ls命令会列出当前目录的内容。而带上参数后，我们可以用ls做更多的事情。作为最基础同时又是使用频率很高的命令，我们很有必要搞清楚ls命令的用法，那么接下来一起看看吧！</p><ul><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式:<span class="hljs-built_in">ls</span> [选项] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件及目录（包括以“.”开头的隐藏文件）</td></tr><tr><td>-l</td><td>使用长格式列出文件及目录信息</td></tr><tr><td>-r</td><td>将文件以相反次序显示（默认依英文字母次序）</td></tr><tr><td>-t</td><td>根据最后的修改时间排序</td></tr><tr><td>-A</td><td>同<code>-a</code>，但不列出“.”（当前目录）及“…”（父目录）</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-R</td><td>递归列出所有子目录</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li><p>列出所有文件(包括隐藏文件)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -a<br></code></pre></td></tr></table></figure></li><li><p>列出文件的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure></li><li><p>列出根目录(/)下的所有目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure></li><li><p>列出当前工作目录下所有名称是“s”开头的文件（不包含文件夹哦~）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -ltr s*<br></code></pre></td></tr></table></figure></li><li><p>列出/root目录下的所有目录及文件的详细信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR /root<br></code></pre></td></tr></table></figure></li><li><p>列出当前工作目录下所有文件及目录并以文件的大小进行排序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -AS<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【cp命令】–复制文件或目录"><a href="#【cp命令】–复制文件或目录" class="headerlink" title="【cp命令】–复制文件或目录"></a><strong>【cp命令】–复制文件或目录</strong></h3><p>cp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。</p><p>cp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">cp</span> [参数] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-f</td><td>若目标文件已存在，则会直接覆盖原文件</td></tr><tr><td>-i</td><td>若目标文件已存在，则会询问是否覆盖</td></tr><tr><td>-p</td><td>保留源文件或目录的所有属性</td></tr><tr><td>-r</td><td>递归复制文件和目录</td></tr><tr><td>-d</td><td>当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录</td></tr><tr><td>-l</td><td>对源文件建立硬连接，而非复制文件</td></tr><tr><td>-s</td><td>对源文件建立符号连接，而非复制文件</td></tr><tr><td>-b</td><td>覆盖已存在的文件目标前将目标文件备份</td></tr><tr><td>-v</td><td>详细显示<code>cp</code>命令执行的操作过程</td></tr><tr><td>-a</td><td>等价于“<code>dpr</code>”选项（<code>d</code>：复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；<code>p</code>：保留源文件或目录的所有属性；<code>r</code>：递归复制文件和目录）</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>复制目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -R dir1 dir2/<br></code></pre></td></tr></table></figure></li><li>将文件test1改名为test2：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -f test1 test2<br></code></pre></td></tr></table></figure></li><li>复制多个文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r file1 file2 file3 <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure></li><li>交互式地将目录/home/lucifer中的所有.c文件复制到目录dir中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r /home/lucifer/*.c <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【mkdir命令】–创建目录"><a href="#【mkdir命令】–创建目录" class="headerlink" title="【mkdir命令】–创建目录"></a><strong>【mkdir命令】–创建目录</strong></h3><p>mkdir命令是“make directories”的缩写，用来创建目录。</p><p>注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录。所以在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。mkdir命令还可以同时创建多个目录，是不是很强大呢？</p><ul><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式:<span class="hljs-built_in">mkdir</span> [参数] [目录]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>递归创建多级目录，例如<code>mkdir -p a/b/c</code>，若<code>a</code>、<code>b</code>目录不存在，会依次创建<code>a</code>、<code>a/b</code>、<code>a/b/c</code>目录</td></tr><tr><td>-m</td><td>建立目录的同时设置目录的权限，格式为三位八进制数字，如<code>mkdir -m 755 dir</code>，表示创建<code>dir</code>目录并设置权限为所有者可读可写可执行，所属组和其他用户可读可执行</td></tr><tr><td>-z</td><td>设置安全上下文，用于指定与安全相关的属性，不过在一般的日常使用场景中不太常用</td></tr><tr><td>-v</td><td>显示目录的创建过程，会输出创建目录的详细信息，如<code>mkdir -v dir</code>，会显示创建<code>dir</code>目录的操作信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>在工作目录下，建立一个名为dir的子目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure></li><li>在目录/home/lucifer下建立子目录dir，并且设置文件属主有读、写和执行权限，其他人无权访问：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -m 700 /home/lucifer/dir<br></code></pre></td></tr></table></figure></li><li>同时创建子目录dir1，dir2，dir3：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> dir1 dir2 dir3<br></code></pre></td></tr></table></figure></li><li>递归创建目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p lucifer/dir<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【mv命令】–移动或改名文件"><a href="#【mv命令】–移动或改名文件" class="headerlink" title="【mv命令】–移动或改名文件"></a><strong>【mv命令】–移动或改名文件</strong></h3><p>mv命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或对其改名。</p><p>这是一个使用频率超高的文件管理命令，我们需要特别留意它与复制的区别：mv与cp的结果不同。mv命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而cp命令是对文件进行复制操作，文件个数是有增加的。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">mv</span> [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>若存在同名文件，则向用户询问是否覆盖。例如，执行<code>mv file_1 file_2</code>时，如果<code>file_2</code>已存在，使用<code>-i</code>参数会提示用户是否覆盖<code>file_2</code>。</td></tr><tr><td>-f</td><td>覆盖已有文件时，不进行任何提示。比如执行<code>mv -f test.txt.bz2</code>，若目标位置有同名文件，会直接覆盖而不询问用户。</td></tr><tr><td>-b</td><td>当文件存在时，覆盖前为其创建一个备份。假设执行<code>mv -b file_3 file_4</code>，若<code>file_4</code>存在，会先备份<code>file_4</code>再进行覆盖操作。</td></tr><tr><td>-u</td><td>当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作。例如<code>mv -u source.txt destination.txt</code>，只有<code>source.txt</code>的修改时间比<code>destination.txt</code>新，或者<code>destination.txt</code>不存在时，才会移动<code>source.txt</code>到<code>destination.txt</code>。</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>将文件file_1重命名为file_2：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> file_1 file_2<br></code></pre></td></tr></table></figure></li><li>将文件file移动到目录dir中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> file /dir<br></code></pre></td></tr></table></figure></li><li>将目录dir1移动目录dir2中（前提是目录dir2已存在，若不存在则改名)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /dir1 /dir2<br></code></pre></td></tr></table></figure></li><li>将目录dir1下的文件移动到当前目录下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /dir1/*.<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【pwd命令】–显示当前路径"><a href="#【pwd命令】–显示当前路径" class="headerlink" title="【pwd命令】–显示当前路径"></a><strong>【pwd命令】–显示当前路径</strong></h3><p>pwd命令是“print working directory”中每个单词的首字母缩写，其功能正如所示单词一样，为打印工作目录，即显示当前工作目录的绝对路径。</p><p>在实际工作中，我们经常会在不同目录之间进行切换，为了防止“迷路”，我们可以使用pwd命令快速查看当前我们所在的目录路径。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式: <span class="hljs-built_in">pwd</span> [参数]<br></code></pre></td></tr></table></figure></li><li><p>常用参数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-L</td><td>显示逻辑路径</td></tr></tbody></table></li><li><p><strong>参考实例</strong>：</p><ul><li>查看当前工作目录路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-文档编辑"><a href="#2-文档编辑" class="headerlink" title="2. 文档编辑"></a><strong>2. 文档编辑</strong></h2><h3 id="【cat命令】–在终端设备上显示文件内容"><a href="#【cat命令】–在终端设备上显示文件内容" class="headerlink" title="【cat命令】–在终端设备上显示文件内容"></a><strong>【cat命令】–在终端设备上显示文件内容</strong></h3><p>cat这个命令也很好记，因为cat在英语中是“猫”的意思，小猫咪是不是给您一种娇小、可爱的感觉呢？</p><p>注意：当文件内容较大时，文本内容会在屏幕上快速闪动（滚屏），用户往往看不清所显示的具体内容。</p><p>因此对于较长文件内容可以：按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏；按Ctrl+C（中断）键则可以终止该命令的执行。</p><p>或者对于大文件，干脆用more命令吧！</p><ul><li><p><strong>语法</strong>：语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> [参数] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>显示行数（空行也编号）</td></tr><tr><td>-s</td><td>显示行数（多个空行算一个编号）</td></tr><tr><td>-b</td><td>显示行数（空行不编号）</td></tr><tr><td>-E</td><td>每行结束处显示$符号</td></tr><tr><td>-T</td><td>将TAB字符显示为^I符号</td></tr><tr><td>-v</td><td>使用^和M-引用，除了LFD和TAB之外</td></tr><tr><td>-e</td><td>等价于<code>-vE</code>组合</td></tr><tr><td>-t</td><td>等价于<code>-vT</code>组合</td></tr><tr><td>-A</td><td>等价于<code>-vET</code>组合</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>查看文件的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> lucifer.log<br></code></pre></td></tr></table></figure></li><li>查看文件的内容，并显示行数编号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -n lucifer.log<br></code></pre></td></tr></table></figure></li><li>查看文件的内容，并添加行数编号后输出到另外一个文件中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -n lucifer.log &gt; lucifer.txt<br></code></pre></td></tr></table></figure></li><li>清空文件的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /dev/null &gt; /root/lucifer.txt<br></code></pre></td></tr></table></figure></li><li>持续写入文件内容，碰到EOF符后结束并保存：</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt; lucifer.txt &lt;&lt;<span class="hljs-string">EOF </span><br><span class="hljs-string">Hello, World </span><br><span class="hljs-string">Linux! </span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><ul><li>将软盘设备制作成镜像文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /dev/fb0 &gt; fdisk.iso<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【echo命令】–输出字符串或提取Shell变量的值"><a href="#【echo命令】–输出字符串或提取Shell变量的值" class="headerlink" title="【echo命令】–输出字符串或提取Shell变量的值"></a><strong>【echo命令】–输出字符串或提取Shell变量的值</strong></h3><p>echo命令用于在终端设备上输出字符串或变量提取后的值，这是在Linux系统中最常用的几个命令之一，但操作却非常简单。</p><p>人们一般使用在变量前加上$符号的方式提取出变量的值，例如：PATH，然后再用echo命令予以输出。或者直接使用echo命令输出一段字符串到屏幕上，起到给用户提示的作用。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">echo</span> [参数] [字符串]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>不输出结尾的换行符</td></tr><tr><td>-e “\a”</td><td>发出警告音</td></tr><tr><td>-e “\b”</td><td>删除前面的一个字符</td></tr><tr><td>-e “\c”</td><td>结尾不加换行符</td></tr><tr><td>-e “\f”</td><td>换行，光标扔停留在原来的坐标位置</td></tr><tr><td>-e “\n”</td><td>换行，光标移至行首</td></tr><tr><td>-e “\r”</td><td>光标移至行首，但不换行</td></tr><tr><td>-E</td><td>禁止反斜杠转移，与-e参数功能相反</td></tr><tr><td>—version</td><td>查看版本信息</td></tr><tr><td>–help</td><td>查看帮助信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>输出一段字符串：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello Lucifer&quot;</span><br></code></pre></td></tr></table></figure></li><li>输出变量提取后的值：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li>对内容进行转义，不让$符号的提取变量值功能生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li>结合输出重定向符，将字符串信息导入文件中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;It is a test&quot;</span> &gt; lucifer<br></code></pre></td></tr></table></figure></li><li>使用反引号符执行命令，并输出其结果到终端：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">date</span>`<br></code></pre></td></tr></table></figure></li><li>输出带有换行符的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;a\nb\nc&quot;</span><br></code></pre></td></tr></table></figure></li><li>输出信息中删除某个字符，注意看数字3消失了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;123\b456&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【rm命令】–移除文件或目录"><a href="#【rm命令】–移除文件或目录" class="headerlink" title="【rm命令】–移除文件或目录"></a><strong>【rm命令】–移除文件或目录</strong></h3><p>rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。</p><p>注意：rm也是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。</p><p>所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">rm</span> [参数] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-f</td><td>忽略不存在的文件，不会出现警告信息</td></tr><tr><td>-i</td><td>删除前会询问用户是否操作</td></tr><tr><td>-r/R</td><td>递归删除</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>删除前逐一询问确认：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -i test.txt.bz2<br></code></pre></td></tr></table></figure></li><li>直接删除，不会有任何提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -f test.txt.bz2<br></code></pre></td></tr></table></figure></li><li>递归删除目录及目录下所有文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data/log <br><span class="hljs-built_in">rm</span> -rf /data/log<br></code></pre></td></tr></table></figure></li><li>删除当前目录下所有文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf *<br></code></pre></td></tr></table></figure></li><li>清空系统中所有的文件（谨慎）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /*<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【tail命令】–查看文件尾部内容"><a href="#【tail命令】–查看文件尾部内容" class="headerlink" title="【tail命令】–查看文件尾部内容"></a><strong>【tail命令】–查看文件尾部内容</strong></h3><p>tail用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">tail</span> [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–retry</td><td>在tail命令启动时，若文件不可访问或稍后变得不可访问，始终尝试打开文件（需与“——follow=name”连用）</td></tr><tr><td>-c或—bytes=</td><td>输出文件尾部的N（N为整数）个字节内容</td></tr><tr><td>-f&lt;name/descriptor&gt;</td><td>–follow：显示文件最新追加的内容</td></tr><tr><td>-F</td><td>与选项“-follow=name”和“–retry”连用时功能相同</td></tr><tr><td>-n或—line=</td><td>输出文件的尾部N（N位数字）行内容</td></tr><tr><td>–pid=&lt;进程号&gt;</td><td>与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令</td></tr><tr><td>–help</td><td>显示指令的帮助信息</td></tr><tr><td>–version</td><td>显示指令的版本信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示文件file的最后10行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> file<br></code></pre></td></tr></table></figure></li><li>显示文件file的内容，从第20行至文件末尾：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> +20 file<br></code></pre></td></tr></table></figure></li><li>显示文件file的最后10个字符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -c 10 file<br></code></pre></td></tr></table></figure></li><li>一直变化的文件总是显示后10行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f 10 file<br></code></pre></td></tr></table></figure></li><li>显示帮助信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【rmdir命令】–删除空目录"><a href="#【rmdir命令】–删除空目录" class="headerlink" title="【rmdir命令】–删除空目录"></a><strong>【rmdir命令】–删除空目录</strong></h3><p>rmdir命令作用是删除空的目录，英文全称：“remove directory”。</p><p>注意：rmdir命令只能删除空目录。当要删除非空目录时，就要使用带有“-R”选项的rm命令。</p><p>rmdir命令的“-p”参数可以递归删除指定的多级目录，但是要求每个目录也必须是空目录。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式: <span class="hljs-built_in">rmdir</span> [参数] [目录名称]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>用递归的方式删除指定的目录路径中的所有父级目录，非空则报错</td></tr><tr><td>–ignore-fail-on-non-empty</td><td>忽略由于删除非空目录时导致命令出错而产生的错误信息</td></tr><tr><td>-v</td><td>显示命令的详细执行过程</td></tr><tr><td>–help</td><td>显示命令的帮助信息</td></tr><tr><td>–version</td><td>显示命令的版本信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>删除空目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure></li><li>递归删除指定的目录树：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> -p <span class="hljs-built_in">dir</span>/dir_1/dir_2<br></code></pre></td></tr></table></figure></li><li>显示指令详细执行过程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> -v <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure></li><li>显示命令的版本信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> --version<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-系统管理"><a href="#3-系统管理" class="headerlink" title="3. 系统管理"></a>3. 系统管理</h2><h3 id="【rpm命令】–RPM软件包管理器"><a href="#【rpm命令】–RPM软件包管理器" class="headerlink" title="【rpm命令】–RPM软件包管理器"></a><strong>【rpm命令】–RPM软件包管理器</strong></h3><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：rpm [参数] [软件包]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>查询所有的软件包</td></tr><tr><td>-b或-t</td><td>设置包装套件的完成阶段，并指定套件档的文件名称</td></tr><tr><td>-c</td><td>只列出组态配置文件，需配合”-l”参数使用</td></tr><tr><td>-d</td><td>只列出文本文件，需配合”-l”参数使用</td></tr><tr><td>-e或–erase</td><td>卸载软件包</td></tr><tr><td>-f</td><td>查询文件或命令属于哪个软件包</td></tr><tr><td>-h或–hash</td><td>安装软件包时列出标记</td></tr><tr><td>-i</td><td>显示软件包的相关信息</td></tr><tr><td>–install</td><td>安装软件包</td></tr><tr><td>-l</td><td>显示软件包的文件列表</td></tr><tr><td>-p</td><td>查询指定的rpm软件包</td></tr><tr><td>-q</td><td>查询软件包</td></tr><tr><td>-R</td><td>显示软件包的依赖关系</td></tr><tr><td>-s</td><td>显示文件状态，需配合”-l”参数使用</td></tr><tr><td>-U或–upgrade</td><td>升级软件包</td></tr><tr><td>-v</td><td>显示命令执行过程</td></tr><tr><td>-vv</td><td>详细显示指令执行过程</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>直接安装软件包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh packge.rpm<br></code></pre></td></tr></table></figure></li><li>忽略报错，强制安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm --force -ivh package.rpm<br></code></pre></td></tr></table></figure></li><li>列出所有安装过的包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -qa<br></code></pre></td></tr></table></figure></li><li>查询rpm包中的文件安装的位置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ql <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li>卸载rpm包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -e package.rpm<br></code></pre></td></tr></table></figure></li><li>升级软件包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -U file.rpm<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【find命令】–查找和搜索文件"><a href="#【find命令】–查找和搜索文件" class="headerlink" title="【find命令】–查找和搜索文件"></a><strong>【find命令】–查找和搜索文件</strong></h3><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：find [参数] [路径] [查找和搜索范围]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-name</td><td>按名称查找</td></tr><tr><td>-size</td><td>按大小查找</td></tr><tr><td>-user</td><td>按属性查找</td></tr><tr><td>-type</td><td>按类型查找</td></tr><tr><td>-iname</td><td>忽略大小写</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>使用<code>name</code>参数查看<code>/etc</code>目录下面所有的<code>.conf</code>结尾的配置文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /etc -name <span class="hljs-string">&quot;*.conf&quot;</span><br></code></pre></td></tr></table></figure></li><li>使用<code>size</code>参数查看<code>/etc</code>目录下面大于1M的文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /etc -size +1M<br></code></pre></td></tr></table></figure></li><li>查找当前用户主目录下的所有文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find <span class="hljs-variable">$HOME</span> -<span class="hljs-built_in">print</span><br></code></pre></td></tr></table></figure></li><li>列出当前目录及子目录下所有文件和文件夹：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find .<br></code></pre></td></tr></table></figure></li><li>在<code>/home</code>目录下查找以<code>.txt</code>结尾的文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /home -name <span class="hljs-string">&quot;*.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li>在<code>/var/log</code>目录下忽略大小写查找以<code>.log</code>结尾的文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /var/log -iname <span class="hljs-string">&quot;*.log&quot;</span><br></code></pre></td></tr></table></figure></li><li>搜索超过七天内被访问过的所有文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -atime +7<br></code></pre></td></tr></table></figure></li><li>搜索访问时间超过10分钟的所有文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -amin +10<br></code></pre></td></tr></table></figure></li><li>找出<code>/home</code>下不是以<code>.txt</code>结尾的文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /home ! -name <span class="hljs-string">&quot;*.txt&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【startx命令】–初始化X-windows"><a href="#【startx命令】–初始化X-windows" class="headerlink" title="【startx命令】–初始化X-windows"></a><strong>【startx命令】–初始化X-windows</strong></h3><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：startx [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>指定在启动过程中传递给客户机的X服务器的显示名称</td></tr><tr><td>-m</td><td>当未找到启动脚本时，启动窗口管理器</td></tr><tr><td>-r</td><td>当未找到启动脚本时，装入资源文件</td></tr><tr><td>-w</td><td>强制启动</td></tr><tr><td>-x</td><td>使用startup脚本启动X-windows会话</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>已默认方式启动X-windows系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">startx<br></code></pre></td></tr></table></figure></li><li>以16位颜色深度启动X-windows系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">startx --depth 16<br></code></pre></td></tr></table></figure></li><li>强制启动X-windows系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">startx -w<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【uname命令】–显示系统信息"><a href="#【uname命令】–显示系统信息" class="headerlink" title="【uname命令】–显示系统信息"></a><strong>【uname命令】–显示系统信息</strong></h3><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">uname</span> [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示系统所有相关信息</td></tr><tr><td>-m</td><td>显示计算机硬件架构</td></tr><tr><td>-n</td><td>显示主机名称</td></tr><tr><td>-r</td><td>显示内核发行版本号</td></tr><tr><td>-s</td><td>显示内核名称</td></tr><tr><td>-v</td><td>显示内核版本</td></tr><tr><td>-p</td><td>显示主机处理器类型</td></tr><tr><td>-o</td><td>显示操作系统名称</td></tr><tr><td>-i</td><td>显示硬件平台</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示系统主机名、内核版本号、CPU类型等信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure></li><li>仅显示系统主机名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -n<br></code></pre></td></tr></table></figure></li><li>显示当前系统的内核版本:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure></li><li>显示当前系统的硬件架构：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -i<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【vmstat命令】–显示虚拟内存状态"><a href="#【vmstat命令】–显示虚拟内存状态" class="headerlink" title="【vmstat命令】–显示虚拟内存状态"></a><strong>【vmstat命令】–显示虚拟内存状态</strong></h3><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：vmstat [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示活动内页</td></tr><tr><td>-f</td><td>显示启动后创建的进程总数</td></tr><tr><td>-m</td><td>显示slab信息</td></tr><tr><td>-n</td><td>头信息仅显示一次</td></tr><tr><td>-s</td><td>以表格方式显示事件计数器和内存状态</td></tr><tr><td>-d</td><td>报告磁盘状态</td></tr><tr><td>-p</td><td>显示指定的硬盘分区状态</td></tr><tr><td>-S</td><td>输出信息的单位</td></tr><tr><td></td><td></td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示活动内页：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -a<br></code></pre></td></tr></table></figure></li><li>显示启动后创建的进程总数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -f<br></code></pre></td></tr></table></figure></li><li>显示slab信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -m<br></code></pre></td></tr></table></figure></li><li>头信息仅显示一次：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -n<br></code></pre></td></tr></table></figure></li><li>以表格方式显示事件计数器和内存状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -s<br></code></pre></td></tr></table></figure></li><li>显示指定的硬盘分区状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat -p /dev/sda1<br></code></pre></td></tr></table></figure></li><li>指定状态信息刷新的时间间隔为1秒：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat 1<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-磁盘管理"><a href="#4-磁盘管理" class="headerlink" title="4. 磁盘管理"></a><strong>4. 磁盘管理</strong></h2><h3 id="【df-命令】–显示磁盘空间使用情况"><a href="#【df-命令】–显示磁盘空间使用情况" class="headerlink" title="【df 命令】–显示磁盘空间使用情况"></a><strong>【df 命令】–显示磁盘空间使用情况</strong></h3><p>df 命令的英文全称即 “Disk Free”，用于显示系统上可使用的磁盘空间。默认显示单位为 KB，建议使用 “df -h” 的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。日常中普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">df</span> [参数] [指定文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示所有系统文件</td></tr><tr><td>-B&lt;块大小&gt;</td><td>指定显示时的块大小</td></tr><tr><td>-h</td><td>以容易阅读的方式显示</td></tr><tr><td>-H</td><td>以1000字节为换算单位来显示</td></tr><tr><td>-i</td><td>显示索引字节信息</td></tr><tr><td>-k</td><td>指定块大小为1KB</td></tr><tr><td>-l</td><td>只显示本地文件系统</td></tr><tr><td>-t&lt;文件系统类型&gt;</td><td>只显示指定类型的文件系统</td></tr><tr><td>-T</td><td>输出时显示文件系统类型</td></tr><tr><td>–sync</td><td>在取得磁盘使用信息前，先执行sync命令</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示磁盘分区使用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure></li><li>以容易阅读的方式显示磁盘分区使用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure></li><li>显示指定文件所在分区的磁盘使用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> /etc/dhcp<br></code></pre></td></tr></table></figure></li><li>显示文件类型为 ext4 的磁盘使用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -t ext4<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【fdisk-命令】–磁盘分区"><a href="#【fdisk-命令】–磁盘分区" class="headerlink" title="【fdisk 命令】–磁盘分区"></a><strong>【fdisk 命令】–磁盘分区</strong></h3><p>fdisk 命令的英文全称是 “Partition table manipulator for Linux”，即作为磁盘的分区工具。进行硬盘分区从实质上说就是对硬盘的一种格式化，用一个形象的比喻，分区就好比在一张白纸上画一个大方框，而格式化好比在方框里打上格子。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：fdisk [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-b</td><td>指定每个分区的大小</td></tr><tr><td>-l</td><td>列出指定的外围设备的分区表状况</td></tr><tr><td>-s</td><td>将指定的分区大小输出到标准输出上，单位为区块</td></tr><tr><td>-u</td><td>搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址</td></tr><tr><td>-v</td><td>显示版本信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>查看所有分区情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure></li><li>选择分区磁盘：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /dev/sdb<br></code></pre></td></tr></table></figure></li><li>在当前磁盘上建立扩展分区：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /ext<br></code></pre></td></tr></table></figure></li><li>不检查磁盘表面加快分区操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /actok<br></code></pre></td></tr></table></figure></li><li>重建主引导记录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /cmbr<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【lsblk-命令】–查看系统的磁盘"><a href="#【lsblk-命令】–查看系统的磁盘" class="headerlink" title="【lsblk 命令】–查看系统的磁盘"></a><strong>【lsblk 命令】–查看系统的磁盘</strong></h3><p>lsblk 命令的英文是 “list block”，用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出 RAM 盘的信息。lsblk 命令包含在 util-linux-ng 包中，现在该包改名为 util-linux。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：lsblk [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示所有设备</td></tr><tr><td>-b</td><td>以bytes方式显示设备大小</td></tr><tr><td>-d</td><td>不显示slaves或holders</td></tr><tr><td>-D</td><td>print discard capabilities</td></tr><tr><td>-e</td><td>排除设备</td></tr><tr><td>-f</td><td>显示文件系统信息</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-i</td><td>use ascii characters only</td></tr><tr><td>-m</td><td>显示权限信息</td></tr><tr><td>-l</td><td>使用列表格式显示</td></tr><tr><td>-n</td><td>不显示标题</td></tr><tr><td>-o</td><td>输出列</td></tr><tr><td>-P</td><td>使用key=”value”格式显示</td></tr><tr><td>-r</td><td>使用原始格式显示</td></tr><tr><td>-t</td><td>显示拓扑结构信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>lsblk 命令默认情况下将以树状列出所有块设备：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk<br></code></pre></td></tr></table></figure></li><li>默认选项不会列出所有空设备：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk -a<br></code></pre></td></tr></table></figure></li><li>也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk -m<br></code></pre></td></tr></table></figure></li><li>要获取 SCSI 设备的列表，只能使用 - S 选项，该选项是用来以颠倒的顺序打印依赖的：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk -S<br></code></pre></td></tr></table></figure></li><li>例如，想要以列表格式列出设备，而不是默认的树状格式。可以将两个不同的选项组合，以获得期望的输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk -<span class="hljs-built_in">nl</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【hdparm-命令】–显示与设定硬盘参数"><a href="#【hdparm-命令】–显示与设定硬盘参数" class="headerlink" title="【hdparm 命令】–显示与设定硬盘参数"></a><strong>【hdparm 命令】–显示与设定硬盘参数</strong></h3><p>hdparm 命令用于检测、显示与设定 IDE 或 SCSI 硬盘的参数。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：hdparm [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-a</td><td>设定读取文件时，预先存入块区的分区数</td></tr><tr><td>-f</td><td>将内存缓冲区的数据写入硬盘，并清空缓冲区</td></tr><tr><td>-g</td><td>显示硬盘的磁轨、磁头、磁区等参数</td></tr><tr><td>-I</td><td>直接读取硬盘所提供的硬件规格信息</td></tr><tr><td>-X</td><td>设定硬盘的传输模式</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示硬盘的相关设置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm /dev/sda<br></code></pre></td></tr></table></figure></li><li>显示硬盘的柱面、磁头、扇区数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm -g /dev/sda<br></code></pre></td></tr></table></figure></li><li>评估硬盘的读取效率：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm -t /dev/sda<br></code></pre></td></tr></table></figure></li><li>直接读取硬盘所提供的硬件规格信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm -X /dev/sda<br></code></pre></td></tr></table></figure></li><li>使 IDE 硬盘进入睡眠模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm -Y /dev/sda<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【vgextend-命令】–扩展卷组"><a href="#【vgextend-命令】–扩展卷组" class="headerlink" title="【vgextend 命令】–扩展卷组"></a><strong>【vgextend 命令】–扩展卷组</strong></h3><p>vgextend 命令用于动态扩展 LVM 卷组，它通过向卷组中添加物理卷来增加卷组的容量。LVM 卷组中的物理卷可以在使用 vgcreate 命令创建卷组时添加，也可以使用 vgextend 命令动态地添加。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：vgextend [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>调试模式</td></tr><tr><td>-t</td><td>仅测试</td></tr></tbody></table></li><li><p><strong>参考实例</strong>：</p><ul><li>将物理卷 /dev/sdb1 加入卷组 vglinuxprobe：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vgextend vglinuxprobe /dev/sdb1<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-文件传输"><a href="#5-文件传输" class="headerlink" title="5. 文件传输"></a><strong>5. 文件传输</strong></h2><h3 id="【tftp-命令】–上传及下载文件"><a href="#【tftp-命令】–上传及下载文件" class="headerlink" title="【tftp 命令】–上传及下载文件"></a><strong>【tftp 命令】–上传及下载文件</strong></h3><p>tftp 命令用于传输文件。ftp 让用户得以下载存放于远端主机的文件，也能将文件上传到远端主机放置。tftp 是简单的文字模式 ftp 程序，它所使用的指令和 ftp 类似。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：tftp [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>connect</td><td>连接到远程tftp服务器</td></tr><tr><td>mode</td><td>文件传输模式</td></tr><tr><td>put</td><td>上传文件</td></tr><tr><td>get</td><td>下载文件</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>verbose</td><td>显示详细的处理信息</td></tr><tr><td>trace</td><td>显示包路径</td></tr><tr><td>status</td><td>显示当前状态信息</td></tr><tr><td>binary</td><td>二进制传输模式</td></tr><tr><td>ascii ascii</td><td>传送模式</td></tr><tr><td>rexmt</td><td>设置包传输的超时时间</td></tr><tr><td>timeout</td><td>设置重传的超时时间</td></tr><tr><td>help</td><td>帮助信息</td></tr><tr><td>?</td><td>帮助信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>连接远程服务器”10.211.55.100″：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tftp 10.211.55.100<br></code></pre></td></tr></table></figure></li><li>远程下载 file 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tftp&gt; get file<br></code></pre></td></tr></table></figure></li><li>退出 tftp：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tftp&gt; quit<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【curl-命令】–文件传输工具"><a href="#【curl-命令】–文件传输工具" class="headerlink" title="【curl 命令】–文件传输工具"></a><strong>【curl 命令】–文件传输工具</strong></h3><p>curl 命令是一个利用 URL 规则在 shell 终端命令行下工作的文件传输工具；它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征；做网页处理流程和数据检索自动化。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：curl [参数] [网址]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-O</td><td>把输出写到该文件中，保留远程文件的文件名</td></tr><tr><td>-u</td><td>通过服务端配置的用户名和密码授权访问</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>将下载的数据写入到文件，必须使用文件的绝对地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl [https://www.baidu.com](https://www.baidu.com/) /root/lucifer.txt --silent -O<br></code></pre></td></tr></table></figure></li><li>访问需要授权的页面时，可通过 - u 选项提供用户名和密码进行授权：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u root https://www.baidu.com/<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【fsck-命令】–检查并修复-Linux-文件系统"><a href="#【fsck-命令】–检查并修复-Linux-文件系统" class="headerlink" title="【fsck 命令】–检查并修复 Linux 文件系统"></a><strong>【fsck 命令】–检查并修复 Linux 文件系统</strong></h3><p>fsck 命令的英文全称是 “filesystem check”，即检查文件系统的意思，常用于检查并修复 Linux 文件系统的一些错误信息，操作文件系统需要先备份重要数据，以防丢失。Linux fsck 命令用于检查并修复 Linux 文件系统，可以同时检查一个或多个 Linux 文件系统；若系统掉电或磁盘发生问题，可利用 fsck 命令对文件系统进行检查。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：fsck [参数] [文件系统]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>自动修复文件系统，不询问任何问题</td></tr><tr><td>-A</td><td>依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统</td></tr><tr><td>-N</td><td>不执行指令，仅列出实际执行会进行的动作</td></tr><tr><td>-P</td><td>当搭配”-A”参数使用时，则会同时检查所有的文件系统</td></tr><tr><td>-r</td><td>采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式</td></tr><tr><td>-R</td><td>当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查</td></tr><tr><td>-t</td><td>指定要检查的文件系统类型</td></tr><tr><td>-T</td><td>执行fsck指令时，不显示标题信息</td></tr><tr><td>-V</td><td>显示指令执行过程</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>修复坏的分区文件系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck -t ext3 -r /usr/local<br></code></pre></td></tr></table></figure></li><li>显示 fsck 系统安装的版本号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck --version<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【ftpwho-命令】–显示-ftp-会话信息"><a href="#【ftpwho-命令】–显示-ftp-会话信息" class="headerlink" title="【ftpwho 命令】–显示 ftp 会话信息"></a><strong>【ftpwho 命令】–显示 ftp 会话信息</strong></h3><p>ftpwho 命令用于显示当前所有以 FTP 登入的用户会话信息。执行该命令可得知当前用 FTP 登入系统的用户有哪些人，以及他们正在进行的操作。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：ftpwho [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-v</td><td>详细模式，输出更多信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>查询当前正在登录 FTP 服务器的用户：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ftpwho<br></code></pre></td></tr></table></figure></li><li>在详细模式下，查询当前正在登录 FTP 服务器的用户：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ftpwho -v<br></code></pre></td></tr></table></figure></li><li>显示帮助信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ftpwho -h<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【lprm-命令】–删除打印队列中的打印任务"><a href="#【lprm-命令】–删除打印队列中的打印任务" class="headerlink" title="【lprm 命令】–删除打印队列中的打印任务"></a><strong>【lprm 命令】–删除打印队列中的打印任务</strong></h3><p>lprm 命令的英文全称是 “Remove jobs from the print queue”，意为用于删除打印队列中的打印任务。尚未完成的打印机工作会被放在打印机贮列之中，这个命令可用来将未送到打印机的工作取消。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：lprm [参数] [任务编号]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-E</td><td>与打印服务器连接时强制使用加密</td></tr><tr><td>-P</td><td>指定接受打印任务的目标打印机</td></tr><tr><td>-U</td><td>指定可选的用户名</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>将打印机 hpprint 中的第 102 号任务移除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lprm -Phpprint 102<br></code></pre></td></tr></table></figure></li><li>将第 101 号任务由预设打印机中移除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lprm 101<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-网络通讯"><a href="#6-网络通讯" class="headerlink" title="6. 网络通讯"></a><strong>6. 网络通讯</strong></h2><h3 id="【ssh-命令】–安全连接客户端"><a href="#【ssh-命令】–安全连接客户端" class="headerlink" title="【ssh 命令】–安全连接客户端"></a><strong>【ssh 命令】–安全连接客户端</strong></h3><p>ssh 命令是 openssh 套件中的客户端连接工具，可以给予 ssh 加密协议实现安全的远程登录服务器，实现对服务器的远程管理。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式: ssh [参数] [远程主机]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-1</td><td>强制使用 ssh 协议版本 1</td></tr><tr><td>-2</td><td>强制使用 ssh 协议版本 2</td></tr><tr><td>-4</td><td>强制使用 IPv4 地址</td></tr><tr><td>-6</td><td>强制使用 IPv6 地址</td></tr><tr><td>-A</td><td>开启认证代理连接转发功能</td></tr><tr><td>-a</td><td>关闭认证代理连接转发功能</td></tr><tr><td>-b&lt;IP 地址&gt;</td><td>使用本机指定的地址作为对位连接的源 IP 地址</td></tr><tr><td>-C</td><td>请求压缩所有数据</td></tr><tr><td>-F &lt;配置文件&gt;</td><td>指定 ssh 指令的配置文件，默认的配置文件为 “/etc/ssh/ssh_config”</td></tr><tr><td>-f</td><td>后台执行 ssh 指令</td></tr><tr><td>-g</td><td>允许远程主机连接本机的转发端口</td></tr><tr><td>-i &lt;身份文件&gt;</td><td>指定身份文件（即私钥文件）</td></tr><tr><td>-l &lt;登录名&gt;</td><td>指定连接远程服务器的登录用户名</td></tr><tr><td>-N</td><td>不执行远程指令</td></tr><tr><td>-o &lt;选项&gt;</td><td>指定配置选项</td></tr><tr><td>-p &lt;端口&gt;</td><td>指定远程服务器上的端口</td></tr><tr><td>-q</td><td>静默模式，所有的警告和诊断信息被禁止输出</td></tr><tr><td>-X</td><td>开启 X11 转发功能</td></tr><tr><td>-x</td><td>关闭 X11 转发功能</td></tr><tr><td>-y</td><td>开启信任 X11 转发功能</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>登录远程服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 10.211.55.100<br></code></pre></td></tr></table></figure></li><li>用 test 用户连接远程服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -l <span class="hljs-built_in">test</span> 10.211.55.100<br></code></pre></td></tr></table></figure></li><li>查看分区列表：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 10.211.55.100 /sbin/fdisk -l<br></code></pre></td></tr></table></figure></li><li>强制使用 ssh 协议版本 1：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -1<br></code></pre></td></tr></table></figure></li><li>开启认证代理连接转发功能：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -A<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【netstat-命令】–显示网络状态"><a href="#【netstat-命令】–显示网络状态" class="headerlink" title="【netstat 命令】–显示网络状态"></a><strong>【netstat 命令】–显示网络状态</strong></h3><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p><p>从整体上看，netstat 的输出结果可以分为两个部分：一个是 Active Internet connections，称为有源 TCP 连接，其中”Recv-Q” 和”Send-Q” 指的是接收队列和发送队列。这些数字一般都应该是 0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到；另一个是 Active UNIX domain sockets，称为有源 Unix 域套接口 (和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：netstat [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>显示所有连线中的Socket</td></tr><tr><td>-p</td><td>显示正在使用Socket的程序识别码和程序名称</td></tr><tr><td>-u</td><td>显示UDP传输协议的连线状况</td></tr><tr><td>-i</td><td>显示网络界面信息表单</td></tr><tr><td>-n</td><td>直接使用IP地址，不通过域名服务器</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示详细的网络状况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -a<br></code></pre></td></tr></table></figure></li><li>显示当前户籍 UDP 连接状况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -nu<br></code></pre></td></tr></table></figure></li><li>显示 UDP 端口号的使用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -apu<br></code></pre></td></tr></table></figure></li><li>显示网卡列表：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -i<br></code></pre></td></tr></table></figure></li><li>显示组播组的关系：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -g<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【ping-命令】–测试主机间网络连通性"><a href="#【ping-命令】–测试主机间网络连通性" class="headerlink" title="【ping 命令】–测试主机间网络连通性"></a><strong>【ping 命令】–测试主机间网络连通性</strong></h3><p>ping 命令主要用来测试主机之间网络的连通性，也可以用于。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>不过值得注意的是：Linux 系统下的 ping 命令与 Windows 系统下的 ping 命令稍有不同。Windows 下运行 ping 命令一般会发出 4 个请求就结束运行该命令；而 Linux 下不会自动终止，此时需要按 CTR+C 终止或者使用 - c 参数为 ping 命令指定发送的请求数目。</p><ul><li><strong>语法</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：ping [参数] [目标主机]<br></code></pre></td></tr></table></figure><ul><li><strong>常用参数</strong><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>使用Socket的SO_DEBUG功能</td></tr><tr><td>-c</td><td>指定发送报文的次数</td></tr><tr><td>-i</td><td>指定收发信息的间隔时间</td></tr><tr><td>-I</td><td>使用指定的网络接口送出数据包</td></tr><tr><td>-l</td><td>设置在送出要求信息之前，先行发出的数据包</td></tr><tr><td>-n</td><td>只输出数值</td></tr><tr><td>-p</td><td>设置填满数据包的范本样式</td></tr><tr><td>-q</td><td>不显示指令执行过程</td></tr><tr><td>-R</td><td>记录路由过程</td></tr><tr><td>-s</td><td>设置数据包的大小</td></tr><tr><td>-t</td><td>设置存活数值TTL的大小</td></tr><tr><td>-v</td><td>详细显示指令的执行过程</td></tr></tbody></table></li><li><strong>参考实例</strong><ul><li>检测与百度网站的连通性：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping [www.baidu.com](https://www.baidu.com/)<br></code></pre></td></tr></table></figure></li><li>连续 ping4 次：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 4 [www.baidu.com](https://www.baidu.com/)<br></code></pre></td></tr></table></figure></li><li>设置次数为 4，时间间隔为 3 秒：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 4 -i 3 [www.baidu.com](https://www.baidu.com/)<br></code></pre></td></tr></table></figure></li><li>利用 ping 命令获取指定网站的 IP 地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 1 [baidu.com](https://baidu.com/) | grep from | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot; &quot;</span> -f 4<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【dhclient-命令】–动态获取或释放-IP-地址"><a href="#【dhclient-命令】–动态获取或释放-IP-地址" class="headerlink" title="【dhclient 命令】–动态获取或释放 IP 地址"></a><strong>【dhclient 命令】–动态获取或释放 IP 地址</strong></h3><p>dhclient 命令的作用是：使用动态主机配置协议动态地配置网络接口的网络参数，也支持 BOOTP 协议。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：dhclient [参数] [网络接口]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>指定dhcp客户端监听的端口号（默认端口号86）</td></tr><tr><td>-d</td><td>总是以前台方式运行程序</td></tr><tr><td>-q</td><td>安静模式，不打印任何错误的提示信息</td></tr><tr><td>-r</td><td>释放ip地址</td></tr><tr><td>-n</td><td>不配置任何接口</td></tr><tr><td>-x</td><td>停止正在运行的DHCP客户端，而不释放当前租约，杀死现有的dhclient</td></tr><tr><td>-s</td><td>在获取ip地址之前指定DHCP服务器</td></tr><tr><td>-w</td><td>即使没有找到广播接口，也继续运行</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>在指定网络接口上发出 DHCP 请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dhclient eth0<br></code></pre></td></tr></table></figure></li><li>释放 IP 地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dhclient -r<br></code></pre></td></tr></table></figure></li><li>从指定的服务器获取 ip 地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dhclient -s 10.211.55.100<br></code></pre></td></tr></table></figure></li><li>停止运行 dhclient：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dhclient -x<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【ifconfig命令】–显示或设置网络设备"><a href="#【ifconfig命令】–显示或设置网络设备" class="headerlink" title="【ifconfig命令】–显示或设置网络设备"></a>【ifconfig命令】–显示或设置网络设备</h3><p>ifconfig命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远地存到电脑里，那就要修改网卡的配置文件了。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：ifconfig [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>add&lt;地址&gt;</td><td>设置网络设备IPv6的IP地址</td></tr><tr><td>del&lt;地址&gt;</td><td>删除网络设备IPv6的IP地址</td></tr><tr><td>down</td><td>关闭指定的网络设备</td></tr><tr><td>up</td><td>启动指定的网络设备</td></tr><tr><td>IP地址</td><td>指定网络设备的IP地址</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示网络设备信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig<br></code></pre></td></tr></table></figure></li><li>启动关闭指定网卡：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 down<br>ifconfig eth0 up<br></code></pre></td></tr></table></figure></li><li>为网卡配置和删除IPv6地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 add 33ffe:3240:800:1005::2/64<br>ifconfig eth0 del 33ffe:3240:800:1005::2/64<br></code></pre></td></tr></table></figure></li><li>用ifconfig修改MAC地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 down<br>ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE<br>ifconfig eth0 up<br>ifconfig eth1 hw ether 00:1D:1C:1D:1E <br>ifconfig eth1 up<br><br></code></pre></td></tr></table></figure></li><li>配置IP地址：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 192.168.1.56 <br>ifconfig eth0 192.168.1.56 netmask 255.255.255.0<br>ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7. 设备管理"></a><strong>7. 设备管理</strong></h2><h3 id="【mount-命令】–文件系统挂载"><a href="#【mount-命令】–文件系统挂载" class="headerlink" title="【mount 命令】–文件系统挂载"></a><strong>【mount 命令】–文件系统挂载</strong></h3><p>mount 命令用于加载文件系统到指定的加载点。此命令的最常用于挂载 cdrom，使我们可以访问 cdrom 中的数据，因为将光盘插入 cdrom 中，Linux 并不会自动挂载，必须使用 Linux mount 命令来手动完成挂载。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：mount [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-t</td><td>指定挂载类型</td></tr><tr><td>-l</td><td>显示已加载的文件系统列表</td></tr><tr><td>-h</td><td>显示帮助信息并退出</td></tr><tr><td>-V</td><td>显示程序版本</td></tr><tr><td>-n</td><td>加载没有写入文件“/etc/mtab”中的文件系统</td></tr><tr><td>-r</td><td>将文件系统加载为只读模式</td></tr><tr><td>-a</td><td>加载文件“/etc/fstab”中描述的所有文件系统</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>查看版本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -V<br></code></pre></td></tr></table></figure></li><li>启动所有挂载：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -a<br></code></pre></td></tr></table></figure></li><li>挂载 /dev/cdrom 到 /mnt：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/cdrom/mnt<br></code></pre></td></tr></table></figure></li><li>挂载 nfs 格式文件系统：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -t nfs /123 /mnt<br></code></pre></td></tr></table></figure></li><li>挂载第一块盘的第一个分区到 /etc 目录 ：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -t ext4 -o loop,default /dev/sda1 /etc<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【MAKEDEV-命令】–建立设备"><a href="#【MAKEDEV-命令】–建立设备" class="headerlink" title="【MAKEDEV 命令】–建立设备"></a><strong>【MAKEDEV 命令】–建立设备</strong></h3><p>MAKEDEV 是一个脚本程序，用于在 /dev 目录下建立设备，通过这些设备文件可以访问位于内核的驱动程序。MAKEDEV 脚本创建静态的设备节点，通常位于 /dev 目录下。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：MAKEDEV [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-v</td><td>显示出执行的每一个动作</td></tr><tr><td>-n</td><td>并不做真正的更新，只是显示一下它的执行效果</td></tr><tr><td>-d</td><td>删除设备文件</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示出执行的每一个动作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./MAKEDEV -v update<br></code></pre></td></tr></table></figure></li><li>删除设备：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./MAKEDEV -d device<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【lspci-命令】–显示当前设备所有-PCI-总线信息"><a href="#【lspci-命令】–显示当前设备所有-PCI-总线信息" class="headerlink" title="【lspci 命令】–显示当前设备所有 PCI 总线信息"></a><strong>【lspci 命令】–显示当前设备所有 PCI 总线信息</strong></h3><p>lspci 命令用于显示当前主机的所有 PCI 总线信息，以及所有已连接的 PCI 设备信息。现在主流设备如网卡储存等都采用 PCI 总线。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：lspci [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>以数字方式显示PCI厂商和设备代码</td></tr><tr><td>-t</td><td>以树状结构显示PCI设备的层次关系</td></tr><tr><td>-b</td><td>以总线为中心的视图</td></tr><tr><td>-s</td><td>仅显示指定总线插槽的设备和功能块信息</td></tr><tr><td>-i</td><td>指定PCI编号列表文件，不使用默认文件</td></tr><tr><td>-m</td><td>以机器可读方式显示PCI设备信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示当前主机的所有 PCI 总线信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci<br></code></pre></td></tr></table></figure></li><li>以树状结构显示 PCI 设备的层次关系：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci -t<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【setleds-命令】–设定键盘上方三个-LED-的状态"><a href="#【setleds-命令】–设定键盘上方三个-LED-的状态" class="headerlink" title="【setleds 命令】–设定键盘上方三个 LED 的状态"></a><strong>【setleds 命令】–设定键盘上方三个 LED 的状态</strong></h3><p>setleds 即是英文词组 “set leds” 的合并，翻译为中文就是设置 LED 灯。setleds 命令用来设定键盘上方三个 LED 灯的状态。在 Linux 中，每一个虚拟主控台都有独立的设定。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：setleds [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-F</td><td>设定虚拟主控台的状态</td></tr><tr><td>-D</td><td>改变虚拟主控台的状态和预设的状态</td></tr><tr><td>-L</td><td>直接改变 LED 显示的状态</td></tr><tr><td>+num/-num</td><td>将数字键打开或关闭</td></tr><tr><td>+caps/-caps</td><td>把大小写键打开或关闭</td></tr><tr><td>+scroll /-scroll</td><td>把选项键打开或关闭</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>控制键盘灯 num 灯亮和灯灭：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">setleds +num <br>setleds -num <br></code></pre></td></tr></table></figure></li><li>控制键盘的大小写键打开或关闭，键盘指示灯亮与灭：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">setleds +caps <br>setleds -caps <br></code></pre></td></tr></table></figure></li><li>控制键盘的选项键打开或关闭，键盘指示灯亮与灭：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">setleds +scroll<br></code></pre></td></tr></table></figure></li><li>对三灯的亮与灭的情况进行组合，分别设置为数字灯亮，大小写灯灭，选项键 scroll 灯灭：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">setleds +num -caps -scroll<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【sensors-命令】–检测服务器内部温度及电压"><a href="#【sensors-命令】–检测服务器内部温度及电压" class="headerlink" title="【sensors 命令】–检测服务器内部温度及电压"></a><strong>【sensors 命令】–检测服务器内部温度及电压</strong></h3><p>sensors 命令用于检测服务器内部降温系统是否健康，可以监控主板，CPU 的工作电压，风扇转速、温度等数据 。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：sensors<br></code></pre></td></tr></table></figure></li><li><p><strong>参考实例</strong>：</p><ul><li>检测 cpu 工作电压，温度等：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sensors<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="8-备份压缩"><a href="#8-备份压缩" class="headerlink" title="8.备份压缩"></a><strong>8.备份压缩</strong></h2><h3 id="【zip-命令】–压缩文件"><a href="#【zip-命令】–压缩文件" class="headerlink" title="【zip 命令】–压缩文件"></a><strong>【zip 命令】–压缩文件</strong></h3><p>zip 程序将一个或多个压缩文件与有关文件的信息（名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性）一起放入一个压缩存档中。可以使用一个命令将整个目录结构打包到 zip 存档中。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：zip [参数] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-q</td><td>不显示指令执行过程</td></tr><tr><td>-r</td><td>递归处理，将指定目录下的所有文件和子目录一并处理</td></tr><tr><td>-z</td><td>替压缩文件加上注释</td></tr><tr><td>-v</td><td>显示指令执行过程或显示版本信息</td></tr><tr><td>-n&lt;字尾字符串&gt;</td><td>不压缩具有特定字尾字符串的文件</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -q -r html.zip/home/html<br></code></pre></td></tr></table></figure></li><li>压缩文件 cp.zip 中删除文件 a.c：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -dv cp.zip a.c<br></code></pre></td></tr></table></figure></li><li>把 /home 目录下面的 mydata 目录压缩为 mydata.zip：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -r mydata.zip mydata<br></code></pre></td></tr></table></figure></li><li>把 /home 目录下面的 abc 文件夹和 123.txt 压缩成为 abc123.zip：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -r abc123.zip abc 123.txt<br></code></pre></td></tr></table></figure></li><li>将 logs 目录打包成 log.zip：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -r log.zip./logs<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【zipinfo-命令】–查看压缩文件信息"><a href="#【zipinfo-命令】–查看压缩文件信息" class="headerlink" title="【zipinfo 命令】–查看压缩文件信息"></a><strong>【zipinfo 命令】–查看压缩文件信息</strong></h3><p>zipinfo 命令的全称为 “zip information”，该命令用于列出压缩文件信息。执行 zipinfo 指令可得知 zip 压缩文件的详细信息。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：zipinfo [参数] [压缩文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-1</td><td>只列出文件名称</td></tr><tr><td>-2</td><td>此参数的效果和指定”-1″参数类似，但可搭配”-h”,”-t”和”-z”参数使用</td></tr><tr><td>-h</td><td>只列出压缩文件的文件名称</td></tr><tr><td>-l</td><td>此参数的效果和指定”-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率</td></tr><tr><td>-m</td><td>此参数的效果和指定”-s”参数类似，但多会列出每个文件的压缩率</td></tr><tr><td>-M</td><td>若信息内容超过一个画面，则采用类似more指令的方式列出信息</td></tr><tr><td>-s</td><td>用类似执行”ls -l”指令的效果列出压缩文件内容</td></tr><tr><td>-t</td><td>只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率</td></tr><tr><td>-T</td><td>将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出</td></tr><tr><td>-v</td><td>详细显示压缩文件内每一个文件的信息</td></tr><tr><td>-x&lt;范本样式&gt;</td><td>不列出符合条件的文件的信息</td></tr><tr><td>-z</td><td>如果压缩文件内含有注释，就将注释显示出来</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示压缩文件信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipinfo file.zip<br></code></pre></td></tr></table></figure></li><li>显示压缩文件中每个文件的信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipinfo -v file.zip<br></code></pre></td></tr></table></figure></li><li>只显示压缩包大小、文件数目：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipinfo -h file.zip<br></code></pre></td></tr></table></figure></li><li>生成一个基本的、长格式的列表 (而不是冗长的)，包括标题和总计行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipinfo -l file<br></code></pre></td></tr></table></figure></li><li>查看存档中最近修改的文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipinfo -T file | <span class="hljs-built_in">sort</span> –nr -k 7 | sed 15q<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【unzip-命令】–解压缩-zip-文件"><a href="#【unzip-命令】–解压缩-zip-文件" class="headerlink" title="【unzip 命令】–解压缩 zip 文件"></a><strong>【unzip 命令】–解压缩 zip 文件</strong></h3><p>unzip 命令是用于.zip 格式文件的解压缩工具 ，unzip 命令将列出、测试或从 zip 格式存档中提取文件，这些文件通常位于 MS-DOS 系统上。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：unzip [参数] [文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-l</td><td>显示压缩文件内所包含的文件</td></tr><tr><td>-v</td><td>执行时显示详细的信息</td></tr><tr><td>-c</td><td>将解压缩的结果显示到屏幕上，并对字符做适当的转换</td></tr><tr><td>-n</td><td>解压缩时不要覆盖原有的文件</td></tr><tr><td>-j</td><td>不处理压缩文件中原有的目录路径</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>把 /home 目录下面的 mydata.zip 解压到 mydatabak 目录里面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip mydata.zip -d mydatabak<br></code></pre></td></tr></table></figure></li><li>把 /home 目录下面的 wwwroot.zip 直接解压到 /home 目录里面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip wwwroot.zip<br></code></pre></td></tr></table></figure></li><li>把 /home 目录下面的 abc12.zip、abc23.zip、abc34.zip 同时解压到 /home 目录里面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip abc*.zip<br></code></pre></td></tr></table></figure></li><li>查看把 /home 目录下面的 wwwroot.zip 里面的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -v wwwroot.zip<br></code></pre></td></tr></table></figure></li><li>验证 /home 目录下面的 wwwroot.zip 是否完整：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -t wwwroot.zip<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【gzip-命令】–压缩和解压文件"><a href="#【gzip-命令】–压缩和解压文件" class="headerlink" title="【gzip 命令】–压缩和解压文件"></a><strong>【gzip 命令】–压缩和解压文件</strong></h3><p>gzip 命令的英文是 “GNUzip”，是常用来压缩文件的工具，gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处 “.gz” 扩展名。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：gzip [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>使用ASCII文字模式</td></tr><tr><td>-d</td><td>解开压缩文件</td></tr><tr><td>-f</td><td>强行压缩文件</td></tr><tr><td>-l</td><td>列出压缩文件的相关信息</td></tr><tr><td>-c</td><td>把压缩后的文件输出到标准输出设备，不去更动原始文件</td></tr><tr><td>-r</td><td>递归处理，将指定目录下的所有文件及子目录一并处理</td></tr><tr><td>-q</td><td>不显示警告信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>把 rancher-v2.2.0 目录下的每个文件压缩成.gz 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip *<br></code></pre></td></tr></table></figure></li><li>把上例中每个压缩的文件解压，并列出详细的信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip -dv *<br></code></pre></td></tr></table></figure></li><li>递归地解压目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip -dr rancher.gz<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【unarj-命令】–解压-arj-文件"><a href="#【unarj-命令】–解压-arj-文件" class="headerlink" title="【unarj 命令】–解压.arj 文件"></a><strong>【unarj 命令】–解压.arj 文件</strong></h3><p>unarj 命令用于解压缩.arj 文件。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：unarj [参数] [.arj 压缩文件]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>解压缩.arj文件</td></tr><tr><td>-l</td><td>显示压缩文件内所包含的文件</td></tr><tr><td>-t</td><td>检查压缩文件是否正确</td></tr><tr><td>-x</td><td>解压缩时保留原有的路径</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>解压缩.arj 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unarj -e test.arj<br></code></pre></td></tr></table></figure></li><li>显示压缩文件内所包含的文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unarj -l test.arj<br></code></pre></td></tr></table></figure></li><li>检查压缩文件是否正确：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unarj -t test.arj<br></code></pre></td></tr></table></figure></li><li>解压缩时保留原有的路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unarj -x test.arj<br></code></pre></td></tr></table></figure></li><li>把文件解压到当前路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unarj -ex test.arj<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="9-其他命令"><a href="#9-其他命令" class="headerlink" title="9. 其他命令"></a><strong>9. 其他命令</strong></h2><h3 id="【hash-命令】–显示与清除命令运行时查询的哈希表"><a href="#【hash-命令】–显示与清除命令运行时查询的哈希表" class="headerlink" title="【hash 命令】–显示与清除命令运行时查询的哈希表"></a><strong>【hash 命令】–显示与清除命令运行时查询的哈希表</strong></h3><p>hash 命令负责显示与清除命令运行时系统优先查询的哈希表（hash table）。当执行 hash 命令不指定参数或标志时，hash 命令向标准输出报告路径名列表的内容。此报告含有先前 hash 命令调用找到的当前 shell 环境中命令的路径名，而且还包含通过正常命令搜索进程调用并找到的那些命令。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式: <span class="hljs-built_in">hash</span> [参数] [目录]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>在哈希表中清除记录</td></tr><tr><td>-l</td><td>显示哈希表中的命令</td></tr><tr><td>-p&lt;指令&gt;</td><td>将具有完整路径的命令加入到哈希表中</td></tr><tr><td>-r</td><td>清除哈希表中的记录</td></tr><tr><td>-t</td><td>显示哈希表中命令的完整路径</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示哈希表中的命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> -l<br></code></pre></td></tr></table></figure></li><li>删除哈希表中的命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> -r<br></code></pre></td></tr></table></figure></li><li>向哈希表中添加命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> -p /usr/sbin/adduser myadduser<br></code></pre></td></tr></table></figure></li><li>在哈希表中清除记录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> -d<br></code></pre></td></tr></table></figure></li><li>显示哈希表中命令的完整路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span> -t<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【grep-命令】–强大的文本搜索工具"><a href="#【grep-命令】–强大的文本搜索工具" class="headerlink" title="【grep 命令】–强大的文本搜索工具"></a><strong>【grep 命令】–强大的文本搜索工具</strong></h3><p>grep 是 “global search regular expression and print out the line” 的简称，意思是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，它也是 linux 使用最为广泛的命令。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：grep [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>搜索时，忽略大小写</td></tr><tr><td>-c</td><td>只输出匹配行的数量</td></tr><tr><td>-l</td><td>只列出符合匹配的文件名，不列出具体的匹配行</td></tr><tr><td>-n</td><td>列出所有的匹配行，显示行号</td></tr><tr><td>-h</td><td>查询多文件时不显示文件名</td></tr><tr><td>-s</td><td>不显示不存在、没有匹配文本的错误信息</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-w</td><td>匹配整词</td></tr><tr><td>-x</td><td>匹配整行</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-q</td><td>禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td>-b</td><td>打印匹配行距文件头部的偏移量，以字节为单位</td></tr><tr><td>-o</td><td>与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>支持多文件查询并支持使用通配符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep zwx file_* /etc/hosts<br></code></pre></td></tr></table></figure></li><li>输出匹配字符串行的数量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -c zwx file_*<br></code></pre></td></tr></table></figure></li><li>列出所有的匹配行，并显示行号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n zwx file_*<br></code></pre></td></tr></table></figure></li><li>显示不包含模式的所有行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -vc zwx file_*<br></code></pre></td></tr></table></figure></li><li>不再显示文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -h zwx file_*<br></code></pre></td></tr></table></figure></li><li>只列出符合匹配的文件名，不列出具体匹配的行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -l zwx file_*<br></code></pre></td></tr></table></figure></li><li>不显示不存在或无匹配的文本信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -s zwx file1 file_1<br>grep zwx file1 file_1<br></code></pre></td></tr></table></figure></li><li>递归搜索，不仅搜索当前目录，还搜索子目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r zwx file_2 *<br></code></pre></td></tr></table></figure></li><li>匹配整词，以字面意思去解释他，相当于精确匹配：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep zw* file_1；<br>grep -w zw* file_1<br></code></pre></td></tr></table></figure></li><li>匹配整行，文件中的整行与模式匹配时，才打印出来：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -x zwx file_*<br></code></pre></td></tr></table></figure></li><li>不输出任何结果，已退出状态表示结果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -q zwx file_1<br><span class="hljs-built_in">echo</span> $?<br>grep -q zwx file_5<br><span class="hljs-built_in">echo</span> $?<br>grep -q zwx file5<br><span class="hljs-built_in">echo</span> $?<br><br></code></pre></td></tr></table></figure></li><li>查找一个文件中的空行和非空行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -c ^$ file_1<br>grep -c ^[^$] file_1<br></code></pre></td></tr></table></figure></li><li>匹配任意或重复字符用 “.” 或 “<em>” 符号来实现：</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep ^z.x file_1<br>grep ^z* file_6<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【wait-命令】–等待指令"><a href="#【wait-命令】–等待指令" class="headerlink" title="【wait 命令】–等待指令"></a><strong>【wait 命令】–等待指令</strong></h3><p>wait 命令用来等待指令的指令，直到其执行完毕后返回终端。该指令常用于 shell 脚本编程中，待指定的指令执行完成后，才会继续执行后面的任务。该指令等待作业时，在作业标识号前必须添加备份号”%”。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：<span class="hljs-built_in">wait</span> [参数]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>22或%1</td><td>进程号或作业号</td></tr></tbody></table></li><li><p><strong>参考实例</strong>：</p><ul><li>等待作业号为 1 的作业完成后再返回：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wait</span> %1；find /-name password<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【bc-命令】–浮点运算"><a href="#【bc-命令】–浮点运算" class="headerlink" title="【bc 命令】–浮点运算"></a><strong>【bc 命令】–浮点运算</strong></h3><p>bc 的英文全拼为 “Binary Calculator”，是一种支持任意精度的交互执行的计算器语言。bash 内置了对整数四则运算的支持，但是并不支持浮点运算，而 bc 命令可以很方便的进行浮点运算，当然整数运算也不再话下。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式：bc [选项]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-i</td><td>强制进入交互式模式</td></tr><tr><td>-l</td><td>定义使用的标准数学库</td></tr><tr><td>-w</td><td>定义使用的标准数学库</td></tr><tr><td>-q</td><td>打印正常的 GNU bc 环境信息</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>算术操作高级运算 bc 命令它可以执行浮点运算和一些高级函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1.212*3&quot;</span> | bc<br></code></pre></td></tr></table></figure></li><li>设定小数精度（数值范围）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2;3/8&quot;</span> | bc<br></code></pre></td></tr></table></figure></li><li>计算平方和平方根：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10^10&quot;</span> | bc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sqrt (100)&quot;</span> | bc<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="【history-命令】–显示与操纵历史命令"><a href="#【history-命令】–显示与操纵历史命令" class="headerlink" title="【history 命令】–显示与操纵历史命令"></a><strong>【history 命令】–显示与操纵历史命令</strong></h3><p>history 命令用于显示用户以前执行过的历史命令，并且能对历史命令进行追加和删除等操作。</p><ul><li><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法格式: <span class="hljs-built_in">history</span> [参数] [目录]<br></code></pre></td></tr></table></figure></li><li><p><strong>常用参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-a</td><td>将当前 shell 会话的历史命令追加到命令历史文件中，命令历史文件是保存历史命令的配置文件</td></tr><tr><td>-c</td><td>清空当前历史命令列表</td></tr><tr><td>-d</td><td>删除历史命令列表中指定序号的命令</td></tr><tr><td>-n</td><td>从命令历史文件中读取本次 Shell 会话开始时没有读取的历史命令</td></tr><tr><td>-r</td><td>读取命令历史文件到当前的 Shell 历史命令内存缓冲区</td></tr><tr><td>-s</td><td>将指定的命令作为单独的条目加入命令历史内存缓冲区。在执行添加之前先删除命令历史内存缓冲区中最后一条命令</td></tr><tr><td>-w</td><td>把当前的 shell 历史命令内存缓冲区的内容写入命令历史文件</td></tr></tbody></table></li><li><p><strong>参考实例</strong></p><ul><li>显示最近的 10 条命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> 10<br></code></pre></td></tr></table></figure></li><li>将本次登录的命令写入历史文件中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> -w<br></code></pre></td></tr></table></figure></li><li>将命令历史文件中的内容读入到目前 shell 的 history 记忆中 ：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> -r<br></code></pre></td></tr></table></figure></li><li>将当前 Shell 会话的历史命令追加到命令历史文件中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> -a<br></code></pre></td></tr></table></figure></li><li>清空当前历史命令列表：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> -c<br></code></pre></td></tr></table></figure></li></ul><p>  转自：<a href="https://blog.csdn.net/m0_50546016/article/details/119984255">https://blog.csdn.net/m0_50546016/article/details/119984255</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带你学会AST语法树</title>
    <link href="/2023/03/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AAST%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    <url>/2023/03/20/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AAST%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h1><h2 id="一、AST语法树"><a href="#一、AST语法树" class="headerlink" title="一、AST语法树"></a>一、AST语法树</h2><p>AST全称Abstract Syntax Tree，也就是我们说的语法树，它是一棵用分支和节点的组合来描述代码结构的JSON树形结构。</p><p>AST是现代化前端基础和工程化的基石，尤其是现在开发框架中的构造工具中，都离不开AST技术，</p><p>AST的用途其实请多的，下面简单列举几个</p><ul><li>IDE的错误提示、代码格式化、代码高亮、代码自动补全等</li><li>JSLint、JSHint对代码错误或风格的检查等</li><li>webpack、rollup进行代码打包等</li><li>CoffeeScript、TypeScript、JSX等转化为原生Javascript</li><li>vue模板编译、react模板编译</li></ul><h3 id="1-AST是如何生成的"><a href="#1-AST是如何生成的" class="headerlink" title="1. AST是如何生成的"></a>1. AST是如何生成的</h3><ul><li><p>第一步：源代码</p></li><li><p>第二步：tokenizer（词法分析）</p><p><em>通过一个叫做tokenizer（token生成器，也叫lexer）的工具将源代码分解成一个个 token。</em></p><p><em>token是描述编程语言语法的对象。它可以描述数字，标识符，标点符号，运算符等等。</em></p></li><li><p>第三步：分词结果 - [{token}, {token}, {token}]</p></li><li><p>第四步：语法分析</p><p><em>接收词素并将它们组合成一个描述了源代码各部分之间关系的中间表达形式：抽象语法树。</em></p></li><li><p>第五步：AST 语法树</p></li></ul><p>JS常用的生成的AST的工具有：<a href="https://link.segmentfault.com/?enc=A5CXRGaj1S4PwP34tErORg==.06w42otDX1mMOU4sQGqVDh3hdGeLZ5gWqWYfwbRUg823TtkOV818uKfM5276/Wfy">esprima</a>、<a href="https://link.segmentfault.com/?enc=M7cYHYEeRuJrEGZ2vEwt4Q==.ikqgURAXjfKIrbaZswVxwNQIiUwBg4Zar/n25b+zOTKteoNAJpOVlVAJsiKlw6Z6">uglifyJS2、</a><a href="https://link.segmentfault.com/?enc=rLxtJbg+T/0C2bqqqod0pw==.8G69qWDBST3zi0tWnabx2owLKR4nDGpvIViNQQ3+jE43cPtXb1AgtRYYcLxNzeeD">traceur、</a><a href="https://link.segmentfault.com/?enc=79lHV7PC6BI+SiA+x1f9qg==.f83TsPve7c6cC26UBklFQUn/XmT+eh4UkEo+WCY+YsKkvOcjQETuy+b4Xm5exyGy">acorn、</a><a href="https://link.segmentfault.com/?enc=DWB7bqZv6OZ5WzQNySV2yw==.zTSYTQGLG+Qk+xoPNavApRZFH2zBWAUTGV1e8f6trslvoqFBSp9We4McYcVN+jeA">espree、</a><a href="https://link.segmentfault.com/?enc=B387WVBw69NnaS9bBgckqg==.3Il06gFMYSda83pIPGOgEjLEq6haCc47BEclX24z+YhI4eg+ipE/aqABArTq6REEzC6SerBFrXaBumoSA6ZnSKU8YpeXlybUNOQDhP0c3/k=">@babel/parser</a></p><p>在线生成AST的工具有：<a href="https://link.zhihu.com/?target=https://astexplorer.net/">AST explorer</a> 和 <a href="https://link.segmentfault.com/?enc=K9mGbY7Tpy32YS5UZCY44g==.BqUVl+uz3SsYmF3KTOeuKWzMW6Dy4gMQHmLJRLCINFqy+BG3ttl4qFNwt2Ejrueg">Esprima</a></p><p>我们看下面一个例子来感受下这个过程：</p><p>代码<code>var myBlog = &#39;Vito&#39;;</code></p><p>词法分析结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Keyword&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;var&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myBlog&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Punctuator&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;=&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;String&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#x27;Vito&#x27;&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Punctuator&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>语法分析结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Program&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VariableDeclaration&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;declarations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VariableDeclarator&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myBlog&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;init&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Literal&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Vito&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;raw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#x27;Vito&#x27;&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;var&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;script&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-探索AST节点类型"><a href="#2-探索AST节点类型" class="headerlink" title="2. 探索AST节点类型"></a>2. <strong>探索AST节点类型</strong></h3><p><img src="/img/ast1.webp"></p><p>看了规则后瞬间明白ast的json中那些看不懂的type是个什么玩意了(详细可对照<a href="https://link.juejin.cn/?target=https://babeljs.io/docs/en/babel-types">babel-types</a><br>），真的就是描述语法的词汇罢了！</p><h2 id="二、AST-的遍历"><a href="#二、AST-的遍历" class="headerlink" title="二、AST 的遍历"></a>二、<strong><strong>AST 的遍历</strong></strong></h2><p>当我们运用AST来做一些事情时，大致都要经历以下操作：</p><ul><li>parse，得到AST。</li><li>遍历AST，找到log节点。</li><li>获取console.log调用表达式的所有参数。</li><li>对不同类型的节点做针对处理。</li><li>替换log节点的参数。</li><li>生成代码</li></ul><p>所以遍历是我们的必须操作，所以我们重点看遍历的部分就好了：</p><h3 id="1-AST-的遍历思路"><a href="#1-AST-的遍历思路" class="headerlink" title="1. AST 的遍历思路"></a>1. <strong><strong>AST 的遍历思路</strong></strong></h3><p>AST的遍历本质是对树的遍历，树的遍历有两种：深度优先和广度优先，而对于AST的遍历只能是深度优先。</p><p>比如 <code>a + b</code>这个 <code>BinaryExpression</code>，需要遍历 <code>left</code>、<code>right</code> 属性</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Program&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ExpressionStatement&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;expression&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BinaryExpression&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;+&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;script&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>再比如 <code>if (a === 1) &#123;&#125;</code>这个 **<code>IfStatement</code>**，需要遍历 <code>test</code>、<code>consequece</code> 属性：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Program&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IfStatement&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BinaryExpression&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;===&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Literal&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;raw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;consequent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BlockStatement&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alternate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;script&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样，我们记录下每种 AST 怎么遍历，然后从根结点开始递归的遍历就可以了，例如这样：</p><p><img src="/img/ast2.png"></p><p>因为是每种 AST 访问那些 key，所以叫做 visitorKeys。</p><p>遍历每种 AST 的时候，就从 visitorKeys 里面找，看看要遍历哪些属性，之后取出来递归遍历就行了。</p><p>当然，思路虽然只有一种，但还是有一些变形的：</p><p>变形一：把递归变成循环，因为 AST 如果过深，那递归层次就过深，可能栈溢出，所以可以用一个数组（作为栈）来代替对象，来记录接下来要遍历 AST，这样就可以变成数组的循环了。（react fiber 也是把递归变循环）</p><p>变形二：可以不把 visitorKeys 提出来，而是直接在代码里写死，这样虽然不如提出来更容易扩展，但是做一些针对部分 AST 的逻辑变更还是比较方便的。</p><h3 id="2-各种编译工具的-AST-遍历的实现"><a href="#2-各种编译工具的-AST-遍历的实现" class="headerlink" title="2. 各种编译工具的 AST 遍历的实现"></a>2. <strong><strong>各种编译工具的 AST 遍历的实现</strong></strong></h3><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a><strong>eslint</strong></h3><p>eslint 的 遍历过程比较标准，我们先来看下这个：</p><p><img src="/img/ast3.png"></p><p>就是对每种 AST 都从 visitorKeys 中拿到遍历的属性 keys，然后递归遍历每个 key 的值就行了，数组的话还要循环遍历每个元素。</p><p>和我们上面理清的思路一毛一样。</p><p>而且，在遍历之前可以调用 enter 回调函数，在遍历之后可以调用 exit 回调函数。</p><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a><strong>babel</strong></h3><p>babel 也是一样的思路，通过 visitorKeys 记录每种 AST 怎么遍历，然后遍历的时候取出对应的 keys 来递归访问：</p><p><img src="/img/ast4.png"></p><p>babel 分为了两个方法，没啥实质区别，而且也有 enter 和 exit 两个阶段的回调。</p><h2 id="estraverse"><a href="#estraverse" class="headerlink" title="estraverse"></a><strong>estraverse</strong></h2><p>estraverse 是专门用于遍历 AST 的库，一般和 esprima 的 parser 配合。它的 AST 遍历和上面两个不太一样，就是把递归变成了循环。</p><p><img src="/img/ast5.png"></p><p>看到我标出来的地方了么，和上面的是一样的，只不过这里不是递归了，而是把要遍历的 AST 放入数组，之后继续循环。</p><p>递归改循环的思路都是这样，加个数组（作为栈）记录路径就可以了。</p><h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a><strong>typescript</strong></h2><p>typescript 的遍历和上面的也不太一样，它没有抽离出 visitorKeys 的数据，而是写死在代码里对什么 AST 访问什么属性：</p><p><img src="/img/ast6.png"></p><p>这种方式比较命令式，要把所有 AST 枚举一遍，而上面那种把 visitorKeys 抽离出来的方式是声明式的思想，逻辑可以复用。不知道为什么 ts 是这样写遍历逻辑的，可能好处就是可以对某一些遍历逻辑做修改吧。</p><h2 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a><strong>postcss</strong></h2><p>postcss 也稍微有点不同，它的所有 key 都是可遍历的，也就不需要 visitorKeys ，直接遍历所有的 key 就行。</p><p><img src="/img/ast7.png"></p><p>而且 postcss 的 node 是有方法的，通过面向对象的方式来组织遍历的过程。</p><p>写法上有点区别，但遍历的思路没有变。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、<strong>总结</strong></h2><p>前端领域的编译工具有挺多的，它们都是基于 AST，而操作 AST 就需要遍历来查找。</p><p>eslint、babel、estraverse、postcss、typescript compiler 这些编译工具的遍历 AST 的实现我们都过了一遍，虽然有的用递归、有的用循环，有的是面向对象、有的是函数，有的是抽离 visitorKeys、有的是写死在代码里，但思路都是一样的。</p><p>所以，我们来正式的下个结论：<code>编译工具的遍历实现思路只有一种，就是找到每种 AST 的可遍历的 keys，深度优先的遍历。</code></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九种跨域方式实现原理（完整版）</title>
    <link href="/2023/03/17/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"/>
    <url>/2023/03/17/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="九种跨域方式实现原理（完整版）"><a href="#九种跨域方式实现原理（完整版）" class="headerlink" title="九种跨域方式实现原理（完整版）"></a>九种跨域方式实现原理（完整版）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。</p><h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="/img/cross1.awebp"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h3 id="2-常见跨域场景"><a href="#2-常见跨域场景" class="headerlink" title="2.常见跨域场景"></a>2.常见跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p><p><img src="/img/cross2.awebp"></p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h3 id="1-JSONP原理"><a href="#1-JSONP原理" class="headerlink" title="1) JSONP原理"></a>1) JSONP原理</h3><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><h3 id="2-JSONP和AJAX对比"><a href="#2-JSONP和AJAX对比" class="headerlink" title="2) JSONP和AJAX对比"></a>2) JSONP和AJAX对比</h3><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p><h3 id="3-JSONP优缺点"><a href="#3-JSONP优缺点" class="headerlink" title="3) JSONP优缺点"></a>3) JSONP优缺点</h3><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p><h3 id="4-JSONP的实现流程"><a href="#4-JSONP的实现流程" class="headerlink" title="4) JSONP的实现流程"></a>4) JSONP的实现流程</h3><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    <span class="hljs-variable language_">window</span>[callback] = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(data)<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script)<br>    &#125;<br>    params = &#123; ...params, callback &#125; <span class="hljs-comment">// wd=b&amp;callback=show</span><br>    <span class="hljs-keyword">let</span> arrs = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      arrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)<br>    &#125;<br>    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/say&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">&#x27;Iloveyou&#x27;</span> &#125;,<br>  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/say&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.<span class="hljs-property">query</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wd) <span class="hljs-comment">// Iloveyou</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(callback) <span class="hljs-comment">// show</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>)<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)复制代码<br></code></pre></td></tr></table></figure><h3 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h3><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">$.ajax(<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">url:</span><span class="hljs-string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,<br><span class="hljs-symbol">dataType:</span><span class="hljs-string">&quot;jsonp&quot;</span>,<br><span class="hljs-symbol">type:</span><span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-comment">//可以省略</span><br><span class="hljs-symbol">jsonpCallback:</span><span class="hljs-string">&quot;show&quot;</span>,<span class="hljs-comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="hljs-symbol">jsonp:</span><span class="hljs-string">&quot;callback&quot;</span>,<span class="hljs-comment">//-&gt;把传递函数名的那个形参callback，可省略</span><br><span class="hljs-symbol">success:</span>function (data)<span class="hljs-punctuation">&#123;</span><br>console.log(data)<span class="hljs-punctuation">;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span>复制代码<br></code></pre></td></tr></table></figure><h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h3 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h3><p>只要同时满足以下两大条件，就属于简单请求</p><p>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><h3 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h3><p>不符合以上条件的请求就肯定是复杂请求了。<br>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-comment">// 允许哪个方法访问我</span><br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)<br><span class="hljs-comment">// 预检的存活时间</span><br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">// OPTIONS请求不做任何处理</span><br><span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>  res.<span class="hljs-keyword">end</span>()<br>&#125;<br><span class="hljs-comment">// 定义后台返回的内容</span><br>app.put(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(req.headers)<br>  res.<span class="hljs-keyword">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// index.html</span><br>let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>document.cookie = <span class="hljs-string">&#x27;name=xiamen&#x27;</span> <span class="hljs-comment">// cookie不能跨域</span><br>xhr.withCredentials = <span class="hljs-literal">true</span> <span class="hljs-comment">// 前端设置是否带cookie</span><br>xhr.open(<span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="hljs-literal">true</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;xiamen&#x27;</span>)<br>xhr.onreadystatechange = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) || xhr.status === <span class="hljs-number">304</span>) &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(xhr.response)<br>      <span class="hljs-comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span><br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(xhr.getResponseHeader(<span class="hljs-string">&#x27;name&#x27;</span>))<br>    &#125;<br>  &#125;<br>&#125;<br>xhr.send()复制代码<br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">//server1.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = express();<br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(__dirname));<br>app.listen(<span class="hljs-number">3000</span>);复制代码<br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">//server2.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = express()<br><span class="hljs-keyword">let</span> whitList = [<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>] <span class="hljs-comment">//设置白名单</span><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> origin = req.headers.origin<br>  <span class="hljs-keyword">if</span> (whitList.includes(origin)) &#123;<br>    <span class="hljs-comment">// 设置哪个源可以访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)<br>    <span class="hljs-comment">// 允许携带哪个头访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-comment">// 允许哪个方法访问我</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)<br>    <span class="hljs-comment">// 允许携带cookie</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-keyword">true</span>)<br>    <span class="hljs-comment">// 预检的存活时间</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)<br>    <span class="hljs-comment">// 允许返回的头</span><br>    res.setHeader(<span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>      res.end() <span class="hljs-comment">// OPTIONS请求不做任何处理</span><br>    &#125;<br>  &#125;<br>  next()<br>&#125;)<br>app.put(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>&#123;<br>  console.log(req.headers)<br>  res.setHeader(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jw&#x27;</span>) <span class="hljs-comment">//返回一个响应头，后台需设置</span><br>  res.end(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>&#123;<br>  console.log(req.headers)<br>  res.end(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(__dirname))<br>app.listen(<span class="hljs-number">4000</span>)复制代码<br></code></pre></td></tr></table></figure><p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><blockquote><p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">// a.html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/b.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //等它加载完触发一个事件<br>  //内嵌在http://localhost:3000/a.html<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> frame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;frame&#x27;</span>)</span><br><span class="language-javascript">        frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>) <span class="hljs-comment">//发送数据</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123; <span class="hljs-comment">//接受返回数据</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//我不爱你</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// b.html</span><br>  window<span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>    console<span class="hljs-selector-class">.log</span>(e.data) <span class="hljs-comment">//我爱你</span><br>    e<span class="hljs-selector-class">.source</span><span class="hljs-selector-class">.postMessage</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>, e.origin)<br> &#125;复制代码<br></code></pre></td></tr></table></figure><h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">// socket.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);</span><br><span class="language-javascript">    socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>);<span class="hljs-comment">//向服务器发送数据</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<span class="hljs-comment">//接收服务器返回的数据</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);<span class="hljs-comment">//记得安装ws</span><br><span class="hljs-keyword">let</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>&#125;);<br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">ws</span>) &#123;<br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>  &#125;);<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong><br>代理服务器，需要做以下几个步骤：</p><ul><li><p>接受客户端请求 。</p></li><li><p>将请求 转发给服务器。</p></li><li><p>拿到服务器 响应 数据。</p></li><li><p>将 响应 转发给客户端。</p></li></ul><p><img src="/img/cross3.awebp"></p><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// index.html(http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">5500</span>)<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      $.<span class="hljs-title function_">ajax</span>(</span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">        url: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="language-xquery">        type: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="language-xquery">        data: &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;xiamen&#x27;</span>, password: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;</span><span class="language-xml"><span class="language-javascript">,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">          console.log(result) // &#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;fontend&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;123456&quot;</span>&#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">          console.log(msg)</span><br><span class="language-xquery">        &#125;</span><span class="language-xml"></span><br><span class="language-xml">      &#125;)</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// server1.js 代理服务器(http://localhost:3000)</span><br>const http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 第一步：接受客户端请求</span><br>const server = http<span class="hljs-selector-class">.createServer</span>((request, response) =&gt; &#123;<br>  <span class="hljs-comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br>  response<span class="hljs-selector-class">.writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="hljs-string">&#x27;Content-Type&#x27;</span><br>  &#125;)<br>  <span class="hljs-comment">// 第二步：将请求转发给服务器</span><br>  const proxyRequest = http<br>    <span class="hljs-selector-class">.request</span>(<br>      &#123;<br>        host: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        port: <span class="hljs-number">4000</span>,<br>        url: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        method: request<span class="hljs-selector-class">.method</span>,<br>        headers: request<span class="hljs-selector-class">.headers</span><br>      &#125;,<br>      serverResponse =&gt; &#123;<br>        <span class="hljs-comment">// 第三步：收到服务器的响应</span><br>        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">body</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        serverResponse<span class="hljs-selector-class">.on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, chunk =&gt; &#123;<br>          <span class="hljs-selector-tag">body</span> += chunk<br>        &#125;)<br>        serverResponse<span class="hljs-selector-class">.on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, () =&gt; &#123;<br>          console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;The data is &#x27;</span> + body)<br>          <span class="hljs-comment">// 第四步：将响应结果转发给浏览器</span><br>          response<span class="hljs-selector-class">.end</span>(body)<br>        &#125;)<br>      &#125;<br>    )<br>    <span class="hljs-selector-class">.end</span>()<br>&#125;)<br>server<span class="hljs-selector-class">.listen</span>(<span class="hljs-number">3000</span>, () =&gt; &#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;The proxyServer is running at http://localhost:3000&#x27;</span>)<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server2.js(http://localhost:4000)</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;fontend&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>  &#125;<br>&#125;)<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The server is running at http://localhost:4000&#x27;</span>)<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>先下载<a href="https://link.juejin.cn/?target=http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// proxy服务器</span><br><span class="hljs-keyword">server</span> &#123;<br>    listen       <span class="hljs-number">81</span>;<br>    server_name  www.domain1.com;<br>    location / &#123;<br>        proxy_pass   http:<span class="hljs-comment">//www.domain2.com:8080;  #反向代理</span><br>        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="hljs-meta">#修改cookie里域名</span><br>        <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;<br><br>        <span class="hljs-meta"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br>        add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br>        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// index.html</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span><br>xhr.withCredentials = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 访问nginx中的代理服务器</span><br>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.send();复制代码<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<br><span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> params = qs.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 向前台写cookie</span><br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="hljs-comment">// HttpOnly:脚本无法读取</span><br>    &#125;);<br>    res.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params));<br>    res.<span class="hljs-title function_">end</span>();<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);复制代码<br></code></pre></td></tr></table></figure><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">// a.html(http://localhost:3000/b.html)<br> <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span></span><br><span class="language-javascript">   <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">     <span class="hljs-keyword">if</span>(first)&#123;</span><br><span class="language-javascript">     <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">       iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="language-javascript">       first = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">     &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">     <span class="hljs-comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="language-javascript">       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>);</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// c.html(http://localhost:4000/c.html)<br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;我不爱你&#x27;</span></span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash + iframe"></a>8.location.hash + iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。<br>同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">// a.html<br> <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//检测hash的变化</span></span><br><span class="language-javascript">     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// b.html</span><br> &lt;script&gt;<br>   window<span class="hljs-selector-class">.parent</span><span class="hljs-selector-class">.parent</span><span class="hljs-selector-class">.location</span><span class="hljs-selector-class">.hash</span> = location<span class="hljs-selector-class">.hash</span><br>   <span class="hljs-comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span><br> &lt;/script&gt;复制代码<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// c.html</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);<br> <span class="hljs-keyword">let</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br> iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;<br> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);复制代码<br></code></pre></td></tr></table></figure><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。<br>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">// a.html<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> helloa<br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">a</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">// b.html<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   hellob<br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><br><span class="language-javascript">     <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;</span><br><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ul><p>转载自：<a href="https://juejin.cn/post/6844903767226351623">https://juejin.cn/post/6844903767226351623</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会使用for-in与for-of</title>
    <link href="/2023/03/15/%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8for-in%E4%B8%8Efor-of/"/>
    <url>/2023/03/15/%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8for-in%E4%B8%8Efor-of/</url>
    
    <content type="html"><![CDATA[<h1 id="学会使用for-in-与-for-of"><a href="#学会使用for-in-与-for-of" class="headerlink" title="学会使用for-in 与 for-of"></a>学会使用for-in 与 for-of</h1><h2 id="一、初步认识"><a href="#一、初步认识" class="headerlink" title="一、初步认识"></a>一、初步认识</h2><p>我们通过下面例子先感受下<code>for-in</code>和<code>for-of</code>的遍历特点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><br><span class="hljs-comment">// for in 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    <span class="hljs-comment">// 0</span><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-comment">// for of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    <span class="hljs-comment">// a</span><br>    <span class="hljs-comment">// b</span><br>    <span class="hljs-comment">// c</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现<code>for-in</code>在遍历数组时候返回的是<strong>数组的序号</strong>，而<code>for-of</code>遍历的是<strong>数组的值</strong>。接着我们看下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-comment">// 手动给 arr数组添加一个属性</span><br>arr.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;vito&#x27;</span><br>arr.<span class="hljs-property">__proto__</span>.<span class="hljs-property">age</span> = <span class="hljs-number">24</span><br><br><span class="hljs-comment">// for in 循环可以遍历出 name 这个键名</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    <span class="hljs-comment">// 0</span><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">// name</span><br><span class="hljs-comment">// age</span><br>&#125;<br><span class="hljs-comment">// for in 循环不会遍历新增name这个键名</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  <span class="hljs-comment">// a</span><br>  <span class="hljs-comment">// b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现<code>for-in</code> 不仅会遍历出数组自身属性还会遍历出其原型上的属性，而<code>for-of</code>不会遍历出自身属性，通过这个例子我们我们至少可以得出<code>for-of</code>更适合遍历数组，当我们吧目标换成对象时，看下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> obj = &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>obj.<span class="hljs-property">d</span> = <span class="hljs-number">4</span><br>obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;vito&#x27;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    <span class="hljs-comment">// a</span><br>    <span class="hljs-comment">// b</span><br>    <span class="hljs-comment">// c</span><br><span class="hljs-comment">//d</span><br><span class="hljs-comment">// name</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> obj) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    <span class="hljs-comment">// Uncaught TypeError: obj is not iterable 报错了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现<code>for-in</code>无论是遍历数组还是对象<strong>都会遍历到原型的属性</strong>，而且<code>for-of</code>不支持遍历对象，所以我们得出一下结论：</p><ul><li><code>for-in</code> 会遍历目标的原型对象那个的属性，并且<code>for-in</code>更适合遍历对象，至于原型的属性我们可以过滤</li><li><code>for-of</code>不支持遍历对象，但可以遍历数组，而且不会像<code>for-in</code>那样遍历原型属性。</li></ul><p>下面我们详细的了解下各自的特点：</p><h3 id="for-in-特点"><a href="#for-in-特点" class="headerlink" title="for-in 特点"></a><code>for-in</code> 特点</h3><ul><li>返回的值都是数据结构的<strong>键值名，</strong>所以遍历对象返回的<strong>对象的key值，</strong>遍历数组返回的**数组的下标(**key)。</li><li>会遍历<strong>所有可枚举属性</strong>包括原型上和手动添加的其他键</li><li>遍历顺序可能不是实际的内部顺序</li><li>索引是<strong>字符串型的数字</strong>，因而不能直接进行几何运算</li><li>可以通过<code>break</code>和<code>continue</code>配合使用<strong>（不能用<code>return</code>）</strong></li></ul><h3 id="for-of-特点"><a href="#for-of-特点" class="headerlink" title="for-of 特点"></a><code>for-of</code> 特点</h3><ul><li>遍历返回的值是<strong>键值对中的值</strong></li><li><strong>提供了遍历所有数据结构的统一接口</strong></li><li>遍历顺序是有序的固定的。</li><li>部署iterator接口可以使用for-of 遍历</li><li>可以与 <code>break</code>、<code>continue</code>和<code>return</code> 配合使用</li></ul><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><table><thead><tr><th></th><th>for-in</th><th>for-of</th></tr></thead><tbody><tr><td>遍历结果</td><td>键值的名字</td><td>键值的值</td></tr><tr><td>是否会遍历原型属性</td><td>是</td><td>否</td></tr><tr><td>遍历是否按顺序</td><td>否</td><td>是</td></tr><tr><td>适合遍历的数据类型</td><td>对象</td><td>数组</td></tr><tr><td>循环的中断方式</td><td>break、continue</td><td>break、continue、return</td></tr></tbody></table><h2 id="三、疑问解答"><a href="#三、疑问解答" class="headerlink" title="三、疑问解答"></a>三、疑问解答</h2><h3 id="问题一：既然说for-in更适合遍历对象，但是他还是会遍历原型链上的可枚举属性，这个问题如何解决？"><a href="#问题一：既然说for-in更适合遍历对象，但是他还是会遍历原型链上的可枚举属性，这个问题如何解决？" class="headerlink" title="问题一：既然说for-in更适合遍历对象，但是他还是会遍历原型链上的可枚举属性，这个问题如何解决？"></a>问题一：<strong>既然说for-in更适合遍历对象，但是他还是会遍历原型链上的可枚举属性，这个问题如何解决？</strong></h3><p>答：通过使用<code>hasOwnProperty</code> 方法将这些属性过滤掉，该方法会忽略掉那些从原型链上继承到的属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span>=<span class="hljs-string">&quot;cgl&quot;</span>;<br>    <span class="hljs-keyword">var</span> person =&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiaoming&#x27;</span><br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>        <span class="hljs-keyword">if</span>(person.<span class="hljs-title function_">hasOwnProperty</span>(key))&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<span class="hljs-comment">//name age</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="问题二：什么是可枚举类型，在平时通过for-in遍历对象时一定要加hasOwnProperty过滤属性嘛吗？"><a href="#问题二：什么是可枚举类型，在平时通过for-in遍历对象时一定要加hasOwnProperty过滤属性嘛吗？" class="headerlink" title="问题二：什么是可枚举类型，在平时通过for-in遍历对象时一定要加hasOwnProperty过滤属性嘛吗？"></a>问题二：什么是可枚举类型，在平时通过for-in遍历对象时一定要加<code>hasOwnProperty</code>过滤属性嘛吗？</h3><p>答：① 可枚举属性是指那些内部 <code>enumerable: true</code>的属性，对于通过<strong>直接的赋值和属性初始化的属性</strong>，该标识值默认为即为 <code>true</code>，通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><strong>Object.defineProperty</strong></a>等定义的属性，该标识值默认为 <code>false</code>。</p><p>② 如果是简单对象，其实可以不用加<code>hasOwnProperty</code> 属性，因为基本包装类型（Object, Array, Number等）的原型属性都是不可枚举的，但是如果是比较复杂的类型，<strong>有在原型手动加一些属性和方法，这些属性和方法默认是可枚举的</strong>，所以就会有坑，就必须用<code>hasOwnProperty</code> 过滤下。</p><h3 id="问题三：for-of除了数组类型，还支持遍历哪些？"><a href="#问题三：for-of除了数组类型，还支持遍历哪些？" class="headerlink" title="问题三：for-of除了数组类型，还支持遍历哪些？"></a>问题三：<code>for-of</code>除了数组类型，还支持遍历哪些？</h3><p><strong>答：</strong> Array、Map、Set、String、arguments对象、Nodelist对象（获取的dom列表集合）以上这些都可以直接使用 for of 循环。 </p><h3 id="问题四：如何理解“for-of提供了遍历所有数据结构的统一接口”"><a href="#问题四：如何理解“for-of提供了遍历所有数据结构的统一接口”" class="headerlink" title="问题四：如何理解“for-of提供了遍历所有数据结构的统一接口”?"></a>问题四：如何理解“<code>for-of</code><strong>提供了遍历所有数据结构的统一接口</strong>”?</h3><p>答：一个数据结构<strong>只要部署了</strong> <code>Symbol.iterator</code><strong>属性</strong>, 就被视为具有 <code>iterator</code>接口, 就可以使用 <code>for-of</code>循环。</p><h3 id="问题五：-for-of遍历对象报错obj-is-not-iterable，请问如何解决？"><a href="#问题五：-for-of遍历对象报错obj-is-not-iterable，请问如何解决？" class="headerlink" title="问题五：**for-of遍历对象报错obj is not iterable，请问如何解决？**"></a>问题五：**<code>for-of</code>遍历对象报错<code>obj is not iterable</code>，请问如何解决？**</h3><ul><li>方法一：用<code>for-in</code>遍历</li><li>方法二：**<strong>使用 Object.keys() 获取对象的 key值的数组后,再使用 <code>for-of</code></strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  <span class="hljs-comment">// a</span><br>  <span class="hljs-comment">// b</span><br>  <span class="hljs-comment">// c</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法三：给对象部署 Symbol.iterator属性</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">//方法一</span><br><br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( self )<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>( index &lt; keys.<span class="hljs-property">length</span> )&#123;<br>                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: self[keys[index++]], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>方法二：obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>* ()&#123;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( <span class="hljs-variable language_">this</span> )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>[keys[i]]<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-comment">// 2</span><br>  <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见CSS布局方案总结</title>
    <link href="/2023/03/12/%E5%B8%B8%E8%A7%81CSS%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/12/%E5%B8%B8%E8%A7%81CSS%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常见CSS布局方案总结"><a href="#常见CSS布局方案总结" class="headerlink" title="常见CSS布局方案总结"></a>常见CSS布局方案总结</h1><h2 id="一、水平居中方案"><a href="#一、水平居中方案" class="headerlink" title="一、水平居中方案"></a>一、水平居中方案</h2><h3 id="思路一：利用text-align-center"><a href="#思路一：利用text-align-center" class="headerlink" title="思路一：利用text-align:center"></a>思路一：利用<code>text-align:center</code></h3><p><strong>原理：</strong>声明<code>text-align:center</code>可以使得子元素的<strong>内联元素</strong>水平居中。</p><p><strong>条件：</strong>将子元素都设置为内联元素即可生效，如果子元素不是内联元素需要我们设置display为<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>inline-flex</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">text-align</span>:center<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline; // 值还可以为 inline-block 、inline-<span class="hljs-selector-tag">table</span> 、inline-<span class="hljs-attribute">flex</span>、inline-<span class="hljs-attribute">grid</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路二：利用margin：0-auto"><a href="#思路二：利用margin：0-auto" class="headerlink" title="思路二：利用margin：0 auto"></a>思路二：利用<code>margin：0 auto</code></h3><p><strong>原理：</strong>利用CSS的盒模型和外边距的特性，当一个块级元素左右外边距都设置为auto，浏览器会自动计算出左右外边距的值，使得水平方向居中。</p><ul><li><p>方式一：在元素定宽的情况下，<code>margin：0 auto</code>可以生效</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>//无<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：不需要元素定宽，只是让元素处于<code>FFC (flex formatting context)</code> ，或者 <code>GFC (grid formatting context)</code> 中，也就是父元素display属性取<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code>，<code>margin：0 auto</code>可以生效</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex; // 值还可以为inline-<span class="hljs-attribute">flex</span>、<span class="hljs-attribute">grid</span>、inline-<span class="hljs-attribute">grid</span><br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="思路三：绝对定位"><a href="#思路三：绝对定位" class="headerlink" title="思路三：绝对定位"></a>思路三：绝对定位</h3><p><strong>原理：</strong>通过绝对定位将元素脱离文档流，利用left将元素定位到距离父元素左边界-50%地方，然后通过修正自身宽度的偏移使得水平方向居中。</p><ul><li><p>方式一：绝对定位 +<code>left:50%</code>+ <code>margin-left:-50% * 元素宽度</code></p><p>  条件：子元素必须定宽度</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：绝对定位 + <code>left:50%</code>+ <code>transform:translateX(-50%);</code></p><p>  条件：适用于所有场景，不需要元素定宽度</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="思路四：flex布局"><a href="#思路四：flex布局" class="headerlink" title="思路四：flex布局"></a><strong>思路四：flex布局</strong></h3><p>原理：利用<code>FFC (flex formatting context)</code> 下，水平的主轴<code>justify-content</code>属性特性</p><p>条件：适用于所有场景，不需要元素定宽度</p><p>方式：设置父元素为<code>flex</code>布局，且设置<code>justify-content: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex;<br><span class="hljs-attribute">justify-content</span>:cneter<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路五：grid布局"><a href="#思路五：grid布局" class="headerlink" title="思路五：grid布局"></a>思路五：grid布局</h3><p>原理：利用<code>GFC (grid formatting context)</code>  下，水平的主轴<code>justify-content</code>属性特性</p><p>条件：适用于所有场景，不需要元素定宽度</p><p>方式：设置父元素为grid布局，且设置<code>justify-content: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex;<br><span class="hljs-attribute">justify-content</span>:cneter<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><ul><li>行内元素，给其父元素设置<code>text-align:center</code></li><li>定宽块级元素，该元素设置<code>margin:0 auto</code></li><li>定宽块级元素，设置父元素为<code>position: relative</code>，子元素<code>position: absulote</code>和<code>left:50%</code>;加<code>margin-left:-50%*宽度</code>；</li><li>不定宽块级元素，设置父元素为<code>position: relative</code>，子元素<code>position: absulote;</code> <code>left: 50%;</code> <code>transform: translateX(-50%);</code></li><li>不定宽块级元素，设置父元素为<code>flex</code>布局，子元素设置<code>margin:0 auto</code>即可</li><li>不定宽块级元素，设置父元素为<code>flex</code>布局，且设置<code>justify-content: center</code></li><li>不定宽块级元素，设置父元素为<code>grid</code>布局，且设置<code>justify-content: center</code></li></ul><h2 id="二、垂直居中方案"><a href="#二、垂直居中方案" class="headerlink" title="二、垂直居中方案"></a>二、垂直居中方案</h2><h3 id="思路一：利用line-height：父元素高度"><a href="#思路一：利用line-height：父元素高度" class="headerlink" title="思路一：利用line-height：父元素高度"></a>思路一：利用<code>line-height：父元素高度</code></h3><p>原理：<code>line-height：父元素高度</code>让行高等于盒子高度，从而让行内元素垂直居中</p><p>条件：适用于内联元素，也就是<code>display:inline | inline-block | inline-flex | inline-grid，由于line-height具有继承性，防止子元素的高受影响</code>，子元素应该设置<code>line-height:子元素高度</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>：<span class="hljs-number">200px</span>;<br><span class="hljs-attribute">line-height</span>:<span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">line-height</span>:<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路二：利用vertical-align-middle"><a href="#思路二：利用vertical-align-middle" class="headerlink" title="思路二：利用vertical-align:middle"></a>思路二：利用<code>vertical-align:middle</code></h3><p>原理：vertical-align：middle可以使元素<strong>在表格单元中</strong>或者行内元素垂直居中。该属性原理是<strong><strong>行内元素的基线相对于该元素所在行的基线的垂直对齐。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。</strong></strong></p><p>条件：<strong>元素必须为内联元素，或者父元素是表格单元</strong>，也就是<code>display:inline | inline-block | inline-flex | inline-grid | table-cell</code></p><ul><li><p>方式一：<strong>父元素</strong>设为<code>display: tabel-cell</code>，并且设置<code>vertical-align:middle</code></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span><br>display:table_cell;<br>vartical-align:middle;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：<strong>元素</strong>设置为内联元素，并且设置<code>vertical-align:middle</code>，增加一个辅助DOM来改变基线。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span><br>font-size: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">display</span>:inline-block;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br><span class="hljs-selector-class">.father</span><span class="hljs-selector-pseudo">::before</span>&#123;<br><span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<br><span class="hljs-attribute">display</span>:inline-block;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p><strong>vertical-align找基准元素的原则：</strong>同一行中最高的那个inline box就是这一行的基准元素，这也就解释为什么需要辅助元素来占满父元素。</p><p><strong>注意：</strong>inline-block元素间有空格或是换行会产生间隙，使用<code>font-size: 0;</code>可去除</p><h3 id="思路三：子元素使用margin：auto-0"><a href="#思路三：子元素使用margin：auto-0" class="headerlink" title="思路三：子元素使用margin：auto 0"></a>思路三：子元素使用<code>margin：auto 0</code></h3><p><strong>原理：</strong>利用CSS的盒模型和外边距的特性，当一个块级元素<strong>上下</strong>外边距都设置为auto，浏览器会自动计算出左右外边距的值，使得垂直方向居中。</p><p><strong>条件：</strong>不需要确定元素高度，但是必须让元素处于<code>FFC (flex formatting context)</code> ，或者 <code>GFC (grid formatting context)</code> 中，也就是父元素display属性取<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex;// 值还可以为inline-<span class="hljs-attribute">flex</span>、<span class="hljs-attribute">grid</span>、inline-<span class="hljs-attribute">grid</span><br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">margin</span>：auto <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路四：绝对定位"><a href="#思路四：绝对定位" class="headerlink" title="思路四：绝对定位"></a>思路四：绝对定位</h3><p><strong>原理：</strong>通过绝对定位将元素脱离文档流，利用top将元素定位到距离父元素上边界-50%地方，然后通过修正自身高度的偏移使得垂直方向居中。</p><ul><li><p>方式一：绝对定位 +<code>top:50%</code>+ <code>margin-top:-50% * 元素高度</code></p><p>  条件：子元素必须定高度</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：绝对定位 + <code>top:50%</code>+ <code>transform:translateY(-50%);</code></p><p>  条件：适用于所有场景，不需要元素定高度</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="思路五：flex布局"><a href="#思路五：flex布局" class="headerlink" title="思路五：flex布局"></a>思路五：flex布局</h3><p><strong>原理：</strong>利用<code>FFC (flex formatting context)</code> 下，垂直的交叉轴<code>align-item</code>属性特性</p><p><strong>条件：</strong>适用于所有场景，不需要元素定高度</p><p><strong>方式：</strong>设置父元素为<code>flex</code>布局，且设置<code>align-item: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex; <br>align-item:center<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路六：grid布局"><a href="#思路六：grid布局" class="headerlink" title="思路六：grid布局"></a>思路六：grid布局</h3><p><strong>原理：</strong>利用<code>GFC (grid formatting context)</code>  下，垂直的交叉轴的<code>align-item</code>属性特性</p><p><strong>条件：</strong>适用于所有场景，不需要元素定高度</p><p><strong>方式：</strong>设置父元素为grid布局，且设置<code>align-item: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:grid; <br>align-item:center<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><ul><li>若元素是单行文本, 则可设置<code>line-height</code>等于<code>父元素高度</code></li><li>定高块级元素，该元素设置<code>margin:auto 0</code></li><li>定高块级元素，可以用<code>绝对定位</code>+<code>top:50%</code>;+<code>margin-top</code></li><li>不定高会级元素，可以用<code>绝对定位</code>和<code>transform</code></li><li>不定高块级元素，设置<code>父元素</code>为<code>flex</code>布局，<code>子元素</code>设置<code>margin: auto 0</code>即可</li><li>不定高块级元素，设置<code>父元素</code>为<code>flex</code>布局，且设置<code>align-items: center;</code></li><li>不定高块级元素，设置<code>父元素</code>为grid布局，且设置<code>align-items: center;</code></li><li>不定高块级元素，设置<code>父元素</code>为<code>table</code>布局，子元素<code>display: table-cell;vertical-align:middle</code></li></ul><h2 id="三、水平垂直居中方案"><a href="#三、水平垂直居中方案" class="headerlink" title="三、水平垂直居中方案"></a>三、水平垂直居中方案</h2><h3 id="思路一：line-height：父元素高-和-text-align-center"><a href="#思路一：line-height：父元素高-和-text-align-center" class="headerlink" title="思路一：line-height：父元素高 和 text-align:center"></a>思路一：<code>line-height：父元素高</code> 和 <code>text-align:center</code></h3><p>原理：<code>line-height：父元素高度</code>让行高等于盒子高度，从而让行内元素垂直居中，<code>text-align:center</code> 可以是内联元素水平居中</p><p>条件：适用于内联元素，也就是<code>display:inline | inline-block | inline-flex | inline-grid，由于line-height具有继承性，防止子元素的高受影响</code>，子元素应该设置<code>line-height:子元素高度</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">line-height</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">text-align</span>:center;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">width</span>：<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span><br>  line-height:<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路二：vertical-align：middle-和-text-align-center"><a href="#思路二：vertical-align：middle-和-text-align-center" class="headerlink" title="思路二：vertical-align：middle 和 text-align:center"></a>思路二：<code>vertical-align：middle</code> 和 <code>text-align:center</code></h3><p><strong>原理：</strong>vertical-align：middle可以使元素<strong>在表格单元中</strong>或者行内元素垂直居中。该属性原理是行内元素的基线相对于该元素所在行的基线的垂直对齐。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式，<code>text-align:center</code> 可以是内联元素水平居中</p><p><strong>条件：</strong>元素必须为内联元素，或者父元素是表格单元，也就是<code>display:inline | inline-block | inline-flex | inline-grid | table-cell</code></p><ul><li><p>方式一：<strong>父元素</strong>设为<code>display: tabel-cell</code>和<code>text-align:center</code>，并且设置<code>vertical-align:middle</code></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span><br>display:table_cell;<br>vartical-align:middle;<br><span class="hljs-attribute">text-align</span>:center;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式二：父元素加<code>text-align:center</code>，<strong>元素</strong>设置为内联元素，并且设置<code>vertical-align:middle</code>，增加一个辅助DOM来改变基线。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span><br>font-size: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">text-align</span>:center<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">display</span>:inline-block;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br><span class="hljs-selector-class">.father</span><span class="hljs-selector-pseudo">::before</span>&#123;<br><span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<br><span class="hljs-attribute">display</span>:inline-block;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p><strong>vertical-align找基准元素的原则：</strong>同一行中最高的那个inline box就是这一行的基准元素，这也就解释为什么需要辅助元素来占满父元素。</p><p><strong>注意：</strong>inline-block元素间有空格或是换行会产生间隙，使用<code>font-size: 0;</code>可去除</p><h3 id="思路三：使用margin：auto"><a href="#思路三：使用margin：auto" class="headerlink" title="思路三：使用margin：auto"></a>思路三：使用<code>margin：auto</code></h3><p><strong>原理：</strong>利用CSS的盒模型和外边距的特性，当一个块级元素<strong>上下左右</strong>外边距都设置为auto，浏览器会自动计算出上下左右外边距的值，使得水平垂直方向居中。</p><p><strong>条件：</strong>不需要定高，但是必须让元素处于<code>FFC (flex formatting context)</code> ，或者 <code>GFC (grid formatting context)</code> 中，也就是父元素display属性取<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex;// 值还可以为inline-<span class="hljs-attribute">flex</span>、<span class="hljs-attribute">grid</span>、inline-<span class="hljs-attribute">grid</span><br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">margin</span>：auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路四：绝对定位-1"><a href="#思路四：绝对定位-1" class="headerlink" title="思路四：绝对定位"></a>思路四：绝对定位</h3><p>方式一：绝对定位 + <code>left:50%</code> + <code>top:50%</code> + <code>margin-left:-50%*元素高度</code> + <code>margin-top:-50%*元素高度</code></p><p>条件：子元素必须定宽度和高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：绝对定位 + <code>left:50%</code> + <code>top:50%</code> + <code>transform:translate(-50%,-50%)</code></p><p>条件：适用于所有场景，不需要元素定宽度和高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">position</span>:relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>方式三：绝对定位 + <code>top:0</code> + <code>bottom:0</code> + <code>left:0</code> + <code>right:0</code> + <code>margin:auto</code></p><p>条件：子元素必须定宽度和高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路五：flex布局-1"><a href="#思路五：flex布局-1" class="headerlink" title="思路五：flex布局"></a>思路五：flex布局</h3><p>原理：利用<code>FFC (flex formatting context)</code> 下，利用<code>align-item</code>和<code>justify-content</code>属性特性</p><p>条件：适用于所有场景，不需要元素定高度</p><p>方式：设置父元素为<code>flex</code>布局，且设置<code>justify-content: center</code>和<code>align-item: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:flex;<br><span class="hljs-attribute">justify-content</span>:center;<br>align-item:center;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路六：grid布局-1"><a href="#思路六：grid布局-1" class="headerlink" title="思路六：grid布局"></a>思路六：grid布局</h3><p>原理：利用<code>GFC (grid formatting context)</code>  下，利用<code>align-item</code>和<code>justify-content</code>属性特性</p><p>条件：适用于所有场景，不需要元素定高度</p><p>方式：设置父元素为<code>flex</code>布局，且设置<code>justify-content: center</code>和<code>align-item: center</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br><span class="hljs-attribute">display</span>:grid;<br><span class="hljs-attribute">justify-content</span>:center;<br>align-item:center;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  // 无<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><ul><li>子元素内联元素，父元素<code>line-height:父元素高度</code>+<code>textalign:center</code></li><li>子元素内联元素，父元素<code>textalign:center</code>，子元素设置<code>vertical-align:middle</code> + 辅助dom</li><li>子元素内联元素，父元素<code>display: tabel-cell</code>+<code>text-align:center</code>+<code>vertical-align:middle</code></li><li>子元素宽高未知，父元素<code>flex/grid</code>布局，子元素设置<code>margin:auto</code>;</li><li>子元素宽高未知，父元素<code>flex</code>布局，设置<code>justify-content: center</code>+<code>align-items: center</code>;</li><li>子元素宽高未知，父元素<code>grid</code>布局，设置<code>justify-content: center</code>+<code>align-items: center</code>;</li><li>子元素宽高已知，父元素<code>position: relative</code>，子元素用绝对定位，设置上下左右为<code>0</code>，<code>margin:auto</code></li><li>子元素宽高已知，父元素<code>position: relative</code>，子元素用绝对定位 <code>left: 50%</code> + <code>top: 50%;</code> 再 <code>margin</code> 自己的负一半；或者 <code>transform: translate(-50%,-50%)</code>;</li></ul><h2 id="四、两栏布局方案——左边定宽，右边自适应"><a href="#四、两栏布局方案——左边定宽，右边自适应" class="headerlink" title="四、两栏布局方案——左边定宽，右边自适应"></a>四、两栏布局方案——左边定宽，右边自适应</h2><h3 id="思路一：利用float布局"><a href="#思路一：利用float布局" class="headerlink" title="思路一：利用float布局"></a>思路一：利用float布局</h3><ul><li><p><strong>方式一：左<code>float</code>+ 右<code>margin</code></strong></p><p>  左设置<code>固定宽度+向左浮动</code>，右边设置<code>margin-left</code>为左边的固定宽度</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span>&gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方式二：双<code>float</code>+ 右<code>calc</code></strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">200px</span>);<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方式三：左<code>float</code>+右<code>BFC</code></strong></p><p>  利用了<code>BFC</code> 的区域不会与 <code>float</code> 的元素区域重叠的机制</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="思路二：绝对定位"><a href="#思路二：绝对定位" class="headerlink" title="思路二：绝对定位"></a>思路二：绝对定位</h3><p><strong>左<code>position:absolute</code>+右<code>margin</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">position</span>:relative;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br><span class="hljs-attribute">position</span>:absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路三：利用文档流"><a href="#思路三：利用文档流" class="headerlink" title="思路三：利用文档流"></a>思路三：利用文档流</h3><p><strong>双<code>inline-block</code>+右<code>calc</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">font-size</span>:<span class="hljs-number">0</span>; //消除inline-block盒子间的空格<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">display</span>:inline-block;<br><span class="hljs-attribute">vertical-align</span>:top;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路四：Flex布局"><a href="#思路四：Flex布局" class="headerlink" title="思路四：Flex布局"></a>思路四：Flex布局</h3><p><code>最简单常用</code>：使用<code>flex</code>布局（<code>左定宽，右flex1</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; // 设置<span class="hljs-attribute">flex-grow</span>属性为<span class="hljs-number">1</span>，默认为<span class="hljs-number">0</span><br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路五：Grid布局"><a href="#思路五：Grid布局" class="headerlink" title="思路五：Grid布局"></a>思路五：Grid布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  // 无<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> // 无<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、三栏布局方案——左右定宽中间自适应布局"><a href="#五、三栏布局方案——左右定宽中间自适应布局" class="headerlink" title="五、三栏布局方案——左右定宽中间自适应布局"></a>五、三栏布局方案——左右定宽中间自适应布局</h2><h3 id="思路一：流体布局"><a href="#思路一：流体布局" class="headerlink" title="思路一：流体布局"></a>思路一：流体布局</h3><p>左右<code>float</code>+中<code>margin</code>：左右栏定宽并设置浮动，中间一栏设置左右两个方向的<code>margin</code>值且不设置宽度。注意：DOM结构必须为<strong>左右中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br><span class="hljs-selector-class">.main</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="思路二：BFC布局"><a href="#思路二：BFC布局" class="headerlink" title="思路二：BFC布局"></a>思路二：BFC布局</h3><p>利用BFC 区域，不会与浮动元素重叠的特性。<strong>左右模块各自向左右浮动</strong>，并设置中间模块的<code>overflow：hidden</code>，使中间模块宽度自适应。注意：DOM结构必须为<strong>左右中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.main</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路三：Flex布局"><a href="#思路三：Flex布局" class="headerlink" title="思路三：Flex布局"></a>思路三：Flex布局</h3><p><strong>方式一：利用</strong><code>justify-content: space-around</code><strong>属性</strong></p><p>通过在父元素声明<code>justify-content: space-around</code>，使得水平方向元素靠两边布局，左右定宽，中间宽度设置100%</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">width</span>：<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span><br>  height:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">width</span>：<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式二：利用 <code>flex-grow</code> 、<code>flex-shrink</code> 、 <code>flex-basis</code>属性</strong></p><p>通过这三个属性缩写形式，父元素<code>flex</code>，左右设置<code>flex: 0 1 200px</code>，中间设置<code>flex:1</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路四：Grid布局"><a href="#思路四：Grid布局" class="headerlink" title="思路四：Grid布局"></a>思路四：Grid布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrap</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  // 无<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> // 无<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路五：绝对定位"><a href="#思路五：绝对定位" class="headerlink" title="思路五：绝对定位"></a>思路五：绝对定位</h3><p>左右<code>绝对定位</code>+中<code>margin</code>：左右两栏设置绝对定位放左右，中间设置两个方面的<code>margin</code>值，注意DOM结构顺序，顺序不同代码有微少差异。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>  <span class="hljs-attribute">position</span>:realtive;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">200px</span>;<br><span class="hljs-attribute">margin-right</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span><br>  height:<span class="hljs-number">500px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路六：圣杯布局"><a href="#思路六：圣杯布局" class="headerlink" title="思路六：圣杯布局"></a>思路六：圣杯布局</h3><p>父元素设置左右<code>padding</code>，子元素三栏都通过<code>float</code>浮动，然后通过<strong>负值<code>margin</code><strong>或者</strong>相对定位</strong>进行调整。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过margin调节位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>  <span class="hljs-attribute">position</span>:realtive;<br><span class="hljs-attribute">padding-left</span>:<span class="hljs-number">200px</span>;<br><span class="hljs-attribute">padding-right</span>:<span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">margin-left</span>:<span class="hljs-built_in">calc</span>(-<span class="hljs-number">100%</span> - <span class="hljs-number">200px</span>);// 同样负的<span class="hljs-attribute">margin-right</span>也是不能达到效果<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span><br>  height:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">margin-right</span>:-<span class="hljs-number">200px</span>; //为什么<span class="hljs-attribute">margin-right</span>就可以挤到父元素的<span class="hljs-attribute">padding</span>里，<span class="hljs-attribute">margin-left</span>就不可以<br>&#125;<br></code></pre></td></tr></table></figure><p>通过相对定位调节位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>  <span class="hljs-attribute">position</span>:realtive;<br><span class="hljs-attribute">padding-left</span>:<span class="hljs-number">200px</span>;<br><span class="hljs-attribute">padding-right</span>:<span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<br><span class="hljs-attribute">position</span>:relative;<br><span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>; <br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span><br>  height:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">position</span>:relative;<br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">200px</span>;<br><span class="hljs-attribute">right</span>:-<span class="hljs-number">200px</span><br>&#125;<br></code></pre></td></tr></table></figure><p>缺陷：中间栏的最小宽度不能小于左右两栏的宽度，否则左右两栏会掉到下一行。（设置 <code>min-width</code> 解决）</p><h3 id="思路七：双飞翼布局（圣杯布局改进版）"><a href="#思路七：双飞翼布局（圣杯布局改进版）" class="headerlink" title="思路七：双飞翼布局（圣杯布局改进版）"></a>思路七：双飞翼布局（圣杯布局改进版）</h3><p>对圣杯布局的改进，取消了相对定位</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.inner</span>&#123;<br>   <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">200px</span>;<br>   <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span><br>  height:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优势：解决圣杯布局中，margin的复杂调节，节省很多css代码</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入一个URL浏览器会发生什么</title>
    <link href="/2023/03/10/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
    <url>/2023/03/10/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="输入一个URL浏览器会发生什么"><a href="#输入一个URL浏览器会发生什么" class="headerlink" title="输入一个URL浏览器会发生什么"></a>输入一个URL浏览器会发生什么</h1><h2 id="一、-DNS域名解析获取IP地址"><a href="#一、-DNS域名解析获取IP地址" class="headerlink" title="一、 DNS域名解析获取IP地址"></a>一、 <strong>DNS域名解析获取IP地址</strong></h2><p><img src="/img/urlwork1.png"></p><ul><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ul><blockquote><p>DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；</p></blockquote><p>在客户端输入 URL 后，会有一个<strong>递归查找</strong>的过程，从<code>浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找</code>，这个过程中任何一步找到了都会结束查找流程。</p><p><img src="/img/urlwork2.png"></p><p>如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则<strong>迭代查找</strong>过程如下图：</p><p><img src="/img/urlwork3.png"></p><p>结合起来的过程，可以用一个图表示：</p><p><img src="/img/urlwork4.png"></p><p><strong>在查找过程中，有以下优化点：</strong></p><ul><li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: <code>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</code>。</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h2 id="二、-建立TCP连接"><a href="#二、-建立TCP连接" class="headerlink" title="二、 建立TCP连接"></a>二、 <strong>建立TCP连接</strong></h2><p>首先，判断是不是HTTPS，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据</p><p><strong>我们先了解下TCP报文中字段的含义：</strong></p><ul><li>序列号：seq序号占32位，用来标识从计算机A发送到计算机B的数据包的房号，计算机发送数据时对此进行标记</li><li>确认号：ack确认号占32位，客户端和服务器端都可以发送，ack = seq +1</li><li>标志位：每人标志位占用1Bit,共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：URG: 紧急指针有效。<ul><li><strong>ACK:确认序号有效。ACK=0代表未确认；ACK=1代表确认。</strong></li><li>PSH: 接收方应该尽快将这人报文交给应用层。</li><li>RST: 重留连接</li><li><strong>SYN: 建立一个新连接，SYN=0表示这是一个普通TCP报文；SYN=1代表是用于连接的SYN报文段。</strong></li><li><strong>FIN: 断开一个连接，FIN=0表示发送方还未完成发送数据，不能请求关闭连接；FIN=1表示发送方完成数据发送，请求关闭连接。</strong></li></ul></li></ul><p><strong>建立TCP连接，进行三次握手。</strong></p><p><img src="/img/urlwork5.png"></p><p>最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong></p><ul><li>第一次握手：*建立连接。客户端发送连接请求报文段，发送建立连接标志位SYN，并选择一个初始序列号seq=x，此时，TCP客户端进程进入了 <strong>SYN-SENT 同步已发送状态</strong>。*【证明客户端的发送能力正常】</li><li>第二次握手：*服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，发送建立连接标志位SYN和确认序号有效标志位ACK，并发送确认号seq = x + 1 （表示确认收到客户端SYN报文），同时发送服务器自己的序列号ack=y，此时，TCP服务器进程进入了 <strong>SYN-RCVD 同步收到状态</strong>。*【证明服务器端的接收能力、发送能力正常】</li><li>第三次握手：<em>客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段，告诉服务器序号有效，并发送确认号ack = y + 1（表示确认收到服务端SYN报文），<strong>并发送自己的序列号seq = x+1（为了保证服务器不收到重复的连接请求）</strong>，此时，TCP连接建立，客户端进入<strong>ESTABLISHED已建立连接状态</strong>，触发三次握手。</em>【证明客户端的接收能力正常】</li></ul><p><strong>SSL握手过程</strong></p><ul><li>第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数</li><li>第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号</li><li>第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息</li><li>第四阶段 变更密码构件和结束握手协议</li></ul><p>完成了之后，客户端和服务器端就可以开始传送数据</p><h2 id="三、浏览器发送HTTP请求，并进行资源缓存缓存"><a href="#三、浏览器发送HTTP请求，并进行资源缓存缓存" class="headerlink" title="三、浏览器发送HTTP请求，并进行资源缓存缓存"></a>三、浏览器发送HTTP请求，并进行资源缓存缓存</h2><p><strong>发送HTTP请求，服务器处理请求，返回响应结果</strong></p><blockquote><p>TCP连接建立后，浏览器就可以利用 HTTP／HTTPS 协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200</p></blockquote><p>这里有发生的一个过程是HTTP缓存，具体可以看<a href="/2023/03/01/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94HTTP%E7%BC%93%E5%AD%98/">前端缓存——HTTP缓存</a></p><h2 id="四、-进行四次挥手，关闭TCP连接"><a href="#四、-进行四次挥手，关闭TCP连接" class="headerlink" title="四、 进行四次挥手，关闭TCP连接"></a>四、 <strong>进行四次挥手，关闭TCP连接</strong></h2><p><img src="/img/urlwork6.png"></p><ul><li>第一次挥手：<em>客户端发出连接释放报文，并且停止发送数据。发送断开连接标志位FIN，同时也发送自己序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态</em></li><li>第二次挥手 ：<em>服务器端接收到客户端断开连接请求后，发出序号有效标志位ACK，同时发送确认号ack=u+1<strong>（告诉客户端收到断开请求，但服务器还不能断）</strong>，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态</em></li><li>第三次挥手：<em>客户端接收到服务器端的确认请求后，<strong>客户端就会进入FIN-WAIT-2（终止等待2）</strong>状态，等待服务器发送断开连接请求，服务器将最后的数据发送完毕后，就向客户端发送断开连接标志位FIN和确认号有效标志位ACK，同时发送确认号ack = u+ 1（<strong>告诉客户端，服务器可以断开了）</strong>，并带上服务器序列号为seq=w，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</em></li><li>第四次挥手：<em>客户端收到服务器的断开连接报文后，必须发出确认，发送确认号有效标志位ACK，并发送确认号ack=w+1（告诉服务器，客户端确定断开了），同时发送自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成</em></li></ul><aside>💡 简版过程<ul><li>A：“任务处理完毕，我希望断开连接。”</li><li>B：“哦，是吗？请稍等，我准备一下。”</li><li>等待片刻后……</li><li>B：“我准备好了，可以断开连接了。”</li><li>A：“好的，谢谢合作。”</aside></li></ul><h2 id="五、-浏览器渲染"><a href="#五、-浏览器渲染" class="headerlink" title="五、 浏览器渲染"></a>五、 <strong>浏览器渲染</strong></h2><p><img src="/img/urlwork7.png"></p><ul><li>解析 HTML 代码，构建 DOM 树（DOM Tree）, <strong>下载资源，</strong>解析 CSS 代码，构建 CSSOM 树（CSSOM Tree），执行JS脚本</li><li>将 DOM 树和 CSSOM 树合并，生成渲染树 （Render Tree）。</li><li>对渲染树进行布局（Layout），计算每个渲染对象的位置和大小，然后更新渲染树。</li><li>渲染树后面大小或者位置发生改变，将会重新计算，重新进行布局和绘制，我们也称之为重排（回流）、重绘。</li><li>对渲染树进行绘制（Paint），将渲染对象绘制到屏幕上</li></ul><h3 id="1-构建-DOM-树和CSSOM树"><a href="#1-构建-DOM-树和CSSOM树" class="headerlink" title="1. 构建 DOM 树和CSSOM树"></a>1. <strong>构建 DOM 树和CSSOM树</strong></h3><p><img src="/img/urlwork8.png"></p><p>渲染引擎将HTML解析为DOM树，将 CSS 解析为CSSOM树。</p><blockquote><p>CSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。</p></blockquote><p>CSS的解析不影响DOM的解析，二者是同时进行，但由于渲染树必须等DOM树和CSSOM树都解析完成才可以生成，所以CSSOM解析时间过晚或者时间过长可能会影响DOM的渲染，当然CSS还会不影响JS的下载，但会堵塞JS的执行。</p><p>当然JS的位置也会对DOM的解析产生影响，如果DOM在<head>中，并且没有加<code>defer</code>或者<code>async</code>，将会堵塞DOM的解析。</p><p><strong>所以避免css堵塞的方法：</strong>一定要将css的<link>放在<head>中，并且永远在在JS之前，这样才能保证CSS不会影响到后面JS的执行。</p><p><strong>避免JS堵塞的方法：</strong></p><ul><li>将<code>&lt;script&gt;</code>放到<code>&lt;body&gt;</code>下</li><li>放在<code>&lt;head&gt;</code>中为<code>&lt;script&gt;</code>使用<code>defer</code> 或者 <code>async</code> 异步加载JS</li><li>如果注重<code>&lt;script&gt;</code>加载顺序，就是用<code>defer</code></li><li>如果不需要特定的顺序，那就采用<code>async</code></li></ul><h3 id="2-生成渲染树"><a href="#2-生成渲染树" class="headerlink" title="2. 生成渲染树"></a>2. 生成渲染树</h3><p>根据CSSOM树中每个元素样式和DOM元素结合起来，就会生成一个只包<strong>所有可见节点</strong>的样式的渲染树（Render Tree）。</p><h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3. 布局"></a>3. 布局</h3><p><strong>3.1 生成布局树</strong></p><p>计算元素的尺寸和位置信息，确定元素的位置，构建一棵只包含可见元素<strong>布局树（Layout Tree）。</strong></p><blockquote><p>布局树是渲染树的一个子集，用于描述需要进行局部计算元素位置和大小信息</p></blockquote><p>其中，这个过程需要注意的是<strong>重排（回流）</strong>和<strong>重绘，我们看看那些属性会发生重排和重绘：</strong></p><table><thead><tr><th>常见引起重排属性和方法</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>clientTop</td><td>clientLeft</td></tr><tr><td>offsetWidth</td><td>offsetHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>scrollIntoView()</td><td>scrollTo()</td><td>getComputedStyle()</td><td></td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewIfNeeded()</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>常见的引起重绘的属性</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td>background-size</td><td></td></tr></tbody></table><p>重排和重绘都会产生性能影响，但重排最为影响性能，因为<strong>重绘不一定导致重排，但重排一定会导致重绘，所以要尽量避免重排。</strong></p><p><strong>3.1.1 如何避免重排？</strong></p><ul><li><strong>样式集中改变</strong></li><li><strong>读写操作集中改变，不要“读”“写”“读”“写”，尽量改成“读”“读” “写”“写”</strong></li><li><strong>DOM离线</strong><ul><li>使用 display:none指会有一次重排重绘，使用visibility : hidden只会有重绘。</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排和重绘。</li><li>• 复制节点，在副本上工作，然后替换它</li></ul></li><li><strong>脱离文档流，这样只会发生局部的重排和重绘</strong></li><li><strong>优化动画</strong><ul><li>将动画脱离文档流</li><li>启用GPU加速，也就是使用Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL，Vedio等</li></ul></li></ul><p><strong>3.2 生成分层树</strong></p><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树（LayerTree）</strong>。</p><blockquote><p>图层树（LayerTree）是渲染树的一个子集，用于描述需要进行图层合成的元素的位置和图层之间的关系。</p></blockquote><h3 id="4-绘制"><a href="#4-绘制" class="headerlink" title="4.绘制"></a>4.绘制</h3><p><strong>栅格化</strong></p><p>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。</p><blockquote><p>绘制列表也是渲染树的一个子集，用户描述需要进行绘制的元素和绘制顺序。</p></blockquote><p>所谓栅格化，是指将图块转换为位图</p><p><img src="/img/urlwork9.png"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h3 id="6-显示"><a href="#6-显示" class="headerlink" title="6.显示"></a>6.<strong>显示</strong></h3><p>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>清除浮动</title>
    <link href="/2023/03/08/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/03/08/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h3 id="一、浮动元素本质"><a href="#一、浮动元素本质" class="headerlink" title="一、浮动元素本质"></a>一、浮动元素本质</h3><p>浮动的本质是通过脱离文档流并向左或向右排列元素，直到遇到父元素或其他元素为止。</p><aside>💡 这里引用张鑫旭大神观点：   “撇开浮动的“破坏性”，浮动就是个带有方位的display:inline-block属性。”</aside><h3 id="二、浮动的“破坏性”是什么？"><a href="#二、浮动的“破坏性”是什么？" class="headerlink" title="二、浮动的“破坏性”是什么？"></a>二、<strong>浮动的“破坏性”是什么？</strong></h3><p>其实浮动<code>float</code>最开始出现的意义只是为了让文字环绕图片而已。但人们发现，如果想要三个块级元素并排显示，都给它们加个<code>float</code>来得会比较方便。但这样做也会带来问题……</p><p><em>我们希望看到这样的效果：</em></p><p><img src="/img/float1.webp"></p><p><em>但结果却是这样：</em></p><p><img src="/img/float2.webp"></p><p>这个时候，我们就要清除浮动带来的“破坏性”——<strong>父元素高度塌陷</strong>了。</p><h3 id="三、清除浮动的方式"><a href="#三、清除浮动的方式" class="headerlink" title="三、清除浮动的方式"></a>三、清除浮动的方式</h3><ul><li>在浮动元素后面添加 <code>clear:both</code>的空 <code>div</code> 元素</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;clear:both&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ul><li>给父元素添加 <code>overflow:hidden</code> 或者 <code>auto</code> 样式，触发<code>BFC</code>特性</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">container</span>&#123;<br>    <span class="hljs-attr">width</span>: 300px;<br>    background-<span class="hljs-attr">color</span>: #aaa;<br>    <span class="hljs-attr">overflow</span>:hidden;<br>    <span class="hljs-attr">zoom</span>:<span class="hljs-number">1</span>;   <span class="hljs-comment">/*IE6*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用伪元素，也是在元素末尾添加一个点并带有 <code>clear: both</code> 属性的元素实现的。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container clearfix&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">clearfix</span>&#123;<br>    <span class="hljs-attr">zoom</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/*IE6*/</span><br>&#125;<br>.<span class="hljs-property">clearfix</span>:after&#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;.&quot;</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attr">clear</span>: both;<br>    <span class="hljs-attr">display</span>: block;<br>    <span class="hljs-attr">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><aside>💡 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰</aside>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲透BFC原理</title>
    <link href="/2023/03/06/%E8%AE%B2%E9%80%8FBFC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/03/06/%E8%AE%B2%E9%80%8FBFC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="讲透BFC原理"><a href="#讲透BFC原理" class="headerlink" title="讲透BFC原理"></a>讲透BFC原理</h1><h2 id="一、什么是BFC"><a href="#一、什么是BFC" class="headerlink" title="一、什么是BFC"></a>一、什么是BFC</h2><p>BFC全称<strong>Block formatting context</strong>，中文叫“块级格式化上下文”，它是一个独立的渲染区域。也就是说可以理解<strong>BFC是一个容器，一个BFC容器里面的元素不会影响容器之外的元素。</strong></p><h2 id="二、Box与Formatting-Context"><a href="#二、Box与Formatting-Context" class="headerlink" title="二、Box与Formatting Context"></a>二、Box与Formatting Context</h2><h3 id="1-Box"><a href="#1-Box" class="headerlink" title="1. Box"></a>1. <strong><strong>Box</strong></strong></h3><p><strong>Box 是 CSS 布局的对象和基本单位</strong>， 直观点来说，就是一个页面是由很多个 Box 组成的。</p><p><strong>元素的类型</strong>和 <strong>display 属性</strong>，决定了这个 <strong>Box 的类型</strong>。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p><ul><li><code>block-level box</code>：display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context，也就是我们说的 <strong>BFC</strong></li><li><code>inline-level box</code>：display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context，也就是我们说的 <strong>IFC</strong></li><li><code>run-in box</code>：css3 中才有， 这儿先不讲了。</li></ul><h3 id="2-Formatting-context"><a href="#2-Formatting-context" class="headerlink" title="2. Formatting context"></a>2. <strong>Formatting context</strong></h3><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。<strong>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p><p>最常见的 Formatting context 有 Block fomatting context (简称BFC) 和 Inline formatting context (简称IFC)。</p><h2 id="三、BFC特性"><a href="#三、BFC特性" class="headerlink" title="三、BFC特性"></a>三、BFC特性</h2><ol><li>同一个 <code>BFC</code>的元素会在垂直方向上一个接一个地放置，形成一个垂直流。</li><li>同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠</li><li><code>BFC</code>区域不会与外部浮动元素重叠。</li><li><code>BFC</code>区域的高度会被内部元素的高度撑开，<strong>浮动子元素也参与计算</strong></li><li><code>BFC</code>区域内部的元素会形成一个独立的渲染环境，不会影响到外部元素的布局。</li><li><code>BFC</code>区域的左边缘与<strong>包含块</strong>的左边缘相接触（对于从右到左格式，右边缘接触），即使存在浮动元素也是如此。</li></ol><aside>💡 CSS包含块是指一个元素的布局上下文，它是指定元素的位置和尺寸的基准，也可以理解为布局的参考系。</aside><h2 id="四、形成BFC条件"><a href="#四、形成BFC条件" class="headerlink" title="四、形成BFC条件"></a>四<strong>、形成BFC条件</strong></h2><ol><li>根元素html</li><li><code>float</code>属性不为<code>none</code> ，为<code>left</code>、<code>right</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block、 table-cell、table-caption</code>、<code>flex、inline-flex</code>、<code>grid</code><br>、<code>inline-grid</code></li><li><code>overflow</code>不为<code>visible</code>，为 <code>auto</code>、<code>scroll</code>、<code>hidden</code></li></ol><h2 id="五、BFC的应用"><a href="#五、BFC的应用" class="headerlink" title="五、BFC的应用"></a>五、BFC的应用</h2><h3 id="1-清除浮动"><a href="#1-清除浮动" class="headerlink" title="1. 清除浮动"></a>1. <strong>清除浮动</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.par</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#fcc</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"> </span><br><span class="language-css">    <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#f66</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;par&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bfc1.png"></p><p>根据BFC特性，<code>BFC</code>在计算高度时，浮动元素也会参与，所以我们可以触发<code>.par</code>元素生成<code>BFC</code>，则内部浮动元素计算高度时候也会计算，从而解决父元素高度塌陷问题。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">par</span> &#123;<br>    <span class="hljs-attr">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/bfc2.png"></p><h3 id="2-防止margin重叠（塌陷）"><a href="#2-防止margin重叠（塌陷）" class="headerlink" title="2. 防止margin重叠（塌陷）"></a>2. <strong>防止margin重叠（塌陷）</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#f55</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#fcc</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>:center;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Haha<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hehe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bfc3.png"></p><p><strong>根据BFC特性，同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠，</strong>我们可以在p外面包裹一层容器，并触发该容器生成一个<code>BFC</code>。那么两个P便不属于同一个<code>BFC</code>，就不会发生margin重叠了，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">wrap</span> &#123;<br>        <span class="hljs-attr">overflow</span>: hidden;<span class="hljs-comment">// 新的BFC</span><br>    &#125;<br>    p &#123;<br>        <span class="hljs-attr">color</span>: #f55;<br>        <span class="hljs-attr">background</span>: #fcc;<br>        <span class="hljs-attr">width</span>: 200px;<br>        line-<span class="hljs-attr">height</span>: 100px;<br>        text-<span class="hljs-attr">align</span>:center;<br>        <span class="hljs-attr">margin</span>: 100px;<br>    &#125;<br>&lt;/style&gt;<br>&lt;body&gt;<br>&lt;p&gt;Haha&lt;/p &gt;<br>&lt;div class=&quot;wrap&quot;&gt;<br>&lt;p&gt;Hehe&lt;/p &gt;<br>&lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/bfc4.png"></p><h3 id="3-自适应两栏布局"><a href="#3-自适应两栏布局" class="headerlink" title="3. 自适应两栏布局"></a>3. 自适应两栏布局</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    body &#123;<br>        <span class="hljs-attr">width</span>: 300px;<br>        <span class="hljs-attr">position</span>: relative;<br>    &#125;<br> <br>    .<span class="hljs-property">aside</span> &#123;<br>        <span class="hljs-attr">width</span>: 100px;<br>        <span class="hljs-attr">height</span>: 150px;<br>        <span class="hljs-attr">float</span>: left;<br>        <span class="hljs-attr">background</span>: #f66;<br>    &#125;<br> <br>    .<span class="hljs-property">main</span> &#123;<br>        <span class="hljs-attr">height</span>: 200px;<br>        <span class="hljs-attr">background</span>: #fcc;<br>    &#125;<br>&lt;/style&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/bfc5.png"></p><p>利用BFC特性：<code>BFC</code>区域不会与外部浮动元素重叠，通过让<code>.main</code>形成一个BFC就可以实现自适应的两栏布局</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">main</span>&#123;<br><span class="hljs-attr">overflow</span>:hidden<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/bfc6.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS中的布局上下文——包含块</title>
    <link href="/2023/03/05/CSS%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87%E2%80%94%E2%80%94%E5%8C%85%E5%90%AB%E5%9D%97/"/>
    <url>/2023/03/05/CSS%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87%E2%80%94%E2%80%94%E5%8C%85%E5%90%AB%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS中的布局上下文——包含块"><a href="#CSS中的布局上下文——包含块" class="headerlink" title="CSS中的布局上下文——包含块"></a>CSS中的布局上下文——包含块</h1><h3 id="什么是包含块？"><a href="#什么是包含块？" class="headerlink" title="什么是包含块？"></a>什么是包含块？</h3><p>CSS包含块是指一个<strong>元素的布局上下文</strong>，它是指定元素的<strong>位置</strong>和<strong>尺寸</strong>的<strong>基准，也可以理解为布局的参考系。</strong></p><p>通过上面的概念我们知道：包含块将会影响元素的<strong>定位</strong>和<strong>尺寸</strong>，那么我们来学习下元素的包含块是如何响应元素的。</p><h3 id="如何确定元素的包含块？"><a href="#如何确定元素的包含块？" class="headerlink" title="如何确定元素的包含块？"></a>如何确定元素的包含块？</h3><p>确定一个元素的包含块的过程完全依赖于这个元素的 <code>[position](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position)</code>属性，也就是说<code>position</code>属性的不同，该元素的包含块指向也不同:</p><ul><li>当元素的<code>position：absolute</code>：元素的包含块就是离它<strong>最近</strong>的<strong>positon值不为static</strong>的<strong>祖先元素</strong>的padding-box 。</li><li>当元素的<code>position：fixed</code>：元素的包含块就是当前的viewport</li><li>当元素的<code>position：static | relative | sticky</code> ：包含块可能由它的最近的祖先<strong>块元素的content-box</strong></li></ul><p>注意：一个完整的box包含margin-box，border-box，padding-box，content-box，但是包含块只能是content-box或者padding-box。</p><p>假设有以下HTML代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ul><li>如果没有对<code>.parent</code>和<code>.child</code>进行任何定位，那么<code>.child</code>的包含块就是<code>.parent</code>元素。</li><li>如果我们对<code>.child</code>进行相对定位，那么<code>.child</code>的包含块就是它父元素<code>.parent</code>。</li><li>如果我们对<code>.child</code>进行绝对定位，并且<code>.parent</code>没有进行定位，那么<code>.child</code>的包含块就是根元素（HTML元素）。</li><li>如果我们对<code>.parent</code>进行相对定位，并且<code>.child</code>进行绝对定位，那么<code>.child</code>的包含块就是<code>.parent</code>元素。</li></ul><h3 id="包含块对元素位置的影响"><a href="#包含块对元素位置的影响" class="headerlink" title="包含块对元素位置的影响"></a>包含块对元素位置的影响</h3><p>定位元素的属性有<code>top</code>、<code>right</code>、<code>bottom</code> 和<code>left</code><strong>（<code>position:static</code>时这些定位属性是不起作用的）</strong></p><p>前提是这些元素起作用的情况下，这些属性的值是依据<strong>包含块</strong>的长宽为基准的，并且位置的偏移也是基于<strong>包含块的左上角计算的</strong>。</p><p>如果这些属性的值为百分比，那么它的值 = 百分比 * 基准值</p><h3 id="包含块对于元素尺寸影响"><a href="#包含块对于元素尺寸影响" class="headerlink" title="包含块对于元素尺寸影响"></a>包含块对于元素尺寸影响</h3><p>设置元素尺寸的属性有<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>，这些值是相对于包含块计算的。</p><p>如果这些属性的值为百分比，那么它的值 = 百分比 * 基准值</p><h3 id="包含块在CSS的应用"><a href="#包含块在CSS的应用" class="headerlink" title="包含块在CSS的应用"></a>包含块在CSS的应用</h3><ul><li>定位元素：在CSS中，可以使用position属性将元素定位到页面上的特定位置。元素的位置通常是相对于其包含块来计算的。因此，包含块对于定位元素非常重要。</li><li>响应式布局：在响应式布局中，页面的布局会根据不同的屏幕尺寸和设备类型进行调整。为了实现这种布局，通常会使用百分比或em单位来指定元素的大小和位置。这些单位是相对于元素的包含块来计算的。</li><li>浮动元素：在CSS中，可以使用float属性将元素浮动到页面上的特定位置。浮动元素的位置也是相对于其包含块来计算的。</li><li>清除浮动：在浮动元素的周围添加内容时，可能会出现布局问题。为了解决这个问题，可以使用clear属性来清除浮动。clear属性指定了元素应该清除哪些浮动元素。这个属性也是相对于元素的包含块来计算的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>包含块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式速查表</title>
    <link href="/2023/03/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <url>/2023/03/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式速查表"><a href="#正则表达式速查表" class="headerlink" title="正则表达式速查表"></a>正则表达式速查表</h1><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>字母、数字</td><td>匹配字面量本身。比如 /f/，匹配字母 “f”。</td></tr><tr><td>\0</td><td>匹配 NUL 字符。</td></tr><tr><td>\t</td><td>匹配水平制表符。</td></tr><tr><td>\v</td><td>匹配垂直制表符。</td></tr><tr><td>\n</td><td>匹配换行符。</td></tr><tr><td>\r</td><td>匹配回车符。</td></tr><tr><td>\f</td><td>匹配换页符。</td></tr><tr><td>\xnn</td><td>匹配拉丁字符。比如 \xOA 等价于 \n。</td></tr><tr><td>\uxxxx</td><td>匹配 Unicode 字符。比如 \u2028 匹配行终止符，\u2029 匹配段终止符。</td></tr><tr><td>\cX</td><td>匹配 ctrl+X。比如 \cI 匹配 ctrl+I，等价于 \t。</td></tr><tr><td>[\b]</td><td>匹配 Backspace 键（特殊记忆）。</td></tr></tbody></table><h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>[abc]</td><td>匹配 “a”、”b”、”c” 其中任何一个字符。</td></tr><tr><td>[a-d1-4]</td><td>匹配 “a”、”b”、”c”、”d”、”1”、”2”、”3”、”4” 其中任何一个字符。</td></tr><tr><td>[^abc]</td><td>匹配除了 “a”、”b”、”c” 之外的任何一个字符。</td></tr><tr><td>[^a-d1-4]</td><td>匹配除了 “a”、”b”、”c”、”d”、”1”、”2”、”3”、”4” 之外的任何一个字符。</td></tr><tr><td>.</td><td>通配符，匹配除了少数字符（\n）之外的任意字符。</td></tr><tr><td>\d</td><td>匹配数字（digit），等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配非数字，等价于 [^0-9]。</td></tr><tr><td>\w</td><td>匹配单词（word）字符，等价于 [a-zA-Z0-9_]。</td></tr><tr><td>\W</td><td>匹配非单词字符，等价于 [^a-zA-Z0-9_]。</td></tr><tr><td>\s</td><td>匹配空白符（space），等价于 [ \t\v\n\r\f]。</td></tr><tr><td>\S</td><td>匹配非空白符，等价于 [^ \t\v\n\r\f]。</td></tr></tbody></table><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>{n,m}</td><td>连续出现 n 到 m 次。贪婪模式。</td></tr><tr><td>{n,}</td><td>至少连续出现 n 次。贪婪模式。</td></tr><tr><td>{n}</td><td>连续出现 n 次。贪婪模式。</td></tr><tr><td>?</td><td>等价于 {0,1}。贪婪模式。</td></tr><tr><td>+</td><td>等价于 {1,}。贪婪模式。</td></tr><tr><td>*</td><td>等价于 {0,}。贪婪模式。</td></tr><tr><td>{n,m}?</td><td>连续出现 n 到 m 次。惰性模式。</td></tr><tr><td>{n,}?</td><td>至少连续出现 n 次。惰性模式。</td></tr><tr><td>{n}?</td><td>连续出现 n 次。惰性模式。</td></tr><tr><td>??</td><td>等价于 {0,1}?。惰性模式。</td></tr><tr><td>+?</td><td>等价于 {1,}?。惰性模式。</td></tr><tr><td>*?</td><td>等价于 {0,}?。惰性模式。</td></tr></tbody></table><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配开头的位置，当正则有修饰符 m 时，表示匹配行开头位置。</td></tr><tr><td>$</td><td>匹配结尾的位置，当正则有修饰符 m 时，表示匹配行结尾位置。</td></tr><tr><td>\b</td><td>匹配单词边界，即，\w 与 \W、^ 与 \w、\w 与 $ 之间的位置。</td></tr><tr><td>\B</td><td>匹配非单词边界，即，\w 与 \w、\W 与 \W、^ 与 \W，\W 与 $ 之间的位置。</td></tr><tr><td>(?=abc)</td><td>匹配 “abc” 前面的位置，即此位置后面匹配 “abc”。</td></tr><tr><td>(?!abc)</td><td>匹配非 “abc” 前面的位置，即此位置后面不匹配 “abc”。</td></tr></tbody></table><h3 id="括号作用"><a href="#括号作用" class="headerlink" title="括号作用"></a>括号作用</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>(ab)</td><td>捕获型分组。把 “ab” 当成一个整体，比如 (ab)+ 表示 “ab” 至少连续出现一次。</td></tr><tr><td>(?:ab)</td><td>非捕获型分组。与 (ab) 的区别是，它不捕获数据。</td></tr><tr><td>(good</td><td>nice)</td></tr><tr><td>(?:good</td><td>nice)</td></tr><tr><td>\num</td><td>反向引用。比如 \2，表示引用的是第二个括号里的捕获的数据。</td></tr></tbody></table><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>全局匹配，找到所有满足匹配的子串。</td></tr><tr><td>i</td><td>匹配过程中，忽略英文字母大小写。</td></tr><tr><td>m</td><td>多行匹配，把 ^ 和 $ 变成行开头和行结尾。</td></tr></tbody></table><h3 id="String相关实例方法"><a href="#String相关实例方法" class="headerlink" title="String相关实例方法"></a>String相关实例方法</h3><table><thead><tr><th>属性</th><th>方法作用说明</th></tr></thead><tbody><tr><td>search</td><td>返回正则匹配到的第一个子串在目标字符串中的下标位置。</td></tr><tr><td>split</td><td>以正则匹配到的子串，对目标字符串进行切分。返回一个数组。</td></tr><tr><td>match</td><td>对目标字符串执行正则匹配操作，返回的匹配结果数组中包含具体的匹配信息。</td></tr><tr><td>replace</td><td>对目标字符串进行替换操作。正则是其第一个参数。返回替换后的字符串。</td></tr></tbody></table><h3 id="replace第二个参数中的特殊字符"><a href="#replace第二个参数中的特殊字符" class="headerlink" title="replace第二个参数中的特殊字符"></a>replace第二个参数中的特殊字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>$1,$2,…,$99</td><td>匹配第 1-99 个分组里捕获的文本</td></tr><tr><td>$&amp;</td><td>匹配到的子串文本</td></tr><tr><td>$`</td><td>匹配到的子串的左边文本</td></tr><tr><td>$’</td><td>匹配到的子串的右边文本</td></tr><tr><td>$$</td><td>美元符号</td></tr></tbody></table><h3 id="RegExp相关实例方法"><a href="#RegExp相关实例方法" class="headerlink" title="RegExp相关实例方法"></a>RegExp相关实例方法</h3><table><thead><tr><th>属性</th><th>方法作用说明</th></tr></thead><tbody><tr><td>test</td><td>判断目标字符串中是否有满足正则匹配的子串。返回布尔值。</td></tr><tr><td>exec</td><td>比 match 更强大的正则匹配操作。返回结果与 match 一致。</td></tr></tbody></table><h3 id="RegExp静态属性"><a href="#RegExp静态属性" class="headerlink" title="RegExp静态属性"></a>RegExp静态属性</h3><table><thead><tr><th>属性</th><th>方法作用说明</th></tr></thead><tbody><tr><td>$1,…,$9</td><td>最近一次第 1-9 个分组捕获的数据。</td></tr><tr><td>input</td><td>最近一次目标字符串，可以简写成 $_ 。</td></tr><tr><td>lastMatch</td><td>最近一次匹配的文本，可以简写成 $&amp; 。</td></tr><tr><td>lastParen</td><td>最近一次捕获的文本，可以简写成 $+ 。</td></tr><tr><td>leftContext</td><td>目标字符串中 lastMatch 之前的文本，可以简写成 $` 。</td></tr><tr><td>rightContext</td><td>目标字符串中 lastMatch 之后的文本，可以简写成 $’ 。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>正则</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端缓存——HTTP缓存</title>
    <link href="/2023/03/01/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2023/03/01/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前端缓存——HTTP缓存"><a href="#前端缓存——HTTP缓存" class="headerlink" title="前端缓存——HTTP缓存"></a>前端缓存——HTTP缓存</h1><p>HTTP缓存是一种机制，主要用于客户端与服务器之间的一种数据缓存。HTTP缓存主要通过设置HTTP的 <strong>header</strong> 中的字段来控制，例如 <code>**Cache-Control**</code> 和 <code>**Expires**</code> 等字段。</p><p>HTTP缓存的策略主要有三种：强缓存、协商缓存、启发式缓存（http2.0），但我们主要介绍的是在HTTP1.1的缓存策略 即强缓存、协商缓存。</p><h2 id="一、强缓存"><a href="#一、强缓存" class="headerlink" title="一、强缓存"></a>一、强缓存</h2><h3 id="1-强缓存策略"><a href="#1-强缓存策略" class="headerlink" title="1. 强缓存策略"></a>1. 强缓存策略</h3><p>强缓存是指浏览器在请求资源时，先检查本地缓存中是否有该资源的副本，并且该副本是否过期。如果没有过期，浏览器直接从本地缓存中获取该资源，不会向服务器发送请求，如果过期就向服务器请求。</p><p>通过该流程图来感受下强缓存策略：</p><p><img src="/img/cache1.png"></p><h3 id="2-强缓存优缺点"><a href="#2-强缓存优缺点" class="headerlink" title="2. 强缓存优缺点"></a>2. 强缓存优缺点</h3><p><strong>优点：</strong>减少网络请求，提高页面加载速度</p><p><strong>缺点：</strong>无法<strong>及时</strong>获取最新的资源。因为只是设置了过期时间，但如果在过期时间内资源发生变动，则无法第一时间获取最新时间，只能等到资源超出设置的过期时间，才能获取新的资源。</p><h3 id="3-强缓存控制字段"><a href="#3-强缓存控制字段" class="headerlink" title="3. 强缓存控制字段"></a>3. 强缓存控制字段</h3><p>在浏览器中，控制强缓存的字段有三个：<code>Expires</code>（http1.0规范）、<code>Pragma</code>（http1.0规范，不常用）、<code>cache-control</code>（http1.1规范）3种</p><h3 id="3-1-Expires"><a href="#3-1-Expires" class="headerlink" title="3.1 Expires"></a><strong>3.1 Expires</strong></h3><p><code>Expires</code>是<code>http1.0</code>的规范，用于表示资源的过期时间的请求头字段，值是由服务器端返回的<strong>绝对时间</strong>。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。</p><p>这种方式有一个明显的缺点，由于失效时间是一个绝对时间，由于expires是根据<strong>本地时间</strong>来判断的，假设客户端和服务器时间不同，或者存在误差，会导致缓存命中误差</p><h3 id="3-2-Pragma"><a href="#3-2-Pragma" class="headerlink" title="3.2  Pragma"></a>3.2  <strong><strong>Pragma</strong></strong></h3><p>只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p><h3 id="3-3-Cache-control"><a href="#3-3-Cache-control" class="headerlink" title="3.3 Cache-control"></a>3.3 <strong><strong>Cache-control</strong></strong></h3><p>为了解决expires带来的问题，在<code>http1.1</code>规范中，提出了<code>cache-control</code>字段，且<strong>这个字段优先级高于上面提到的<code>Expires</code><strong>，值是一个</strong>相对时间</strong>。</p><p>在<code>cache-control</code>中有常见的几个响应属性值，它们分别是：</p><table><thead><tr><th>属性值</th><th>备注</th></tr></thead><tbody><tr><td>max-age</td><td>值例如3600，表示（当前时间+3600秒）内不向服务器请求新的数据，最大值为一年</td></tr><tr><td>s-maxage</td><td>和max-age一样，但这个是设定代理服务器的缓存时间</td></tr><tr><td>privite</td><td>内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)</td></tr><tr><td>public</td><td>所有内容都将被缓存(客户端和代理服务器都可缓存)</td></tr><tr><td>no-store</td><td>不缓存任何数据，关闭所有缓存</td></tr><tr><td>no-cache</td><td>关闭强缓存，直接开启强协商缓存</td></tr><tr><td>immutable</td><td>就算过期了也不用协商，资源就是不变的</td></tr><tr><td>max-stale</td><td>过期了一段时间的话，资源也能用。值为毫秒</td></tr><tr><td>stale-while-revalidate</td><td>在验证（协商）期间，返回过期的资源</td></tr><tr><td>stale-if-error</td><td>验证（协商）出错的话，返回过期的资源</td></tr><tr><td>must-revalidate</td><td>不允许过期了还用过期资源，必须等协商结束</td></tr><tr><td>…还有许多不常用的，例如特意给代理服务器配置的</td><td></td></tr></tbody></table><h2 id="二、协商缓存"><a href="#二、协商缓存" class="headerlink" title="二、协商缓存"></a>二、协商缓存</h2><p>协商缓存是指浏览器在请求资源时，先向服务器发送一个请求，询问该资源是否有更新。如果服务器返回的响应状态码为304，表示该资源没有更新，浏览器可以直接从本地缓存中获取该资源。如果服务器返回的响应状态码为200，表示该资源已经更新，浏览器需要重新下载该资源。</p><p>通过该流程图来感受下协商缓存策略：</p><p><img src="/img/cache2.png"></p><h3 id="2-协商缓存优缺点"><a href="#2-协商缓存优缺点" class="headerlink" title="2. 协商缓存优缺点"></a>2. 协商缓存优缺点</h3><p>优点：是可以及时获取最新的资源</p><p>缺点：需要向服务器发送请求，增加了网络请求的次数。</p><h3 id="3-协商缓存控制字段"><a href="#3-协商缓存控制字段" class="headerlink" title="3. 协商缓存控制字段"></a>3. 协商缓存控制字段</h3><p>协商缓存字段是<strong>成对搭配使用</strong>，左边是字段是<strong>第一次</strong>请求资源<strong>响应头返回的字段</strong>，右边字段是接下来第二次<strong>请求头的字段，值为左边字段返回的值（两个字段值是一样的）。</strong></p><h3 id="3-1-Last-modified-if-modified-since"><a href="#3-1-Last-modified-if-modified-since" class="headerlink" title="3.1 Last-modified/if-modified-since"></a>3.1 Last-modified/if-modified-since</h3><p>浏览器第一次请求一个资源时，服务器返回的response header中会加上Last-Modified，Last-Modified是一个时间标识该资源的最后修改时间。</p><p>当浏览器再次请求该资源时，request的请求头中会包含If-Modified-Since，该值为缓存之前返回的Last-Modified。服务器收到If-Modified-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中，返回304，并且不会返回资源内容，并且不会返回Last-Modified。</p><ul><li><code>Last-modified</code>表示<strong>本地文件最后修改时间</strong>，由服务器返回</li><li><code>if-modified-since</code>是浏览器在请求数据时返回的，<strong>值是上次浏览器返回的<code>Last-modified</code></strong></li></ul><p><strong>缺点：</strong></p><ul><li>在没有修改文件内容情况下文件的<code>**Last-modified**</code>时间可能也会改变，这会导致客户端认为这文件被改动了，导致重新请求，从而增加没必要的请求。</li><li>因为<code>Last-Modified</code>只能以秒计时，如果在几毫秒时间内服务器资源发生改变的话，<code>**Last-Modified**</code> 并不会发生变化，这就会导致客户端请求的时候，服务器端还是认为命中缓存，直接用了缓存资源（但其实服务器资源是变化了的，应该请求才对）。</li><li>周期性变化。如果这个资源在一个周期内修改回原来的样子，我们认为是可以使用缓存的，但是使用**<code>Last-Modified</code>**是达不到这个效果的，因此便有了ETag。</li></ul><h3 id="3-2-ETag-if-none-match"><a href="#3-2-ETag-if-none-match" class="headerlink" title="3.2 ETag/if-none-match"></a>3.2 ETag/if-none-match</h3><p>浏览器在下一次请求资源时，会将上一次返回的ETag值放到<strong>响应头</strong>中的 <strong><code>If-none-Match</code> 值里</strong>，服务器只需要比较客户端传来的<code>**If-none-Match**</code>跟自己服务器上该资源的<code>**ETag**</code>值是否一致，如果匹配不上，直接以常规<strong>200状态码</strong>将<strong>最新的资源</strong>和新的<code>**ETag**</code>返回给客户端；如果匹配一致，则直接返回304给客户端直接使用本地缓存即可。</p><p><strong>与<code>Last-Modified</code>不同的是，当服务器返回304 Not Modified 的响应时，虽然<code>Etag</code>值不会改变，但是响应头中还会把<code>ETag</code>值返回，以便下次请求使用。</strong></p><ul><li><code>**ETag**</code>是一个文件的唯一标识符，当资源发生变化时这个<code>ETag</code>就会发生变化，相当于给每个资源版本增加版本号。弥补了<code>**Last-Modified</code>** 上面的三个缺点。这个值也是又服务器返回的</li><li><code>**if-none-match**</code>是浏览器请求数据时带上的字段，值是上次服务器返回的<code>**ETag**</code></li></ul><p><strong>缺点：</strong></p><ul><li>性能上不如 <strong><code>Last-modified/if-modified-since</code> ，</strong>因为在生成Etag的hash值会多出一些额外开销</li></ul><h3 id="3-3-Last-modified-if-modified-since-和-ETag-if-none-match-区别"><a href="#3-3-Last-modified-if-modified-since-和-ETag-if-none-match-区别" class="headerlink" title="3.3 Last-modified/if-modified-since 和 ETag/if-none-match 区别"></a>3.3 Last-modified/if-modified-since 和 ETag/if-none-match 区别</h3><ul><li><strong>精确度上，Etag要优于Last-Modified。</strong><br>Last-Modified的时间单位是秒，如果服务器某个文件在几毫秒内改变了，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次资源改变都会跟着改变，从而确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li><li><strong>性能上，<code>Last-Modified</code> 性能上要优于 <code>Etag</code>  。</strong><br>因为 <code>Etag</code> 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 <code>Last-Modified</code>，只能作为补充和强化</li><li><strong>在优先级上，服务器校验优先考虑Etag。</strong></li></ul><h2 id="三、缓存机制"><a href="#三、缓存机制" class="headerlink" title="三、缓存机制"></a>三、缓存机制</h2><p>强缓存优先于协商缓存进行，若强缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；若是生效则返回304，继续使用缓存。</p><h3 id="1-缓存优先级"><a href="#1-缓存优先级" class="headerlink" title="1. 缓存优先级"></a>1. 缓存优先级</h3><ul><li><strong><strong>强缓存优先于协商缓存</strong></strong></li><li><strong>Cache-control 优先级高于Paragma优先级高于Expires</strong></li><li><strong>ETag/if-none-match 优先级高于 Last-modified/if-modified-since</strong></li></ul><p>所以，**<code>Cache-control</code> -&gt;<code>paragma</code> -&gt;  <code>expires</code>-&gt; <code>ETag/if-none-match</code> -&gt; <code>Last-modified/if-modified-since</code>**</p><aside>💡 “When the Cache-Control header field is also present and understood in a request, Pragma is ignored.” —— **HTTP1.1协议-RFC7234<p>从这句话我们得知Cache-control 优先级高于Paragma优先级<br>【网上文章都是Paragma优先级高于Cache-control 优先级，不知道依据是什么！】**</p></aside><h3 id="2-缓存整体的流程图"><a href="#2-缓存整体的流程图" class="headerlink" title="2. 缓存整体的流程图"></a>2. 缓存整体的流程图</h3><p><img src="/img/cache3.png"></p><p>针对流程图注意几点：</p><ul><li>通过Cache-control：no-cache来关闭强缓存，直接进行协商缓存</li><li>通过Cache-control: no-store来关闭所有缓存，这意味着当客户端看见这个字段，客户端会直接请求服务器资源。</li><li>协商缓存命中时，服务器不会发送新的资源，但不是说客户端和服务器就没有会话了，客户端还是会发请求到服务器的。</li></ul><h2 id="四、缓存位置和优先级"><a href="#四、缓存位置和优先级" class="headerlink" title="四、缓存位置和优先级"></a>四、缓存位置和优先级</h2><h3 id="1、Memory-Cache"><a href="#1、Memory-Cache" class="headerlink" title="1、Memory Cache"></a>1、Memory Cache</h3><p><strong>Memory Cache主要存储在电脑的RAM中（也就是运行内存）。</strong>主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的<strong>样式、脚本、图片</strong>等，占据该进程一定的内存资源，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p><p><strong>内存缓存特点</strong>：①读取速度快 ②时效短，关闭页面进程的内存自动清空</p><h3 id="2、Disk-Cache"><a href="#2、Disk-Cache" class="headerlink" title="2、Disk Cache"></a>2、Disk Cache</h3><p><strong>Disk Cache主要存在我们电脑的磁盘（硬盘）中。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的，绝大部分的缓存都来自 Disk Cache。</p><p>根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p>硬盘缓存比内存缓存读取速度慢，读取需要对硬盘进行I/O操作，会导致重新解析缓存内容，造成读取路的复杂。</p><p><strong>硬盘缓存特点</strong>：①内存大 ②时效性长，关闭页面进程不会自动清除</p><p><strong>Memory Cache 和 Disk Cache 的相同和不同比较</strong></p><table><thead><tr><th></th><th>Memory Cache（内存）</th><th>Disk Cache（硬盘）</th></tr></thead><tbody><tr><td>相同点</td><td>只能存储一些派生类资源文件</td><td>只能存储一些派生类资源文件</td></tr><tr><td>不同点</td><td>退出Tag进程时数据会被清除</td><td>退出Tag进程时数据不会被清除</td></tr><tr><td>存储资源</td><td>一般脚本、图片、字体</td><td>一般非脚本css等</td></tr></tbody></table><p><strong>脚本、图片、非CSS脚本等资源存储选择不同缓存的原因？</strong><br>由于CSS文件加载一次就可以渲染，不会频繁的读取，所以存储在Disk Cache；而JS脚本可能会随时会被执行，存储在Memory Cache，若存储在硬盘中，会因为I/O开销大导致浏览器失去响应。</p><h3 id="3-缓存访问优先级"><a href="#3-缓存访问优先级" class="headerlink" title="3. 缓存访问优先级"></a>3. 缓存访问优先级</h3><p>HTTP在访问资源缓存的优先级，我们也称为<strong>三级缓存原理：</strong></p><p>① 先去内存查找，找到直接加载</p><p>② 内存找不到，硬盘中找，找到直接加载</p><p>③ 硬盘找不到进行网络请求</p><p>④ 请求获取的资源缓存到硬盘和内存</p><h2 id="六、用户操作几种刷新和回车的区别"><a href="#六、用户操作几种刷新和回车的区别" class="headerlink" title="六、用户操作几种刷新和回车的区别"></a>六、用户操作<strong>几种刷新和回车的区别</strong></h2><ul><li>使用 <code>Ctrl+F5</code> 强制刷新页面时，会对本地缓存文件直接过期，然后跳过强缓存和协商缓存，直接请求服务器</li><li>点击刷新或 <code>F5</code> 刷新页面时，对本地缓存文件过期，然后带<code>If-Modifed-Since</code>和<code>If-None-Match</code>发起协商缓存验证新鲜度</li><li>浏览器输入URL回车，浏览器查找 <code>Disk Cache</code>，有则使用，没有则发送网络请求</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8工作原理——垃圾回收机制</title>
    <link href="/2023/02/26/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/02/26/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="V8工作原理——垃圾回收机制"><a href="#V8工作原理——垃圾回收机制" class="headerlink" title="V8工作原理——垃圾回收机制"></a>V8工作原理——垃圾回收机制</h1><p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p><p>如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的</p><p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p><p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p><p>接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p><h2 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;我是b&quot;</span>&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;我是c&quot;</span><br>      <span class="hljs-keyword">var</span> d = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;我是d&quot;</span>&#125;<br>    &#125;<br>    <span class="hljs-title function_">showName</span>()<br>&#125;<br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><p>当代码执行到showName()后，其调用栈和堆空间状态图如下所示：</p><p><img src="/img/V8-recover1.png"></p><p>如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p><p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。如图所示：</p><p><img src="/img/V8-recover2.png"></p><p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p><h2 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a><strong>堆中的数据是如何回收的</strong></h2><p>通过上面的讲解，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示</p><p><img src="/img/V8-recover3.png"></p><p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p><p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，所以根据对象周期不同而使用不同的算法，V8中会把堆分为<strong>新生区</strong>和<strong>老生区</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</strong></p><p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。</li><li>主垃圾回收器，主要负责老生代的垃圾回收。</li></ul><p>首先我们先看一张V8的堆空间结构</p><p><img src="/img/V8-recover4.png"></p><p>V8引擎通过判断JS对象大小来决定它在新生区还是老生区，通常情况下新创建的对象都会放进新生区的对象区域（From区域），如果对象大小超过新生区的对象区域（From区域）大小（约32MB）则被直接放到老生区</p><h3 id="新生区垃圾回收"><a href="#新生区垃圾回收" class="headerlink" title="新生区垃圾回收"></a><strong>新生区垃圾回收</strong></h3><p>新生区里又分为对象区域（From区域）和空闲区域（To区域），对象区域（From区域）负责垃圾回收，空闲区域（To区域）负责垃圾回收后的存活对象的存放和内存整理。</p><ul><li>新加入的对象都会存放到对象区域（From区域），当对象区域（From区域）快被写满时，就需要执行一次垃圾清理操作（Scavenge算法）</li><li>对新生区中的垃圾做标记，副垃圾回收器把存活对象复制到空闲区域并进行内存整理，这样复制后空闲区域就没有内存碎片了</li><li>完成复制后，对象区域与空闲区域进行角色翻转（原来的对象区域（From区域）变成空闲区域（To区域），原来的空闲区域（From区域）变成了对象区域（To区域）），继续执行相同的各自区域做的事情。</li><li>如果对象区域（From区域）和空闲区域（To区域）反转两次之后依然存活的对象，采用对象晋升策略，直接转移到老生区。</li></ul><p>由于新生区空间不大，所以才适用Scavenge算法，通过对象区域和空闲区域反复垃圾回收并复制整理，也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域，所以JavaScript 引擎采用了<strong>对象晋升策略</strong>。</p><h3 id="老生区垃圾回收"><a href="#老生区垃圾回收" class="headerlink" title="老生区垃圾回收"></a><strong>老生区垃圾回收</strong></h3><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点：<strong>一个是对象占用空间大，另一个是对象存活时间长</strong>。</p><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</p><ul><li><p>遍历整个调用栈，查看所有引用类型变量的引用地址对应的堆中对象，将堆中所有可被变量引用的对象标记为活动对象，然后将其他未被标记的对象标记为垃圾数据，并清除垃圾对象如图：</p><p><img src="/img/V8-recover5.png"></p></li><li><p>不过对一块内存多次执行标记 - 清除算法后会产生大量内存碎片，再通过标记-整理算法，标记过程同标记-清除算法一致，找出所有活动对象都向一端移动，然后清理掉边界以外的内存，如图：</p><p><img src="/img/V8-recover6.png"></p></li></ul><p>由于JavaScript运行和垃圾回收都在主线程上，所以一旦进行垃圾回收，整个JS的执行也被暂停，等待垃圾回收结束再恢复JS脚本的执行。这种停顿也叫“全停顿”（Stop-The-World）。</p><p><img src="/img/V8-recover7.png"></p><p>因为新生区结构和针对的垃圾回收对象也就决定在新生区中“全停顿”不会受很多影响，而老生区主要针对大对象所以垃圾回收导致之间也会很长，同时在成页面卡顿。</p><p>为了解决老生区问题V8将标记为为一个个子标记过程，让垃圾回收的标记过程和JS应用逻辑交替执行，直到标记完成，同时这个算法又称之为“<strong>增量标记算法</strong>”（Incremental Marking）。</p><p><img src="/img/V8-recover8.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后将整个垃圾回收过程用流程图展示出来：</p><p><img src="/img/V8-recover9.png"></p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8工作原理——JS中代码时如何存储的</title>
    <link href="/2023/02/23/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94JS%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%97%B6%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <url>/2023/02/23/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94JS%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%97%B6%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="V8工作原理——JS中代码时如何存储的"><a href="#V8工作原理——JS中代码时如何存储的" class="headerlink" title="V8工作原理——JS中代码时如何存储的"></a>V8工作原理——JS中代码时如何存储的</h1><h2 id="一、JavaScript-是什么类型的语言"><a href="#一、JavaScript-是什么类型的语言" class="headerlink" title="一、JavaScript 是什么类型的语言"></a>一、<strong>JavaScript 是什么类型的语言</strong></h2><p>首先，我们的编程语言分为<strong>动态语言、静态语言、弱类型语言、强类型语言</strong>等。</p><p>动态与静态相对，我们在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言，动态类型就是指我们声明变量的时候不需要为该变量声明类型，而是JS在运行时由JS引擎通过变量值来推断变量类型。</p><p>强与弱是相对的，强类型是不允许两个不同类型的变量赋值的，会报错，而弱类型则允许，并且在不同类型变量赋值的时候，被赋值的变量会根据赋值的变量类型而隐性转换。</p><p><img src="/img/V8-stock1.png"></p><p>JS是动态弱类型语言，我们依次解释动态和弱类型的概念</p><p><strong>弱类型，</strong>意味着你可以使用同一个变量保存不同类型的数据</p><p><strong>动态，</strong>意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</p><h2 id="二、JavaScript-的数据类型"><a href="#二、JavaScript-的数据类型" class="headerlink" title="二、JavaScript 的数据类型"></a>二、<strong>JavaScript 的数据类型</strong></h2><ul><li><p>基本类型： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code></p></li><li><p>引用类型Object： <code>Array</code> ，<code>Function</code>， <code>Date</code>， <code>RegExp</code>等</p><p><img src="/img/V8-stock2.png"></p></li></ul><h2 id="三、内存空间模型"><a href="#三、内存空间模型" class="headerlink" title="三、内存空间模型"></a>三、<strong>内存空间模型</strong></h2><p>所以我们来看看JS是如何存储原始类型和引用类型：</p><p>首先我们需要了解JavaScript的内存模型，如图：</p><p><img src="/img/V8-stock3.png"></p><p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p><h2 id="四、栈空间和堆空间"><a href="#四、栈空间和堆空间" class="headerlink" title="四、栈空间和堆空间"></a>四、<strong>栈空间和堆空间</strong></h2><p>我们主要来了解栈空间和堆空间</p><p>栈空间就是我们讲的执行栈，即存储执行上下文的地方。我们看下面代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot; 1111 &quot;</span><br>    <span class="hljs-keyword">var</span> b = a<br>    <span class="hljs-keyword">var</span> c = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot; 2222 &quot;</span>&#125;<br>    <span class="hljs-keyword">var</span> d = c<br>&#125;<br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><p><img src="/img/V8-stock4.png"></p><p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p><p>现在你应该知道了<strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。</strong></p><p><strong>为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</strong></p><p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，<strong>所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率</strong>，进而又影响到整个程序的执行效率。</p><h2 id="五、闭包和堆的关系"><a href="#五、闭包和堆的关系" class="headerlink" title="五、闭包和堆的关系"></a>五、闭包和堆的关系</h2><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> test1 = <span class="hljs-string">&quot;1111&quot;</span><br><span class="hljs-keyword">var</span> test2 = <span class="hljs-string">&quot;2222&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> test1<br>&#125;<br><span class="hljs-keyword">return</span> inner<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br><br><span class="hljs-title function_">bar</span>()<br></code></pre></td></tr></table></figure><ul><li><p>当 JavaScript 引擎执行到 foo()操作时，首先会编译，并创建一个空的foo函数执行上下文。</p></li><li><p>在编译过程中，将test1和test2放到变量环境并赋值，遇到内部函数inner，JavaScript引擎还要对该函数做一次快速的词法分析，发现内部函数inner引用了foo中的变量，所以JS引擎判断这是一个闭包，于是在inner对函数的对地址的引用的函数对象中的[Scopes]属性中创建closure(foo)的变量，里面保存着对foo函数变量的引用即test1的值。</p></li><li><p>如图，这是执行到return inner时，执行栈的情况如图</p><p><img src="/img/V8-stock5.png"></p></li><li><p>当执行完foo函数时，foo的执行上下文变成closure(foo)的执行上下文，里面保存着对foo函数作用域的引用，直到bar调用时，生成inner函数执行上下文，而inner函数里面outer保存着对closure(foo)的引用。</p><p><img src="/img/V8-stock6.png"></p></li></ul><p>通过以上的观察我们总结几点：</p><ol><li>在词法分析阶段闭包函数就生成了，但这时是保存在函数对象的[Scopes]属性中，当后续调用闭包函数会新生一个闭包函数执行上下文。</li><li>闭包函数只有被调用的时候才会产生新的执行上下文，并且是通过outer的地址指向堆中对于函数内部变量的引用。</li></ol><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><ul><li>原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</li><li>在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</li><li>我们还站在内存模型的视角分析了闭包的产生过程</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8工作原理——从底层理解一段代码的运行和它的特性</title>
    <link href="/2023/02/20/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%92%8C%E5%AE%83%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/2023/02/20/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%92%8C%E5%AE%83%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="V8工作原理——从底层理解一段代码的运行和它的特性"><a href="#V8工作原理——从底层理解一段代码的运行和它的特性" class="headerlink" title="V8工作原理——从底层理解一段代码的运行和它的特性"></a>V8工作原理——从底层理解一段代码的运行和它的特性</h1><h2 id="一、编译器和解释器：V8执行JS的基本流程"><a href="#一、编译器和解释器：V8执行JS的基本流程" class="headerlink" title="一、编译器和解释器：V8执行JS的基本流程"></a>一、<strong>编译器和解释器：V8</strong>执行JS的基本流程</h2><p><strong>我们首先介绍下编译器和解释器的概念：</strong></p><p>由于机器不能理解我们写的代码，所以在代码执行前，需要将代码翻译成机器能懂得机器语言。这时，由于语言又分为编译型语言和解释型语言。</p><p>所以编译器就是编译型语言的翻译机，解释器就是解释型语言的翻译机。</p><p>这两种不同语言在“翻译”过程中也是有些许区别：</p><p><img src="/img/V8-exe1.png"></p><p>所以我们知道JS的动态类型的弱类型语言，按照编译方式分类它也属于解释类型语言。</p><p><strong>解释类型语言在编译时就需要我们的解释器来编译</strong>，流程大致为：</p><p><img src="/img/V8-exe2.png"></p><ul><li><strong>词法分析（Tokenizing）</strong>：词法分析器（Lexer）将JavaScript代码转换为一系列Token。</li><li><strong>语法分析（Parsing）</strong>：语法分析器（Parser）将Token序列转换为抽象语法树（AST），在，生成AST的过程中，会判断语法是否正确，同时根据语法结构构建出代码的逻辑结构。</li><li><strong>预处理器（Preprocessor）：</strong>在AST上进行变量声明提升、函数声明提升等操作。</li><li><strong>执行上下文的生成（Execution Context）：</strong>V8会在执行上下文中生成变量环境和词法环境，并将他们连接起来形成作用域链，并将其保存在执行上下文中以便在程序执行时使用。</li><li><strong>字节码生成（Bytecode Generation）</strong>：将语法树转换成字节码。字节码是一种类似于汇编语言的中间代码，它比源代码更加容易执行。</li><li><strong>优化（Optimization）</strong>：V8引擎会通过执行上下文信息对字节码进行优化，以提高代码的执行效率。优化的方式包括内联函数、去除冗余代码等。</li><li><strong>解释执行（Interpreter）：</strong>V8引擎会先使用解释器对字节码进行执行。解释器是一种逐行执行字节码的方式，它可以快速执行代码，但效率较低。</li><li><strong>JIT编译（Just-In-Time Compilation）</strong>：V8引擎会在解释器的基础上，使用TurboFan编译器对热点代码进行JIT编译( 即时编译 )，直接生成机器码，方便下次遇见相同代码可以直接<strong>热点代码是指经常被执行的代码，它们会被优先编译，以提高执行效率。</strong></li><li><strong>优化编译（Optimized Compilation）</strong>：V8引擎会对热点代码进行深度优化，以进一步提高执行效率。</li></ul><p><img src="/img/V8-exe3.png"></p><blockquote><ol><li>token：指的是语法上不可能再分的、最小的单个字符或字符串。例如如下代码：**<code>var myBlog = &quot;Vito&quot;</code>**，这段代码的token就分别为：“var”、”myBlog”、“=”、“Vito”</li></ol></blockquote><ol><li>字节码：它是介于 AST 和机器码之间的一种代码，换句话说字节码就是解释器自己能懂得语言，而如果想要机器也能懂，就需要通过解释器将字节码转换为机器码后才能执行</li><li>热点代码：一段代码被重复执行多次，这种就称为热点代码。</li><li>解释器 Ignition 是点火器的意思。编译器 TurboFan 是涡轮增压的意思。寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</li></ol><blockquote></blockquote><p><strong>疑问：JS为何在执行阶段会有编译器的参与，不应该是解释器来对JS进行执行吗？</strong></p><p>没错，JS是一门解释类型原因，自然它的编辑器肯定也是解释器，原本也是没有编译机来参与的，是因为后期随着时间推移，为了用户的体验，所以通过增加编译器对多次执行的代码块的优化来提升代码编译速度，因此才会有编译器参与。</p><h2 id="二、执行上下文概述"><a href="#二、执行上下文概述" class="headerlink" title="二、执行上下文概述"></a>二、执行上下文概述</h2><p>执行上下文是JavaScript执行一段代码时的运行环境，也可以理解为“容器”，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。</p><p><strong>1.  执行上下文存的类型</strong></p><ul><li>全局执行上下文——全局有且只有一个全局执行上下文，任何不在函数内部的代码都在全局执行上下文中。默认做两件事：1.创建全局window对象；2.设置this的值等于window</li><li>函数执行上下文——每当一个函数被调用，就会为这个函数创建一个函数自己的执行上下文。每当一个新的执行上下文被创建，他会按定义的舜玉执行一系列步骤（后文讨论）。</li><li>Eval 函数执行上下文—— 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 并不经常使用 <code>eval</code>，所以在这里不作讨论。</li></ul><p><strong>2.  执行上下文中的具体结构</strong></p><p>执行上下文一般会包括<strong>变量环境、词法环境、outer指针、This</strong>等内容。如图所示：</p><p><img src="/img/V8-exe4.png"></p><ul><li><strong>词法环境：</strong>它主要用于存储变量标识、函数、对象等各种标识符以及它们的值的<strong>栈结构</strong>，每个词法环境都是由一个<strong>环境记录器</strong>和一个可能的<strong>引用外部词法环境的空值</strong>组成。<ul><li><strong>环境记录器</strong>是存储变量和函数声明的实际位置。</li><li><strong>外部环境的引用</strong>意味着它可以访问其父级词法环境（作用域）。</li></ul></li><li><strong>变量环境：</strong>它是一个特殊的词法环境，所以它具有词法环境所具有的所有组件和结构。</li><li><strong>outer指针：</strong>它指向当前执行上下文所在的<strong>外部执行上下文</strong>，具体来说就是，<strong>指向父级的词法作用域</strong>，所以由它实现了JS的作用域链，以及决定了变量和函数的查找顺序。</li><li><strong>this指针：</strong>它主要用于引用当前执行上下文中的对象，具体作用取决于他在哪里使用，后面会做详细讲解。</li></ul><aside>💡 **那“词法环境”和“变量环境”区别是什么呢？<p>区别1：<strong>变量环境主要负责</strong>var声明的变量<strong>和</strong>具名函数<strong>以及</strong>用var声明的函数表达式**，而词法环境主要负责 <strong>let、const 声明的变量</strong>以及 <strong>let 或 const 声明的函数表达式。</strong></p><p><strong>区别2：</strong>变量环境是<strong>动态</strong>，而词法环境是<strong>静态</strong>的，也就是在函数上下文创建时，JS会把所有var声明的变量汇聚到变量环境中，并赋予初始值 undefinded ,而词法环境是依据代码的静态结构创建的，不会有变量环境这种收集声明变量的动态行为，这也是var变量存在<strong>变量提升</strong>的一个底层原理。</p></aside><p><strong>3. 执行上下文存在什么数据结构里呢？</strong></p><p>答案——<strong>栈结构（先进后出）</strong></p><p>我们一般成这个存储执行上下文的栈结构称之为<strong>执行栈（调用栈）。</strong></p><h2 id="三、执行上下文的创建过程"><a href="#三、执行上下文的创建过程" class="headerlink" title="三、执行上下文的创建过程"></a>三、执行上下文的创建过程</h2><p>当JS引擎第一次遇到脚本，它会创建一个唯一的的<strong>全局执行上下文</strong>处在栈底位置。然后每当发现一个函数调用时，它就会把这个函数的执行上下文推进栈里，后面以此类推。</p><p>引擎会优先执行处在栈顶的函数，当函数执行结束，他就会从执行栈中弹出，然后继续执行当前处在栈顶的函数以此类推。</p><p>通过一个例子来理解下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在first函数执行上下文里&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;还是在first函数执行上下文里&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在second函数执行上下文里&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在全局执行上下文里);</span><br></code></pre></td></tr></table></figure><p><img src="/img/V8-exe5.png"></p><p>当函数执行上述代码时，首先在调用栈中生成全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p><p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>first()</code> 函数的执行上下文。</p><p>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p><h2 id="四、从执行上下文角度看“块级作用域”"><a href="#四、从执行上下文角度看“块级作用域”" class="headerlink" title="四、从执行上下文角度看“块级作用域”"></a>四、从执行上下文角度看“块级作用域”</h2><p>块级作用域主要是依赖词法环境的栈结构来实现，当JS引擎扫描到函数、if语句、for循环等存在大括号包裹的，会把里面用 let 或者 const 声明的变量包裹在一个新的作用域，并推入到词法环境的栈结构里，以此类推。</p><p>在执行代码的时候，如果遇到变量引用，就从词法作用域的栈顶依次查找变量，直到找到该变量或者到达全局作用域为止。</p><p>下面看一段例子来理解下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br>    &#123;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span><br>      <span class="hljs-keyword">var</span> c = <span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> d = <span class="hljs-number">5</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d)<br>&#125;   <br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><ol><li><p>JS引擎进行词法分析和语法分析，首先将所有var声明的变量进行变量提升并赋予初始值undefined，并且扫描到let声明的变量b并将包裹成一个新作用域中并推入词法作用域的栈结构中</p><p><img src="/img/V8-exe6.png"></p></li><li><p>继续扫描，遇到赋值操作就直接赋值，当扫描到大括号时候，生成新的作用域并将里面的对象放入该作用域中，并推入词法作用域的栈中</p><p><img src="/img/V8-exe7.png"></p></li><li><p>扫描结束后，执行上下文如下图所示：</p><p><img src="/img/V8-exe8.png"></p></li><li><p>然后就是代码执行阶段，首先遇到 console.log( a )，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：<strong>沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript引擎，如果没有查找到，那么继续在变量环境中查找。</strong>最终我们找到 a = 1 , 打印结果，后面执行完代码块后，词法作用域里对相应的作用域从栈顶弹出，后面的执行以此类推，最后的打印结果如下：</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// Uncaught ReferenceError: d is not defined</span><br></code></pre></td></tr></table></figure><h2 id="五、从执行上下文角度看-“暂时性死区”和“变量提升”"><a href="#五、从执行上下文角度看-“暂时性死区”和“变量提升”" class="headerlink" title="五、从执行上下文角度看 “暂时性死区”和“变量提升”"></a>五、从执行上下文角度看 “暂时性死区”和“变量提升”</h2><p><strong>由于变量环境的变量和函数声明是代码执行过程中动态创建的，</strong>也就是在函数上下文创建时，JS会把所有var声明的变量汇聚到变量环境中，并赋予初始值 undefinded , 这也就是为什么我们可以在var声明变量前可以使用变量，这个现象也被称为“变量提升”</p><p><strong>由于词法环境式依据代码的静态结构创建的，不是代码执行时候创建的</strong>，不会有变量环境这种收集声明变量的动态行为，所以如果在 let 或者 const 声明的变量之前调用会报”ReferrenceError”的报错。</p><p>例1：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;123&quot;</span> <br><br><span class="hljs-comment">//output：Uncaught ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>这个例子很容易就能看出来，变量没有提升，在变量声明前使用变量，肯定报错。</p><p>那么看下例2：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span><br>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <br>  <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;123456&quot;</span><br>&#125;<br><br><span class="hljs-comment">//output: Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br></code></pre></td></tr></table></figure><p>通常情况下，我们会觉得a 应该根据作用域链向上找然后打印123。很显然没有搞懂执行上下文的编译过程，那么我们画图来理解下报错的原因。</p><p>首先，我们需要理解声明和赋值是两个操作，先进行声明再进行赋值（这里不是指统一声明和统一赋值），具体看以下过程：</p><ol><li><p>扫描所有var声明的变量，并进行变量提升</p><p><img src="/img/V8-exe9.png"></p></li><li><p>进入一个块级作用域，在这个块级作用域中查找所有let或者const变量并进行声明但不赋值</p><p><img src="/img/V8-exe10.png"></p></li><li><p>开始执行块级作用域的代码，遇到console.log( a )，JS引擎首先从词法环境从上到下依次查询，发现a还没有进行赋值，抛出错误： Cannot access ‘a’ before initialization</p></li></ol><p><strong>总结：</strong>一旦进入一个新块级作用域所有变量会<strong>优先使用作用域内部的变量</strong>，<strong>不分在声明前还是后</strong>，所以，在这个作用域中如果存在声明赋值之前使用该变量，就会出现暂时性死区，声明之后使用就不会出现。</p><h2 id="六、从执行上下文的角度看“作用域”和“作用域链”"><a href="#六、从执行上下文的角度看“作用域”和“作用域链”" class="headerlink" title="六、从执行上下文的角度看“作用域”和“作用域链”"></a>六、从执行上下文的角度看“作用域”和“作用域链”</h2><p>首先，要了解作用域链就必须先了解什么是作用域，<strong>作用域也被称之为词法作用域</strong>，它是静态的，也就是说<strong>作用域是在代码定义的时候就已经形成了</strong>，所以作用域是由代码函数中的位置决定的。</p><p>那作用域链，就是将所有作用域连接在一起，它主要是通过执行上下文里的outer实现的，<strong>通过outer指向其父级作用域，以此类推，就实现了作用域的串联，即作用域链。</strong></p><p>通过实例来感受下作用域和作用域链：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;1111&quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot;2222&quot;</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 3333&quot;</span><br>    <span class="hljs-keyword">let</span> test = <span class="hljs-number">2</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> test = <span class="hljs-number">3</span><br>        <span class="hljs-title function_">bar</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;4444&quot;</span><br><span class="hljs-keyword">let</span> myAge = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-number">1</span><br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><ol><li><p>先进行词法分析和语法分析形成该段代码的调用栈中所有执行上下文。</p><p><img src="/img/V8-exe11.png"></p><ol><li>然后我们看由于词法作用域是在代码定义时候就确定，所以函数bar的外部引用outer应该是指向全局执行上下文的词法环境。注意，虽然bar函数是在foo函数内部执行的，但它的词法作用域是不会变的，因此打印test时，test变量的查找顺序如图所示，最后输出1</li></ol><p>我们再来理解下这个过程，<strong>词法作用域是代码没有执行就生成了，跟执行位置没有关系，跟声明位置有关系</strong>，调用栈中执行上下文是调用时产生的，调用栈中的执行上下文的位置是跟它的调用顺序有关系。所以，我们只需要知道函数作用域跟函数执行位置没有关系。</p></li></ol><h2 id="七、从执行上下文看“闭包”"><a href="#七、从执行上下文看“闭包”" class="headerlink" title="七、从执行上下文看“闭包”"></a>七、从执行上下文看“闭包”</h2><p>闭包是指那些引用了另一个函数作用域中变量的函数。通常都是在嵌套函数中实现的，也就是说闭包函数就是指被返回出来的那个函数。如图所示，闭包函数是指inner函数，而不是foo函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> test = <span class="hljs-string">&quot;1111&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> test<br>&#125;<br><span class="hljs-keyword">return</span> inner<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br><span class="hljs-title function_">bar</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> test1 = <span class="hljs-string">&quot;1111&quot;</span><br><span class="hljs-keyword">var</span> test2 = <span class="hljs-string">&quot;2222&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> test1<br>&#125;<br><span class="hljs-keyword">return</span> inner<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br><br><span class="hljs-title function_">bar</span>()<br></code></pre></td></tr></table></figure><p>依旧以上述代码为例，我们看下这段代码的执行栈变化：</p><p><img src="/img/V8-exe12.png"></p><p><img src="/img/V8-exe13.png"></p><p>foo函数执行到return语句时foo函数执行上下文转换成closure(foo)函数执行上下文，执行到bar()生成inner函数执行上下文，里面保存对closure函数的引用。</p><p>注意：闭包函数的表示方法可以写成foo(closure)，代表闭包函数仍可以访问foo函数内部的变量。</p><p>至于闭包函数的回收，当闭包不再被任何变量或函数引用时，它就会被垃圾回收机制回收。如果闭包函数被存储在全局变量中，它就会一直存储到程序结束，除非手动删除变量，或者解除这个外部变量的引用( 赋值为null或者重新赋值 )，如果将一个闭包函数保存在函数的局部变量中，它将在函数执行完毕后被销毁。</p><p>如果闭包引用的变量存在循环引用，即外部变量引用了闭包中的变量，而闭包中的变量又引了外部变量，那么这个闭包就无法被垃圾回收机制回收，直到程序结束或者手动删除这些变量。</p><p>接下来看几个循环引用的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> inner = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  &#125;;<br>  x = &#123; <span class="hljs-attr">inner</span>: inner &#125;;<br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">var</span> closure = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">closure</span>(); <span class="hljs-comment">// 输出 10</span><br>closure.<span class="hljs-title function_">inner</span>(); <span class="hljs-comment">// 输出 10</span><br><span class="hljs-comment">// inner中引用的变量x引用inner导致循环引用</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> inner = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    <span class="hljs-built_in">setTimeout</span>(inner, <span class="hljs-number">1000</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">const</span> inner = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">inner</span>();<span class="hljs-comment">//setTimeout引用inner导致循环引用</span><br></code></pre></td></tr></table></figure><h2 id="八、从执行上下文角度看-“this”"><a href="#八、从执行上下文角度看-“this”" class="headerlink" title="八、从执行上下文角度看 “this”"></a>八、从执行上下文角度看 “this”</h2><p>this 是执行上下文的一个属性，它的值是在函数执行时动态确定的。在执行上下文中，this 的值取决于函数的调用方式。</p><p>如果函数是作为对象的方法调用，this 就指向该对象；如果函数是作为普通函数调用，this 就指向全局对象 window。在箭头函数中，this 的值是在函数定义时确定的，而不是在函数执行时确定的。</p><p>除了函数的调用方式，this 的值还受到函数的执行环境的影响。在严格模式下，this 的值不会自动转换为全局对象，而是保持 undefined。</p><p>接下来具体介绍下this的种类，一个是全局执行上下文中的this、函数执行上下文中的this和eval执行上下文中中的this。</p><p><strong>全局执行上下文中的this</strong></p><p>全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象</p><p><strong>函数执行上下文中的this</strong></p><p>函数种类有普通函数、构造函数、箭头函数。</p><ul><li>普通函数的this都指向它的调用者，没有调用者就默认指向window</li><li>构造函数的this指向它的实例对象</li><li>箭头普函数的this指向定义时的上下文，而不是调用时的上下文，因为箭头函数没有自己的this。</li></ul><p>需要记住一点：<strong>this 的值在函数执行时才会确定，而不是在函数定义时确定。</strong>跟作用域不一样是代码静态时就确认了。因此，如果函数被传递给另一个函数作为参数，this 的值可能会发生变化。为了避免这种情况，可以使用 bind、call 或 apply 方法来显式地指定函数的上下文。</p><p><strong>eval执行上下文中的this</strong></p><p>略</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS模块化</title>
    <link href="/2022/11/28/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/11/28/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h1><h2 id="一、什么是模块化？"><a href="#一、什么是模块化？" class="headerlink" title="一、什么是模块化？"></a>一、什么是模块化？</h2><p>模块化其实是指解决一个复杂问题时 <code>自顶向下逐层把系统划分成若干模块</code>的过程，每个模块完成一个特定的子功能（单一职责），所有的模块按某种方法组装起来，成为一个整体，从而完成整个系统所要求的功能。</p><h2 id="二、早期JS模块化方案"><a href="#二、早期JS模块化方案" class="headerlink" title="二、早期JS模块化方案"></a>二、早期JS模块化方案</h2><h3 id="1-普通函数"><a href="#1-普通函数" class="headerlink" title="1. 普通函数"></a>1. 普通函数</h3><p><strong>全局function模式 : 将不同的功能封装成不同的全局函数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>容易引发命名冲突</li><li>依赖关系难以管理：如果我们引用的当前模块引用了其他模块，就需要将当前模块和它引用的模块都复制到我们需要地方，造成代码冗余。</li><li>模块可重用性差：如果想在项目中引用别的项目中的模块，就需要整个模块复制过来，可重用差，不好维护。</li><li>模块可测试性差：测试成本高，不容易测试。</li></ul><h3 id="2-命名空间（对象）"><a href="#2-命名空间（对象）" class="headerlink" title="2.命名空间（对象）"></a>2.<strong>命名空间（对象）</strong></h3><p>随着代码量的增加，普通函数方式更容易引起命名冲突，所以利用对象的特点，命名空间就被提出。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> myMoudle = &#123; <br><span class="hljs-attr">privite1</span>: <span class="hljs-string">&#x27;privite1&#x27;</span><br><span class="hljs-attr">privite2</span>: <span class="hljs-string">&#x27;privite2&#x27;</span><br><span class="hljs-attr">fn1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a + b + privite1 <br>&#125;<br><span class="hljs-attr">fn2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b - privite2<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点:</strong> 数据不安全(外部可以直接修改模块内部的数据)</p><h3 id="3-立即执行函数（IIFE）"><a href="#3-立即执行函数（IIFE）" class="headerlink" title="3.立即执行函数（IIFE）"></a>3.<strong>立即执行函数（IIFE）</strong></h3><p>命名空间一定程度上解决了全局命名空间上的变量污染问题，但是无法解决代码和数据隔离问题，还是得利用函数，只不过这个函数是立即执行函数IIFE，利用函数闭包的特性来实现私有数据和共享方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> myMoudle = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-keyword">var</span> privite1 = <span class="hljs-string">&#x27;privite1&#x27;</span><br><span class="hljs-keyword">var</span> privite2 = <span class="hljs-string">&#x27;privite2&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a + b + privite1 <br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b - privite2<br>&#125;<br><br><span class="hljs-keyword">return</span> &#123; fn1,fn2&#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>这样也就可以通过<code>myMoudle.fn1()</code> 来获取fn1方法，外部只能调用暴露出来的方法和属性，实现了属性方法私有化。</p><p><strong>缺点:</strong> 如果当前这个模块依赖另一个模块怎么办。</p><p>如果这个模块需要依赖其他模块，就可以通过函数传参的形式传入依赖,也是现代模块化规范的思想来源</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> otherModule = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br><span class="hljs-attr">b</span>:<span class="hljs-number">2</span><br>&#125;<br>&#125;)()<br><br><span class="hljs-keyword">var</span> myMoudle = (<span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) &#123; <br><span class="hljs-keyword">var</span> privite1 = <span class="hljs-string">&#x27;privite1&#x27;</span><br><span class="hljs-keyword">var</span> privite2 = <span class="hljs-string">&#x27;privite2&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a + b + privite1 + other.<span class="hljs-property">a</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b - privite2 - other.<span class="hljs-property">b</span><br>&#125;<br><br><span class="hljs-keyword">return</span> &#123; fn1,fn2&#125;<br>&#125;)(otherModule)<br></code></pre></td></tr></table></figure><h3 id="4-依赖注入"><a href="#4-依赖注入" class="headerlink" title="4.依赖注入"></a>4.依赖注入</h3><p>我们先看下例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 模块fnA</span><br><span class="hljs-keyword">let</span> fnA = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;我是fnA&#x27;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 模块fnB</span><br><span class="hljs-keyword">let</span> fnB = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;我是fnB&#x27;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 模块fnC 其中依赖fnA和fnB模块</span><br><span class="hljs-keyword">let</span> fnC = <span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, fnB</span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">fnA</span>()<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">fnB</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这样的代码无论从哪个角度看都很不灵活，我们不知道这段代码中有哪些依赖，也不能对引入的依赖进行二次修改，因为会造成原函数的更改。</p><p>我们来简单实现一个依赖注册器，我们新建一个 <code>injector</code> 对象，它是独立的，以便它能够在我们应用的各个部分都拥有同样的功能。如果我们在很多地方都调用了函数 <code>fnC</code>，后面突然有需求需要调用第三个依赖项我们不可能去修改fnC模块的传参。</p><p>所以我们需要解决下面问题：</p><ul><li>可以实现依赖的注册</li><li>依赖注入器应该可以接收依赖（函数等），注入成功后给我们返回一个可以获取所有资源的函数</li><li>依赖注入器要能够保持传递函数的作用域</li><li>传递的函数能够接收自定义的参数，而不仅仅是被描述的依赖项</li></ul><p>我们来简单实现一个依赖注册器，我们新建一个 <code>injector</code><br> 对象，它是独立的，以便它能够在我们应用的各个部分都拥有同样的功能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-keyword">let</span> injector = &#123;<br>  <span class="hljs-attr">dependencies</span>: &#123;&#125;,<br>  <span class="hljs-attr">register</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span>[key] = value;<br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">deps, func, scope</span>) &#123;<br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; deps.<span class="hljs-property">length</span>, d = deps[i]; i++) &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span>[d]) &#123;<br>        <span class="hljs-comment">// 存在此依赖</span><br>        args.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span>[d]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不存在</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;不存在依赖：&#x27;</span> + d);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      func.<span class="hljs-title function_">apply</span>(scope || &#123;&#125;, args.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>)));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个对象非常简单，只有三个属性，<code>dependencies</code> 用来保存依赖，<code>register</code> 用来添加依赖，最后的 <code>resolve</code> 用来注入依赖。</p><p><code>resolve</code> 函数需要做的事情很简单，先检查 <code>deps</code> 数组，然后在 <code>dependencies</code> 对象种寻找依赖，依次添加至 <code>args</code> 数组中，<code>scope</code> 参数存在则指定其作用域，返回的函数中将其参数使用 <code>.apply</code> 的方法传入我们传递回去的 <code>func</code> 回调。</p><p>再来看看使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 添加</span><br>injector.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;fnA&#x27;</span>, fnA)<br>injector.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;fnB&#x27;</span>, fnB)<br><br><span class="hljs-comment">// 注入1</span><br>(injector.<span class="hljs-title function_">resolve</span>([<span class="hljs-string">&#x27;fnA&#x27;</span>, <span class="hljs-string">&#x27;fnB&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, fnB</span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">fnA</span>()<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">fnB</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>&#125;))()<br><br><span class="hljs-comment">// 注入2：注入时传入额外参数</span><br>(injector.<span class="hljs-title function_">resolve</span>([<span class="hljs-string">&#x27;fnA&#x27;</span>, <span class="hljs-string">&#x27;fnB&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, fnB, str</span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">fnA</span>()<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">fnB</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, str)<br>&#125;))(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>由此，我们实现了一个简单的依赖注入，依赖注入并不是一个新的东西，它在其他语言中存在已久，它是一种设计模式，也可以说是一种风格。</p><p>早期的模块化演变过程中还有很多方案，就不一一写了。我们所说的模块化方案，并不是相互独立的，每种方案之间可能相互借鉴，就像依赖注入这种方式也用到了 <code>IIFE</code> ，一个好的模块化方案，无非就像是解决我们上面依赖注入提出的几个问题一样解决实际问题而存在。</p><h2 id="三、现代JS模块化规范演进"><a href="#三、现代JS模块化规范演进" class="headerlink" title="三、现代JS模块化规范演进"></a>三、现代<strong>JS模块化规范演进</strong></h2><h3 id="1-CommonJs规范"><a href="#1-CommonJs规范" class="headerlink" title="1. CommonJs规范"></a>1. CommonJs规范</h3><p>CommonJS规范是Node.js采用的模块化规范，它的主要特点是<strong>同步加载模块</strong>，模块的输出值是<strong>被缓存的</strong>，<strong>多次加载同一个模块，只会执行一次</strong>，然后直接从缓存中读取，如果缓存模块发生变化，<strong>模块值并不能实时更新。</strong>CommonJS规范适用于<strong>服务器端</strong>，因为服务器端的模块文件都存放在本地磁盘，加载速度比较快，同步加载不会对性能造成太大影响。</p><h3 id="2-AMD规范-Asynchronous-Module-Definition"><a href="#2-AMD规范-Asynchronous-Module-Definition" class="headerlink" title="2. AMD规范**(Asynchronous Module Definition)**"></a>2. AMD规范**(Asynchronous Module Definition)**</h3><p>AMD是RequireJS采用的模块化规范，它的主要特点是<strong>异步加载模块</strong>，<strong>推崇依赖前置，模块在一开始就会加载。</strong>模块的加载不影响后面语句的执行，模块的输出值<strong>不是被缓存的</strong>，<strong>每次加载都会执行一次。</strong>AMD规范适用于<strong>浏览器端</strong>，因为浏览器端的模块文件都存放在服务器上，加载速度比较慢，异步加载可以提高页面加载速度。</p><p>优势：目前绝大多数第三方库都支持AMD规范</p><p>缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况</p><h3 id="3-CMD规范-Common-Module-Definition"><a href="#3-CMD规范-Common-Module-Definition" class="headerlink" title="3. CMD规范**(Common Module Definition)**"></a>3. CMD规范**(Common Module Definition)**</h3><p>CMD是SeaJS采用的模块化规范，它的主要特点是<strong>延迟执行，推崇依赖就近，</strong>与AMD不同的是，CMD是在需要<strong>使用模块的时候才加载</strong>。模块的加载不影响后面语句的执行，模块的输出值<strong>是被缓存的</strong>，<strong>多次加载同一个模块，只会执行一次</strong>，然后直接从缓存中读取，<strong>如果缓存模块发生变化，模块值并不能实时更新。</strong>CMD规范适用于<strong>浏览器端</strong>，因为浏览器端的模块文件都存放在服务器上，加载速度比较慢，延迟执行可以提高页面加载速度。</p><h3 id="4-ES-Module规范"><a href="#4-ES-Module规范" class="headerlink" title="4. ES Module规范"></a>4. <strong>ES Module规范</strong></h3><p>ES Module是它是JavaScript官方的模块化规范。它的主要特点是<strong>既支持同步也支持异步加载模块，</strong></p><p>使用<code>**import**</code>语句就是同步加载模块而且这些同步模块会被ESModule静态绑定，使用<code>**import()**</code>函数就是异步加载模块，这些异步模块会被ESModule动态绑定。模块的输出值是<strong>会被缓存的，多次加载同一个模块，只会执行一次，然后直接从缓存中读取</strong>，如果模块的值发生变化，由于ESModule输出的是一个值的引用，<strong>即使模块被缓存了，ESModule依然可以实时更新缓存的值。</strong>而且ESModule是静态编译，在代码执行前就确认了模块依赖关系，可以进行静态优化和分析，所以ESModule也拥有更好的性能，并且ESModule同样适用于<strong>浏览器</strong>也适用于<strong>服务端。</strong></p><h3 id="5-区别对比"><a href="#5-区别对比" class="headerlink" title="5. 区别对比"></a>5. 区别对比</h3><table><thead><tr><th></th><th>CommonJS</th><th>AMD</th><th>CMD</th><th>ESMoudle</th></tr></thead><tbody><tr><td>适用环境</td><td>服务端</td><td>浏览器端</td><td>浏览器端</td><td>服务器端、浏览器端</td></tr><tr><td>执行方式</td><td>同步</td><td>异步</td><td>异步</td><td>同步、异步</td></tr><tr><td>模块是否缓存</td><td>缓存</td><td>不缓存</td><td>缓存</td><td>缓存</td></tr><tr><td>是否实时更新</td><td>不实时更新</td><td>不实时更新</td><td>不实时更新</td><td>实时更新</td></tr><tr><td>加载方式</td><td>运行时加载</td><td>运行时加载</td><td>运行时加载</td><td>静态加载、运行时加载（动态绑定时）</td></tr><tr><td>模块输出类型</td><td>值的拷贝</td><td>值的拷贝</td><td>值的拷贝</td><td>值的引用</td></tr><tr><td>导入模块</td><td>require()</td><td>require()</td><td>require()</td><td>import</td></tr><tr><td>导出模块</td><td>module.exports = value/ exports.xxx = value</td><td>return</td><td>module.exports = value/ exports.xxx = value</td><td>export / export default</td></tr><tr><td>定义模块</td><td>不需要定义</td><td>define()</td><td>define()</td><td>不需要定义</td></tr></tbody></table><h2 id="四、-ES6-模块与-CommonJS-模块的差异"><a href="#四、-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="四、 ES6 模块与 CommonJS 模块的差异"></a>四、 ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次掌握JS中的this</title>
    <link href="/2022/11/21/%E4%B8%80%E6%AC%A1%E6%8E%8C%E6%8F%A1JS%E4%B8%AD%E7%9A%84this/"/>
    <url>/2022/11/21/%E4%B8%80%E6%AC%A1%E6%8E%8C%E6%8F%A1JS%E4%B8%AD%E7%9A%84this/</url>
    
    <content type="html"><![CDATA[<h1 id="一次掌握JS中的this"><a href="#一次掌握JS中的this" class="headerlink" title="一次掌握JS中的this"></a>一次掌握JS中的this</h1><h2 id="一、this指向问题"><a href="#一、this指向问题" class="headerlink" title="一、this指向问题"></a>一、this指向问题</h2><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>this是在运行时绑定的，不是在编写时绑定，也就是运行才能知道this指向谁</li><li><strong>this指向永远是其调用者</strong>（除了箭头函数它没有自己的this）</li><li><strong>箭头函数没有自己的this</strong>，所以箭头函数this指的是他所在最近作用域的this</li><li><strong>全局直接调用，this就指的全局的根对象</strong>，在浏览器环境中全局对象是 Window，在 Node.js 环境中是 Global。</li><li><strong>当使用 new 关键字调用函数时，函数中的 this 一定是 JS 创建的新对象。</strong></li><li>当函数使用<code>apply、call、bind</code>调用时，<strong>this指向它们的一个参数</strong>，但是bind比较特殊，他改变this指向后并不像apply、call一样立即执行，它会返回一个<strong>一个永久改变<code>this</code>指向的函数。</strong></li></ul><blockquote><p><strong>注意</strong>：一旦函数通过bind绑定了有效的this对象，那么在函数执行过程中this会指向该对象，即使使用call、apply也不能改变this的指向</p></blockquote><h3 id="方法论："><a href="#方法论：" class="headerlink" title="方法论："></a>方法论：</h3><ol><li>观察this中所在函数执行的调用者（前提不是通过bind、call、apply调用执行），那么this即指向这个调用者</li><li>当函数使用apply、call、bind调用时，this指向它们的一个参数</li></ol><h3 id="常考场景："><a href="#常考场景：" class="headerlink" title="常考场景："></a>常考场景：</h3><ol><li>对象中的方法</li><li>事件绑定</li><li>构造函数</li><li>定时器</li><li>函数对象的<code>call()、apply()、bind()</code> 方法</li></ol><h3 id="QS1：为什么构造函数中this是指向创建的新对象，不是指向运行时的调用对象吗？"><a href="#QS1：为什么构造函数中this是指向创建的新对象，不是指向运行时的调用对象吗？" class="headerlink" title="QS1：为什么构造函数中this是指向创建的新对象，不是指向运行时的调用对象吗？"></a>QS1：<strong>为什么构造函数中this是指向创建的新对象，不是指向运行时的调用对象吗？</strong></h3><p>首先看下简单new的源码， <code>fn.apply(obj, args)</code>  new会将构造函数fn的this绑定到新生成obj的实例上，所以构造函数中的this指向创建的新对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br><br>    obj.<span class="hljs-property">__proto__</span> = fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br>    fn.<span class="hljs-title function_">apply</span>(obj, args)<br><br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QS2-为什么全局调用，this就指向其全局对象？"><a href="#QS2-为什么全局调用，this就指向其全局对象？" class="headerlink" title="QS2:为什么全局调用，this就指向其全局对象？"></a>QS2:<strong>为什么全局调用，this就指向其全局对象？</strong></h3><p>这其实是隐式调用，在浏览器中直接调用fn()等效于Window.fn()，所以浏览器中直接调用this指向Window，node环境同理</p><h2 id="二、改变this指向call-、bind-、apply"><a href="#二、改变this指向call-、bind-、apply" class="headerlink" title="二、改变this指向call()、bind()、apply()"></a>二、改变this指向<code>call()、bind()、apply()</code></h2><h3 id="1-apply"><a href="#1-apply" class="headerlink" title="1. apply()"></a>1. <strong>apply()</strong></h3><p><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p><p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span>&#123;<br>    console.log(<span class="hljs-keyword">this</span>,args);<br>&#125;<br>let obj = &#123;<br>    myname:<span class="hljs-string">&quot;张三&quot;</span><br>&#125;<br><br>fn.apply(obj,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]); <span class="hljs-comment">// this会变成传入的obj，传入的参数必须是一个数组；</span><br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// this指向window</span><br><br></code></pre></td></tr></table></figure><p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">fn.apply(<span class="hljs-literal">null</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]); <span class="hljs-comment">// this指向window</span><br>fn.apply(<span class="hljs-literal">undefined</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]); <span class="hljs-comment">// this指向window</span><br></code></pre></td></tr></table></figure><h3 id="2-call"><a href="#2-call" class="headerlink" title="2. call()"></a>2. call()</h3><p><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表</p><p>跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span>&#123;<br>    console.log(<span class="hljs-keyword">this</span>,args);<br>&#125;<br>let obj = &#123;<br>    myname:<span class="hljs-string">&quot;张三&quot;</span><br>&#125;<br><br>fn.call(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// this会变成传入的obj，传入的参数必须是一个数组；</span><br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// this指向window</span><br><br></code></pre></td></tr></table></figure><p>同样的，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]); <span class="hljs-comment">// this指向window</span><br>fn.<span class="hljs-keyword">call</span>(undefined,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]); <span class="hljs-comment">// this指向window</span><br><br></code></pre></td></tr></table></figure><h3 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. <strong>bind()</strong></h3><p>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p><p><strong>改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span>&#123;<br>    console.log(<span class="hljs-keyword">this</span>,args);<br>&#125;<br>let obj = &#123;<br>    myname:<span class="hljs-string">&quot;张三&quot;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> bindFn = fn.bind(obj); <span class="hljs-comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span><br>bindFn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// this指向obj</span><br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// this指向window</span><br><br></code></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从上面可以看到，<code>apply</code>、<code>call</code>、<code>bind</code>三者的区别在于：</p><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定<code>this</code>之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h2 id="三、源码实现"><a href="#三、源码实现" class="headerlink" title="三、源码实现"></a>三、源码实现</h2><h3 id="1-实现call"><a href="#1-实现call" class="headerlink" title="1. 实现call()"></a>1. 实现call()</h3><ul><li>将函数设为对象的属性</li><li>执行和删除这个函数</li><li>指定<code>this</code>到函数并传入给定参数执行函数</li><li>如果不传入参数，默认指向 <code>window</code></li><li>原生<code>call</code>、<code>apply</code>传入的<code>this</code>如果是值类型，会被<code>new Object</code>，如<code>fn.call(&#39;abc&#39;)</code></li></ul><p>整体实现代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context = <span class="hljs-variable language_">window</span>, ...args</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context !== <span class="hljs-string">&#x27;object&#x27;</span>) context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(context) <span class="hljs-comment">// 值类型，变为对象</span><br><br>  <span class="hljs-comment">// args 传递过来的参数</span><br>  <span class="hljs-comment">// this 表示调用call的函数fn</span><br>  <span class="hljs-comment">// context 是call传入的this</span><br><br>  <span class="hljs-comment">// 在context上加一个唯一值，不会出现属性名称的覆盖</span><br>  <span class="hljs-keyword">let</span> fnKey = <span class="hljs-title class_">Symbol</span>()<br>  <span class="hljs-comment">// 相等于 obj[fnKey] = fn </span><br>  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this 就是当前的函数</span><br>  <br>  <span class="hljs-comment">// 绑定了this</span><br>  <span class="hljs-keyword">let</span> result = context[fnKey](...args);<span class="hljs-comment">// 相当于 obj.fn()执行 fn内部this指向context(obj)</span><br><br>  <span class="hljs-comment">// 清理掉 fn ，防止污染（即清掉obj上的fnKey属性）</span><br>  <span class="hljs-keyword">delete</span> context[fnKey];<br><br>  <span class="hljs-comment">// 返回结果 </span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-实现bind"><a href="#2-实现bind" class="headerlink" title="2. 实现bind()"></a>2. 实现bind()</h3><ul><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式<ul><li>通过直接调用的方式，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来</li><li>通过 <code>new</code> 的方式，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li></ul></li><li>箭头函数的底层是<code>bind</code>，无法改变<code>this</code>，只能改变参数</li></ul><p>整体实现代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context = <span class="hljs-variable language_">window</span>, ...args</span>) &#123;<br>  <span class="hljs-comment">// context 是 bind 传入的 this</span><br>  <span class="hljs-comment">// args 是 bind 传入的各个参数</span><br>  <span class="hljs-comment">// this表示调用bind的函数</span><br>  <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// fn.bind(obj) self就是fn</span><br><br>  <span class="hljs-comment">//返回了一个函数，...innerArgs为实际调用时传入的参数</span><br>  <span class="hljs-keyword">let</span> fBound = <span class="hljs-keyword">function</span>(<span class="hljs-params">...innerArgs</span>) &#123; <br>      <span class="hljs-comment">//this instanceof fBound为true表示构造函数的情况。如new func.bind(obj)</span><br>      <span class="hljs-comment">// 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值</span><br>      <span class="hljs-comment">// 当作为普通函数时，this 默认指向 window，此时结果为 false，将绑定函数的 this 指向 context</span><br>      <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>( <span class="hljs-comment">// 函数执行</span><br>        <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fBound ? <span class="hljs-variable language_">this</span> : context, <br>        args.<span class="hljs-title function_">concat</span>(innerArgs) <span class="hljs-comment">// 拼接参数</span><br>      );<br>  &#125;<br><br>  <span class="hljs-comment">// 如果绑定的是构造函数，那么需要继承构造函数原型属性和方法：保证原函数的原型对象上的属性不丢失</span><br>  <span class="hljs-comment">// 实现继承的方式: 使用Object.create</span><br>  fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-keyword">return</span> fBound;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现apply"><a href="#3-实现apply" class="headerlink" title="3. 实现apply()"></a>3. <strong>实现apply()</strong></h3><p>思路: 利用<code>this</code>的上下文特性。<code>apply</code>其实就是改一下参数的问题</p><p>整体实现代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context = <span class="hljs-variable language_">window</span>, args</span>) &#123;  <span class="hljs-comment">// 这里传参和call传参不一样</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context !== <span class="hljs-string">&#x27;object&#x27;</span>) context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(context) <span class="hljs-comment">// 值类型，变为对象</span><br><br>  <span class="hljs-comment">// args 传递过来的参数</span><br>  <span class="hljs-comment">// this 表示调用call的函数</span><br>  <span class="hljs-comment">// context 是apply传入的this</span><br><br>  <span class="hljs-comment">// 在context上加一个唯一值，不会出现属性名称的覆盖</span><br>  <span class="hljs-keyword">let</span> fnKey = <span class="hljs-title class_">Symbol</span>()<br>  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this 就是当前的函数</span><br><br>  <span class="hljs-comment">// 绑定了this</span><br>  <span class="hljs-keyword">let</span> result = context[fnKey](...args);<br><br>  <span class="hljs-comment">// 清理掉 fn ，防止污染</span><br>  <span class="hljs-keyword">delete</span> context[fnKey];<br><br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环</title>
    <link href="/2022/11/20/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/11/20/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="一、为什么会出现Event-Loop"><a href="#一、为什么会出现Event-Loop" class="headerlink" title="一、为什么会出现Event Loop"></a>一、为什么会出现Event Loop</h2><p>总所周知JS是一门<strong>单线程</strong>的<strong>非阻塞</strong>脚本语言，Event Loop就是为了解决JS异步编程的一种解决方案。</p><p><strong>JS为什么是单线程语言?</strong></p><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂事件循环的同步问题。</p><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="二、浏览器中的EventLoop"><a href="#二、浏览器中的EventLoop" class="headerlink" title="二、浏览器中的EventLoop"></a>二、浏览器中的EventLoop</h2><p>在事件循环中任务有很多种，如果按照<strong>执行方式</strong>划分：同步任务、异步任务；如果按照<strong>发起方式</strong>划分：宏任务、微任务。</p><ul><li><strong>同步任务：</strong>可以立即执行的任务，同步任务会阻塞代码的执行，只有当前面任务执行完毕后才能执行下一个任务。</li><li><strong>异步任务：</strong>指在程序执行过程中，代码不按照顺序依次执行，而是在后台执行，当任务完成后，会通知主线程执行回调函数。异步任务不会阻塞代码的执行。</li><li><strong>宏任务：通过事件循环调度的任务，</strong>通常是由用户交互或者其他浏览器事件触发的，也就是浏览器自己创建的任务</li><li><strong>微任务：通过事件循环调度的任务，</strong>通常指在执行代码过程（宏任务）中被创建出的任务。</li></ul><h3 id="宏任务有哪些"><a href="#宏任务有哪些" class="headerlink" title="宏任务有哪些?"></a>宏任务有哪些?</h3><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code>（Node环境）</li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code> （浏览器环境）</li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul><h3 id="微任务有哪些"><a href="#微任务有哪些" class="headerlink" title="微任务有哪些?"></a>微任务有哪些?</h3><ul><li><code>promise.then</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li><li><code>process.nextTick</code> ( Node环境 )</li></ul><aside>💡 **现在网上关于script代码算不算进宏任务有争议**，但这个对于最终执行结果没有影响，只是对于宏任务定义不同而已。<ol><li>如果script代码算进宏任务，那么优先级就是先宏任务再执行微任务，宏任务一定是属于异步任务。</li></ol><p>2.如果script代码不算进宏任务，那么优先级就是先微任务再执行宏任务，宏任务可能为同步任务也有可能为异步任务。</p><p>但是，我们通常认为，script代码是在主线程直接执行的，不需要事件循环调度，不符合宏任务定义，所以会把script代码认为是同步任务，而不是宏任务。</p></aside><h3 id="浏览器事件循环的流程："><a href="#浏览器事件循环的流程：" class="headerlink" title="浏览器事件循环的流程："></a>浏览器事件循环的流程：</h3><p><img src="/img/event-loop1.webp"></p><ol><li>主体代码（第一次事件循环开始，所有的script代码）直接在主线程执行</li><li>在主体代码执行过程中，如果遇到宏任务就在宏任务的<code>Event Table</code> 注册并放进宏任务的 <code>Event Queue( 队列 )</code>中；如果遇到微任务就在微任务的<code>Event Table</code> 注册并放进微任务的 <code>Event Queue(队列)</code> 中</li><li>当主体代码执行结束，立刻执行微任务的 <code>Event Queue( 队列 )</code> 中<strong>所有微任务</strong>并按照<strong>先进先出</strong>的原则。</li><li>当微任务执行结束后，从宏任务的 <code>Event Queue( 队列 )</code> <strong>出队一个宏任务执行</strong>，如果里面再遇到宏任务或者微任务，同主体代码一样，循环往复，直到所有队列中的任务都执行结束。</li></ol><p>例题1</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">async1</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise3&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise4&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 打印操作</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><span class="hljs-comment">//script start ——&gt; async1 start ——&gt; promise1 ——&gt; promise3 ——&gt; script end ——&gt; promise2 ——&gt; async1 end ——&gt; promise4 ——&gt; setTimeout</span><br></code></pre></td></tr></table></figure><ul><li>首先开始全局下的同步代码，依次输出 script start, async1 start, promise1, promise3, script end。其中 <code>await async2();</code>，<code>async2()</code>中<code>.then()</code>的代码先进入到<code>promise</code>的微任务队列，<code>await async2();</code>后面的代码再进入到<code>promise</code>的任务队列，<code>console.log(&#39;promise4&#39;);</code>最后进入到 <code>promise</code>的任务队列。</li><li>全局下的同步代码结束，<strong>紧接着就执行刚才同步代码所产生的所有的微任务</strong>，promise 的微任务队列中按照队列的先进先出原则依次输出，promise2，async1 end，promise4。</li><li>全局微任务结束，开始下一轮的宏任务<code>setTimeout</code>，最终输出 <code>setTimeout</code>。</li></ul><p>例题2：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout1&#x27;</span>)<span class="hljs-comment">// 这一部分代码会放入到 promise 的微任务队列中。</span><br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout2&#x27;</span>)<br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout3&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">async1</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><span class="hljs-comment">// script start ——&gt; async1 start ——&gt; promise1 ——&gt; script end ——&gt; promise2 ——&gt; setTimeout3 ——&gt; setTimeout2 ——&gt; setTimeout1</span><br></code></pre></td></tr></table></figure><ul><li>全局下的同步代码执行完成后，开始执行异步任务的所有微任务<code>.then()</code>中的代码</li><li>最后开始下一轮宏任务的执行，由于微任务队列没有任务了，直接下一轮宏任务是 <code>setTimeout3</code>先执行，因为是<code>setTimeout3</code>先加入下一个宏任务队列中的，再依次加入<code>setTimeout2, setTimeout1</code>到宏任务队列。所以输出的结果是<code>setTimeout3, setTimeout2, setTimeout1</code></li></ul><p><strong>注意：</strong></p><p><code>async</code>函数在本质上也是异步函数，所以在执行<code>async</code>函数时，里面的<code>await</code><strong>下面的函数</strong>才是微任务，等效于<code>Promise</code>的<code>.then</code>，而<code>await</code><strong>右边的函数</strong>则是同步的。</p><p><strong>例2中，执行aync1函数时，遇到await，此时并不是直接把async2放到微任务队列中，而是继续执行async2函数里面代码，如果遇到宏任务或者微任务直接放到对应队列中，并跳出async2函数，将await下面下面代码放进微任务队列中。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的类型的显式和隐式转换</title>
    <link href="/2022/11/01/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%BE%E5%BC%8F%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/11/01/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%BE%E5%BC%8F%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="JS的类型的显式和隐式转换"><a href="#JS的类型的显式和隐式转换" class="headerlink" title="JS的类型的显式和隐式转换"></a>JS的类型的显式和隐式转换</h1><h1 id="一、显式转换"><a href="#一、显式转换" class="headerlink" title="一、显式转换"></a>一、显式转换</h1><p>1.转字符串方法：toString(radix)、String(mix)</p><p>2.转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)</p><p>3.转换为布尔类型：Boolean(mix)</p><p><img src="/img/convert-table.png"></p><h1 id="二、隐式转换"><a href="#二、隐式转换" class="headerlink" title="二、隐式转换"></a>二、隐式转换</h1><p>在隐形转换的每个规则的<strong>前提都是先转换引用类型为原始类型</strong>，再进行原始类型之间的转换</p><h2 id="引用类型的隐式转换规则"><a href="#引用类型的隐式转换规则" class="headerlink" title="引用类型的隐式转换规则"></a>引用类型的隐式转换规则</h2><h3 id="1-ToPrimitive规则"><a href="#1-ToPrimitive规则" class="headerlink" title="1. ToPrimitive规则"></a>1. ToPrimitive规则</h3><p>⭐️ToPrimitive规则，是引用类型向原始类型转变的规则，它是js内部一个函数，形式如下：toPrimitive( input,  preferedType )</p><ul><li><strong>input是指输入的值；preferedType指的是期望转化的类型</strong></li><li><strong>preferedType有两种：1、Number；2、String</strong></li><li><strong>preferedType = Number 则优先调用valueOf()方法，如果转为原始类型了就返回，否则，再调用toString()方法，直到为原始类型为止</strong></li><li><strong>preferedType = String 则优先调用toString()方法，如果转为原始类型了就返回，否则，再调用valueOf()方法，直到为原始类型为止</strong></li></ul><p>⭐️<strong>何时preferedType：Number：几乎所有引用类型（包括两个引用类型相加等）在转换原始类型时preferedType：Number</strong></p><p>⭐️<strong>何时preferedType: String：在字符串拼接时、单个变量的逻辑判断时</strong></p><h3 id="2-valueOf-与-toString"><a href="#2-valueOf-与-toString" class="headerlink" title="2. valueOf()与 toString()"></a>2. <code>valueOf()</code>与 <code>toString()</code></h3><p>下面表格中的<code>Date</code>、<code>Number</code>、<code>String</code>等都<strong>表示对象，而不是类型。</strong></p><p>所有对象优先使用自己的<code>valueOf</code>和<code>toString</code>，如果对象没有自己的<code>valueOf</code>或者<code>toString</code>将使用<code>Object.prototype</code>上的<code>valueOf</code>和<code>toString</code></p><p><strong>valueOf()方法：返回指定对象的原始值。</strong></p><table><thead><tr><th>类型</th><th>返回值</th><th>例子</th></tr></thead><tbody><tr><td>Array</td><td>数组本身</td><td>new Array(1,2,3) 结果[1,2,3]，调用valueOf后结果[1,2,3]</td></tr><tr><td>Boolean</td><td>Boolean 值。</td><td>new Boolean(111)结果Boolean {true} ,调用valueOf后结果true</td></tr><tr><td>Date</td><td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 。</td><td>new Date() 结果 Thu Dec 01 2022 00:00:00 GMT+0800 (新加坡标准时间)，调用valueOf结果1669824000000</td></tr><tr><td>Function</td><td>函数本身。</td><td>function fn(){}的valueOf结果function fn(){}</td></tr><tr><td>Number</td><td>数字值。</td><td>new Number(11)的结果Number {11}，调用valueOf的结果11</td></tr><tr><td>String</td><td>字符串值。</td><td>new String(‘哈哈’)的结果String {‘哈哈’}，调用valueOf的结果’哈哈’</td></tr><tr><td>Object</td><td>对象本身。这是默认情况。</td><td>new Object()的结果{}，调用valueOf的结果{}</td></tr></tbody></table><p><strong>toString()方法：返回对象的字符串表示。</strong></p><table><thead><tr><th>类型</th><th>操作</th><th>例子</th></tr></thead><tbody><tr><td>Array</td><td>将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。</td><td>new Array(1,2,3) 结果[1,2,3]，调用toString后结果 ‘1,2,3’</td></tr><tr><td>Boolean</td><td>如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。</td><td>new Boolean(111)结果Boolean {true} ,调用valueOf后结果’true’</td></tr><tr><td>Date</td><td>返回日期的文字表示法。</td><td>new Date() 结果 Thu Dec 01 2022 00:00:00 GMT+0800 (新加坡标准时间)，调用toString结果’Thu Dec 01 2022 00:00:00 GMT+0800 (新加坡标准时间)’</td></tr><tr><td>Function</td><td>返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] }</td><td>function fn(){}的toString结果’function fn(){}’</td></tr><tr><td>Number</td><td>返回数字的文字表示。</td><td>new Number(11)的结果Number {11}，调用toString的结果’11’</td></tr><tr><td>String</td><td>返回 String 对象的值。</td><td>new String(‘哈哈’)的结果String {‘哈哈’}，调用toString的结果’哈哈’</td></tr><tr><td>Object</td><td>返回 “[object objectname]”，其中 objectname 是对象类型的名称。</td><td>new Object()的结果{}，调用toString的结果’[object Object]’</td></tr></tbody></table><p>我们在学习<code>ToPrimitive规则</code>时，特别是学习<code>valueOf</code>和<code>toString</code>时候，我们发现<strong>数组</strong>或者<strong>普通对象</strong>的valueOf都是他们本身，那么每次遇到直接走toString不就可以了，这种想法是很容器出错的。<strong>如果私自修改原型的</strong><code>valueOf</code> <strong>或者</strong> <code>toString</code><strong>方法，则会影响引用类型转换为原始类型。</strong></p><p>例如：字符串拼接引用类型会优先调用toString方法，如果把toString重写则会直接影响转化的原始类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-number">111</span>&#125;<br>obj + <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(value)<br>&#125;<br><br>obj + <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &#x27;NaN&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="原始类型的隐式转换规则"><a href="#原始类型的隐式转换规则" class="headerlink" title="原始类型的隐式转换规则"></a>原始类型的隐式转换规则</h2><h3 id="1-数学运算符中的类型转换"><a href="#1-数学运算符中的类型转换" class="headerlink" title="1. 数学运算符中的类型转换"></a>1. 数学运算符中的类型转换</h3><p>① <strong>减、乘、除（引用类型执行<code>toPrimitive( input, Number )</code>）</strong></p><p><strong>⭐️我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- true // <span class="hljs-number">0</span>， 首先把 true 转换为数字 <span class="hljs-number">1</span>， 然后执行 <span class="hljs-number">1</span> - <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span>- null // <span class="hljs-number">1</span>,  首先把 null 转换为数字 <span class="hljs-number">0</span>， 然后执行 <span class="hljs-number">1</span> - <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span>* undefined //  NaN, undefined 转换为数字是 NaN<br><span class="hljs-symbol">2 </span>* [<span class="hljs-comment">&#x27;5&#x27;] //  10， [&#x27;5&#x27;]首先会调用valueOf()还是[&#x27;5&#x27;], 然后调用toString()得到&#x27;5&#x27;,再根据规则1转换成数字5</span><br><br></code></pre></td></tr></table></figure><p>② <strong>加法的特殊性</strong></p><p><strong>⭐️为什么加法要区别对待？因为JS里 <code>+</code>还可以用来拼接字符串。谨记以下2条：</strong></p><ul><li>当 + 作为字符串拼接时（一侧为String类型时），<strong>会优先将另一侧转换为字符串类型</strong>（引用类型执行<code>toPrimitive( input,  String )</code>）</li><li>当 + 作为数学运算时（两侧无String类型时，或者是加号前面什么也没有时），<strong>会优先将另一侧转换为Number类型</strong>（引用类型执行<code>toPrimitive( input, Number )</code>）</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">        <span class="hljs-number">123</span> + <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// 123123   字符换拼接</span><br><span class="hljs-number">123</span> + &#123;&#125;  <span class="hljs-comment">// 123[object Object]  字符换拼接</span><br>        <span class="hljs-number">123</span> + <span class="hljs-literal">null</span>  <span class="hljs-comment">// 123    加法运算</span><br>        <span class="hljs-number">123</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 124   加法运算</span><br><span class="hljs-literal">true</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 2    加法运算</span><br>+ [] <span class="hljs-comment">// 0      加法运算</span><br>+ &#123;&#125; <span class="hljs-comment">// NAN    加法运算</span><br>       <br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>如果两个都是引用类型，<code>toPrimitive规则</code>中<code>preferedType</code> 为 <code>Number</code>。然后我们需要判断此时<code>+符号</code>是属于什么作用。</p><p><strong><code>toPrimitive规则</code>会把</strong><code>[]</code><strong>转化为原始类型<code>&#39;&#39;</code><strong>，</strong>把<code>&#123;&#125;</code>转化为原始类型</strong><code>&#39;[object Object]&#39;</code>，有字符串，则<code>+符号</code>作用是为字符串拼接</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">[]+&#123;&#125;  <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br>转化过程：[] + &#123;&#125; = [] + &#123;&#125; = <span class="hljs-string">&quot;&quot;</span> + **<span class="hljs-string">&quot;[object Object]&quot;</span> = <span class="hljs-string">&quot;[object Object]&quot;</span>**<br></code></pre></td></tr></table></figure><p><strong>javascript有这样的特性，如果 { } 既可以被认为是代码块，又可以被认为是对象字面量，那么js会把他当做代码块来看待，这样就不是两个引用类型相加了，而是 + []，所以此时</strong><code>+符号</code><strong>属于数学运算，<code>toPrimitive规则</code>会把</strong><code>[]</code><strong>转化为原始类型<code>&#39;&#39;</code>，再转换为<code>Number</code></strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;&#125;+[]  <span class="hljs-comment">// 0**</span><br><br>转化过程：&#123;&#125;+[] = (&#123;&#125;, + []) =  + [] =  + <span class="hljs-string">&#x27;&#x27;</span> = + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-逻辑语句中的类型转换"><a href="#2-逻辑语句中的类型转换" class="headerlink" title="2. 逻辑语句中的类型转换"></a>2. 逻辑语句中的类型转换</h3><p>当我们使用 <code>if</code> <code>while</code> <code>for</code> 语句时，我们期望表达式是一个<code>Boolean</code>，所以一定伴随着隐式类型转换。而这里面又分为三种情况：</p><p>① <strong>单个变量（引用类型执行<code>toPrimitive( input,String )</code>）</strong></p><p>⭐️如果只有单个变量，会先将变量转换为Boolean值</p><p>我们可以参考<strong>附录</strong>的转换表来判断各种类型转变为<code>Boolean</code>后的值，不过这里有个小技巧：</p><p><strong>只有 <code>null</code> <code>undefined</code> <code>&#39;&#39;</code> <code>NaN</code> <code>0</code> <code>false</code> 这几个是 <code>false</code>，其他的情况都是 <code>true</code>，比如 <code>&#123;&#125;</code> , <code>[]</code>。</strong></p><p>② <strong>使用 == 比较中的5条规则 （引用类型执行<code>toPrimitive( input,Number )</code>）</strong></p><p><strong>前提：</strong>只有两侧类型不同才会触发转换</p><p>⭐️虽然我们可以严格使用 <code>===</code>，不过了解<code>==</code>的习性还是很有必要的，根据 <code>==</code> 两侧的数据类型，我们总结出 4条规则：</p><ul><li><strong>规则 1：<code>NaN</code>和其他任何类型比较永远返回<code>false</code>（包括和他自己）。</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><strong>规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-literal">true</span> == <span class="hljs-number">1</span>  <span class="hljs-comment">// true</span><br><span class="hljs-literal">true</span> == <span class="hljs-string">&#x27;2&#x27;</span>  <span class="hljs-comment">// false, 先把 true 变成 1，而不是把 &#x27;2&#x27; 变成 true</span><br><span class="hljs-literal">true</span> == [<span class="hljs-string">&#x27;1&#x27;</span>]  <span class="hljs-comment">// true, 先把 true 变成 1， [&#x27;1&#x27;]拆箱成 &#x27;1&#x27;, 再参考规则3</span><br><span class="hljs-literal">true</span> == [<span class="hljs-string">&#x27;2&#x27;</span>]  <span class="hljs-comment">// false, 同上</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false ，首先 false 变成 0，然后参考规则4</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false，同上</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>规则 3：<code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</strong></li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">123 </span>== <span class="hljs-comment">&#x27;123&#x27; // true, &#x27;123&#x27; 会先变成 123</span><br><span class="hljs-comment">&#x27;&#x27; == 0 // true, &#x27;&#x27; 会首先变成 0</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>规则 4：<code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null</code>、<code>undefined</code>和其他任何结果的比较值都为<code>false</code>。</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">null</span> == <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">null</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>⭐️<strong>其实在==的隐形转换类型中，总结一条就可以：原始类型都转为Number 再比较</strong></p><p>③ <strong>逻辑非( ! )：将其后变量或表达式转为布尔值（引用类型使用ToBoolean规则）</strong></p><p>注：ToBoolean规则将所有引用类型都视为true,除了null和undefined会被转为false</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h3 id="1-显式转换规则"><a href="#1-显式转换规则" class="headerlink" title="1. 显式转换规则"></a>1. 显式转换规则</h3><p><strong>转数值类型</strong></p><ul><li>布尔类型中<code>true</code>转为1，<code>false</code>转为0</li><li>若字符串中出现任意非数字、非空格的字符，均转为<code>NaN</code>，纯数字字符串可以转为对应<code>Number</code>类型<ul><li>若其中数字中间存在空格，转为<code>NaN</code>，若希望尽可能的转换字符串中出现的数字，请参考parseInt、parseFloat方法</li></ul></li><li>引用类型除了 <code>length</code>在<code>0-1</code>之间<strong>数字数组</strong>可以转化为<code>Number</code>类型，其他引用类型都是<code>NaN</code></li><li><code>null</code>转为0，<code>undefined</code>转为NaN</li></ul><p><strong>转布尔类型</strong></p><ul><li>只有<code>null</code> <code>undefined</code> <code>&#39;&#39;</code> <code>NaN</code> <code>0</code> <code>false</code> 这几个是 <code>false</code></li><li>其他的情况都是 <code>true</code>，比如 <code>&#123;&#125;</code> , <code>[]</code>。</li></ul><p><strong>转字符串类型</strong></p><ul><li><strong>原始类型</strong>转字符串直接加双引号即可</li><li><strong>引用类型</strong>则是转换为原始类型再加双引号</li></ul><h3 id="2-隐式转换规则"><a href="#2-隐式转换规则" class="headerlink" title="2. 隐式转换规则"></a>2. 隐式转换规则</h3><ul><li><strong>优先转换引用类型为原始类型。</strong></li><li>数学运算中，引用类型执行<code>toPrimitive( input,  Number )</code>，原始类型都转<code>Number</code></li><li>字符串拼接中，引用类型执行<code>toPrimitive( input,  String )</code>，原始类型都转<code>String</code></li><li>单个变量逻辑运算，引用类型执行<code>toPrimitive( input,  String )</code> ，原始类型转为<code>Boolean</code></li><li>逻辑非运算，引用类型执行<code>toBoolean</code>，原始类型转为<code>Boolean</code></li><li><code>==</code>运算中，引用类型执行<code>toPrimitive( input,  Number )</code>，原始类型转为<code>Number</code>（除了<code>null</code>、<code>undefined</code>、<code>NaN</code>有自己的规则）</li></ul><p><strong>注</strong>：在<code>==</code>左边 或者在<code>+</code>左边直接使用{}或者带有属性对象都会被当做代码块</p><h1 id="四、练习："><a href="#四、练习：" class="headerlink" title="四、练习："></a>四、练习：</h1><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&#123;&#125; + &#123;&#125; =&gt; <span class="hljs-string">&quot;[object Object][object Object]&quot;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] + [] =&gt; <span class="hljs-string">&quot;1,2,3&quot;</span> + <span class="hljs-string">&quot;&quot;</span> -&gt;<span class="hljs-string">&quot;1,2,3&quot;</span><br>[] + &#123;&#125; =&gt; <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;[object Object]&quot;</span> -&gt; <span class="hljs-string">&quot;[object Object]&quot;</span><br>&#123;&#125; + []    =&gt; <span class="hljs-number">0</span>    ---&gt; &#123;&#125;被当做一个块，相当于执行 (&#123;&#125;,+[])，返回值为小括号最后面的表达式的返回值<br>&#123;q:<span class="hljs-number">1</span>&#125; + [] =&gt; <span class="hljs-number">0</span><br><br><span class="hljs-keyword">var</span> a = &#123;q:<span class="hljs-number">1</span>&#125;;<br>a + [] =&gt; <span class="hljs-string">&quot;[object Object]&quot;</span>     变量形式运算正常<br>[] + a  =&gt; <span class="hljs-string">&quot;[object Object]&quot;</span><br><br>&#123;&#125; == []  =&gt; 报错   <span class="hljs-function"><span class="hljs-params">(&#123;&#125;, ==[])</span>-&gt;</span>报错<br>&#123;&#125; == !&#123;&#125; =&gt; 报错  <span class="hljs-function"><span class="hljs-params">(&#123;&#125;, ==!&#123;&#125;)</span>-&gt;</span>报错<br><br>[] == <span class="hljs-number">0</span>   =&gt; <span class="hljs-literal">true</span>[]-&gt;<span class="hljs-string">&quot;&quot;</span>-&gt;<span class="hljs-number">0</span><br>![] == <span class="hljs-number">0</span>  =&gt; <span class="hljs-literal">true</span>   ![]-&gt;<span class="hljs-literal">false</span>-&gt;<span class="hljs-number">0</span><br>[] == ![] =&gt; <span class="hljs-literal">true</span>   []-&gt;<span class="hljs-string">&quot;&quot;</span>-&gt;<span class="hljs-number">0</span>  ![]-&gt;<span class="hljs-literal">false</span>-&gt;<span class="hljs-number">0</span><br>[] == []  =&gt; <span class="hljs-literal">false</span>  比较引用地址<br>&#123;&#125; == &#123;&#125;  =&gt; <span class="hljs-literal">false</span>  比较引用地址<br>!&#123;&#125; == &#123;&#125; =&gt; <span class="hljs-literal">false</span>  !&#123;&#125;-&gt;<span class="hljs-literal">false</span>-&gt;<span class="hljs-number">0</span>  &#123;&#125;-&gt;<span class="hljs-string">&quot;[object Object]&quot;</span>-&gt;<span class="hljs-literal">NaN</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链与继承</title>
    <link href="/2022/10/05/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/10/05/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a>原型链与继承</h1><h2 id="一、原型链"><a href="#一、原型链" class="headerlink" title="一、原型链"></a>一、原型链</h2><h3 id="1-原型对象与原型链的理解"><a href="#1-原型对象与原型链的理解" class="headerlink" title="1. 原型对象与原型链的理解"></a>1. 原型对象与原型链的理解</h3><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是<strong>原型链的概念</strong>。</p><p>所以，通过原型链概念我们知道<strong>原型链是由原型对象组成的，而这个原型对象是相对的，相对于有这个原型对象的构造函数的实例，它是原型对象，如果相对于它自己的原型对象，它就是它原型对象构造函数的一个实例而已，也就是个普通函数。</strong></p><h3 id="2-原型链中对象属性的查找和修改机制"><a href="#2-原型链中对象属性的查找和修改机制" class="headerlink" title="2. 原型链中对象属性的查找和修改机制"></a>2. 原型链中对象属性的查找和修改机制</h3><p> <strong>2.1 对象属性查找机制</strong></p><p>当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</p><p><strong>2.2对象属性修改机制</strong></p><p>只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: fn<code>.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</p><h3 id="3-原型、构造函数、实例的具体关系"><a href="#3-原型、构造函数、实例的具体关系" class="headerlink" title="3.原型、构造函数、实例的具体关系"></a>3.原型、构造函数、实例的具体关系</h3><p>那么我们具体了解下原型、构造函数、实例的关系是怎样的呢？</p><p><img src="/img/proto1.png"></p><p>有图我们知道几个关系：</p><p>关系一：<code>原型.constructor === 构造函数</code></p><p>关系二：<code>构造函数.prototype === 原型</code></p><p>关系三：<code>实例.__proto__ === 原型</code></p><p>关系四：<code>实例.constructor === 构造函数</code> </p><p><strong>此时，我不知道各位有没有注意到，图中有两条划红线的地方</strong></p><p>因为这两条关系比较特殊，我们看下面代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructor</span> (<span class="hljs-params">attr1,attr2</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">attr1</span> = attr1<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr2</span> = attr2<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&quot;属性1&quot;</span>,<span class="hljs-string">&quot;属性2&quot;</span></span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(constructor)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(instance)<br></code></pre></td></tr></table></figure><p>我们看一下打印结果：</p><p><img src="/img/proto2.png"></p><p>从图中的知道，关系一、关系二的属性都可以在对象中找到，而关系三和四中在实例中并找不到<code>__proto__</code>属性和<code>constructor</code>属性。下面我们分析下原因：</p><ul><li><p><code>实例.__proto__ === 原型</code> 我们打印实例并没有直接发现__proto__属性，是因为这个属性不是实例自己的，它是<code>Object.prototype</code>中实现的，里面有<code>get__ptoto__</code>的方法和<code>set__proto__</code>的方法对<code>__proto__</code> 进行监听。所以我们在使用<code>__proto__</code> 属性其实也是用到了原型链的查找机制。所以，__proto__属性其实指向<code>[[Prototype]]</code>中，但是由于是<code>[[Prototype]]</code> 是内部属性，我们是没法直接获取的，所以使用<code>__proto__</code> 来访问。</p><p>【<code>__proto__</code>这个属性，在之前版本是在对象直接可以看到的，而不是通过原型链查找，而现在改版原因，又 <strong>Object</strong> 的原型对象统一实现】</p></li><li><p><code>实例.constructor === 构造函数</code> 我们发现实例对象并没有自己的constuctor，所以他肯定又是通过原型链来获取的这个属性。所以它取的它的原型对象的constructor，<code>实例.constructor === 实例.__proto__.constructor === 构造函数</code>。</p></li></ul><p><strong>我们思考一下为什么实例对象没有自己的constructor?</strong> </p><p>如果对象有自己的constructor，说明它一定有自己的构造函数，而不是它原型对象的构造函数，再直白一点就是这个<strong>对象一定是作为原型对象才会有自己的constructor</strong>，我们看构造函数的原型对象是不是就有自己的constructor属性。所以，<strong>constructor是原型对象的属性，一个普通对象是没有自己的constructor属性的（这里不包括它原型上的），只有作为原型对象的时候有自己的constructor属性。</strong></p><aside>💡 现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 `Object.getPrototypeOf()`方法，我们可以通过这个方法来获取对象的原型。</aside><p><strong>最后放出原型链的终极关系图：</strong></p><p><img src="/img/proto3.png"></p><p><strong>总结：</strong></p><ul><li><code>prototype</code>属性是<strong>函数</strong>独有的，<code>__proto__</code>和<code>constructor</code>是<strong>对象</strong>独有的</li><li>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li><li>原型、构造函数、实例三者关系<ul><li>关系一：<code>原型.constructor === 构造函数</code></li><li>关系二：<code>构造函数.prototype === 原型</code></li><li>关系三：<code>实例.__proto__ === 原型</code></li><li>关系四：<code>实例.constructor === 构造函数</code></li></ul></li><li>获取原型对象不推荐用<code>__proto__</code> ，只推荐使用 <code>Object.getPrototypeOf(实例对象)</code></li><li>当对象拥有自己的constructor属性说明对象是作为原型对象的存在；当对象没有自己的constructor属性是作为某个构造函数的实例的存在</li></ul><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><p>首先我们知道ES6支持了Class，但是在JS中并不存在类。Class只是语法糖，其<strong>本质还是函数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><span class="hljs-title class_">Person</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>class</code>实现继承的核心在于使用 <code>extends</code>表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，<code>super</code>本质还是改变this指向。</p><p>下面我们先用一张图了解下继承有哪些实现方式以及继承的发展过程</p><p><img src="/img/proto4.png"></p><h3 id="1-构造函数继承-（-借助call）"><a href="#1-构造函数继承-（-借助call）" class="headerlink" title="1.  构造函数继承 （ 借助call）"></a><strong>1.  构造函数继承 （ 借助call）</strong></h3><p>子类构造函数中使用<code>call()</code>和<code>apply()</code>方法<strong>改变父类构造函数的<code>this</code>指向</strong>来达到继承</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br> &#125;<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child1&#x27;</span><br> &#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>);<br></code></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>可以在子类构造函数通过<code>call</code>可以<strong>向父类传参数</strong></li><li><strong>父类的引用属性不会被共享</strong></li></ul><p><strong>缺点：</strong></p><ul><li><p>子类不能访问父类<strong>原型</strong>上定义的<strong>方法</strong>（即不能访问Parent1.prototype上定义的方法）</p></li><li><p>所有方法属性都只能写在构造函数中，每次创建实例都会初始化</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Parent1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">work</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;work&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-title function_">work</span>()) <span class="hljs-comment">// Uncaught TypeError: s1.work is not a function</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-原型链继承-（借助原型链）"><a href="#2-原型链继承-（借助原型链）" class="headerlink" title="2. 原型链继承 （借助原型链）"></a>2. 原型链继承 （借助原型链）</h3><p>将父类的实例作为子类的原型</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent2</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent2&#x27;</span>;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br> &#125;<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child2</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span>;<br> &#125;<br> <span class="hljs-title class_">Child2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent2</span>();<br><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>());<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>父类方法可以复用，<strong>解决构造函数继承的缺点</strong></li></ul><p><strong>缺点：</strong></p><ul><li><p>父类的所有引用属性会被所有子类共享，如果更改一个子类的引用属性，其他子类也会受影响子类型</p></li><li><p>实例不能给父类型构造函数传参</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>();<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>();<br>s1.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">play</span>, s2.<span class="hljs-property">play</span>); <span class="hljs-comment">// [1,2,3,4]  [1,2,3,4]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-组合继承-（原型链-构造函数）"><a href="#3-组合继承-（原型链-构造函数）" class="headerlink" title="3. 组合继承 （原型链 + 构造函数）"></a>3. <strong>组合继承 （</strong>原型链 + 构造函数<strong>）</strong></h3><p>组合继承综合了<code>原型链继承</code>和<code>盗用构造函数继承(构造函数继承)</code>，将两者的优点结合了起来，</p><p>基本的思路：<strong>使用原型链继承父类原型上的属性和方法</strong>，而<strong>通过构造函数继承实例属性</strong>，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> &#125;<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br> &#125;<br> <span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span><br><br> <span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br> <span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br> s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>); <span class="hljs-comment">// [1,2,3,4]  [1,2,3]</span><br></code></pre></td></tr></table></figure><p> <strong>优点：</strong></p><ul><li>父类方法可以复用</li><li>子类构造函数中向父类传参数<strong>父类的引用属性不会被共享</strong></li></ul><p><strong>缺点：</strong></p><ul><li>父类的构造函数<code>Parent3</code>会执行两次（<code>Parent3.call(this)</code>和<code>Child3.prototype = new Parent3();</code>）。</li></ul><p><strong>注意：</strong></p><p><code>Child3.prototype.constructor = Child3</code> 由于Child3的原型对象被重写，所以<code>Child3.prototype</code> 原本默认的constructor会被丢失。所以我们需要手动指定下原型对象的构造函数指向。</p><h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h3><p>原型式继承是不涉及严格意义上构造函数的继承方法，<strong>基于已有的对象</strong>（不是构造函数哦！）创建一个新对象，该新对象的原型指向已有的对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> parent4 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;parent4&#x27;</span>,<br>    <span class="hljs-attr">play</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  &#125;<br><br><span class="hljs-keyword">var</span> child4 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent4,&#123;<br><span class="hljs-attr">type</span>:&#123;<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;child4&#x27;</span>&#125;<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child4);<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>父类方法可复用</li></ul><p><strong>缺点：</strong></p><ul><li><p>父类的引用会被所有子类所共享</p></li><li><p>子类实例不能向父类传参</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> child5 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent4)<br>child4.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child4.<span class="hljs-property">play</span>) <span class="hljs-comment">//[1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child5.<span class="hljs-property">play</span>) <span class="hljs-comment">//[1,2,3,4]</span><br><br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：<code>Object.create()</code> 是原型式继承的核心，</strong>是ES5为了<strong>规范原型式继承</strong>而出的方法，可以理解为<code>Object.create()</code>就是原型式继承，而这个方法核心原理如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">superInstance</span>)&#123;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = superInstance<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>() <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h3><p>寄生式继承是和原型式继承比较接近的一种继承方式，是一个类似于工厂函数的继承方式：创建一个实现继承的函数，在函数里以某种方法进行增强（加工）对象，然后返回一个对象。</p><p>【寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景】</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> parent5 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;parent2&#x27;</span>,<br>    <span class="hljs-attr">play</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br>  child.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;<br>child.<span class="hljs-property">work</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;work&#x27;</span><br>&#125;<br>  <span class="hljs-keyword">return</span> child;<br>&#125;<br><br><span class="hljs-keyword">var</span> child5 = <span class="hljs-title function_">createChild</span>(parent5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child5);<br><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>父类方法可复用</li><li>在不修改原型对象情况下，对新对象进行扩展</li><li>通过寄生继承实现混入、单例等功能</li><li>代码简洁，易于维护。</li></ul><p><strong>缺点：</strong></p><ul><li>父类的引用会被所有子类所共享</li><li>子类实例不能向父类传参</li><li>调用一次函数<code>createChild</code>就得<strong>重新创建一遍方法</strong>，无法实现函数复用，效率较低</li></ul><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> child6= <span class="hljs-title function_">createChild</span>(parent5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child6.<span class="hljs-property">work</span> === child6.<span class="hljs-property">work</span>) <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>注意：</p><p>Object.create()方法并不是寄生式继承所必需的，任何可以返回新对象的函数都可以在这使用。</p><aside>💡 在没有必要兴师动众地创建构造函数，而只想让一个对象和另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</aside><h3 id="6-方式5-最推荐使用-寄生组合继承-———-最接近extends实现方法"><a href="#6-方式5-最推荐使用-寄生组合继承-———-最接近extends实现方法" class="headerlink" title="6. 方式5(最推荐使用): 寄生组合继承 ——— 最接近extends实现方法"></a>6. 方式5(最推荐使用): 寄生组合继承 ——— 最接近extends实现方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span> (<span class="hljs-params">subClass,superClass</span>)&#123;<br><span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//通过create方法将父类浅复制一份，引用类型依旧是原来的引用</span><br>subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype <span class="hljs-comment">//解决组合继承父类调用两次的问题，由于call已经解决继承父类的问题，那就直接将父类原型继承过去就行了</span><br>subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = subClass <span class="hljs-comment">//修改原型会导致原型对象的constructor属性失效，需要是手动指定</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child5</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//用于继承父类自己的属性和传参</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child6&#x27;</span>;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span> (<span class="hljs-title class_">Child6</span>,<span class="hljs-title class_">Parent6</span>)<br><br></code></pre></td></tr></table></figure><p>这是标准的寄生组合继承，有着寄生式继承的标志性的工厂函数，也有组合式继承的特点，所以这就是集聚所有继承方法的优点，解决了以下问题：</p><ol><li>方法共享（复用）</li><li>引用值修改不会产生副作用</li><li>可以传参数到父类构造函数</li><li>效率提升，只调用了一次父类构造函数，避免了<code>Sub.prototype</code>上不必要也用不到的属性</li></ol><p><strong>下面我们复盘分析下，我们如何实现这些功能的</strong>：</p><ol><li><p><strong>方法的共享，不用频繁的创建方法</strong><br>方法一定是放在原型上，而不是构造函数里，这样就避免频繁创建方法。</p></li><li><p><strong>引用值修改不会产生副作用，这里副作用指的是影响其他对象。</strong><br>想要产生不会产生副作用的引用，那我们不可以直接引用我们想要继承的对象，而是通过新建个拷贝，间接引用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent5</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> &#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child5</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//方式一 </span><br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent5</span>()<br><span class="hljs-comment">//方式二</span><br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">//方式三</span><br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent5</span>)<br><span class="hljs-comment">//方式四</span><br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><br></code></pre></td></tr></table></figure><p><strong>方式一</strong>：这个可以看<code>原型链继承</code>,这个主要是为了Child5继承Parent5本身以及原型上的属性和方法，不过这样会产生引用的副作用，如果实例更改Parent本身或者原型属性，都会导致其他实例的属性改变。</p><p><strong>方式二</strong>：这个方式只是继承了Parent5原型上的属性和方法，没有继承Parent5本身的属性和方法，但是这个同样存在一个缺点就是会产生引用的副作用,Child5的实例只要改其原型上的方法和属性，会直接影响到Person5本身</p><p><strong>方式三</strong>：这个方法通过Obect.create()让一个中间空对象的承担Child5原型,再把Parent5的实例绑到中间空对象上，修改Child5.prototype不会影响到Parent本身，但是有一个缺点就是如果使用Parent5的属性还是会产生饮用的副作用，具体后面做总结</p><p><strong>方式四</strong>：这个与方式三优点相同，修改Child5.prototype不会影响到Parent本身，因为Child5.prototype绑定是一个空对象，而空对象的原型才是Parent5,同时，方式四还弥补了方式三的缺点就是修改Parent5自身属性是不会产生引用的副作用的，除非你去修改Parent5原型的属性和方法，肯定会有引用副作用，这个是避免不了的。</p><p> <strong>总的来说，根据这四种方式总结下</strong>，<strong>只要我想要绑定到Child5.prototype的对象就一定存在引用的副作用，所以就需要我们选择用谁来绑定，是它的实例还是原型等</strong>。一般情况下构造函数里放属性，构造函数的原型放方法，这也是现代Class继承的原理，所以我们通过原型链的实现继承，就不能让引用类型副作用影响继承的属性，这时，继承构造函数的属性就不能通过原型链方式，只能通过<code>构造函数继承</code>来继承自身属性，而构造函数的原型属性方法再通过原型链的方式继承，并且不能是方式二的直接继承，这样会直接影响到Parent5对象本身，我们需要一个空对象来做中介，这样，通过<code>Child5.prototype</code>来操作的就不是Parent.peototype本身，而是’隔着一个墙’的空对象,除非你通过<code>Child5.prototype.__proto__</code>才能影响到Parent5.prototype本身。</p></li><li><p><strong>可以传参数到父类构造函数</strong><br>这个主要是通过构造函数继承的特性，通过call函数技能改变Parent5中this指向，又可以传参的特性。</p></li><li><p><strong>效率提升，只调用了一次父类构造函数</strong><br>像<code>组合式继承</code>的缺点就是通过call方式继承Parent5自身属性和通过<code>Child5.prototype = new Parent5()</code>方式,会导致Parent5执行两次，所以，加上寄生继承的优势Child5.prototype = Object.create(Parent5)减少一次Parent5的调用。</p></li></ol><p>最后我们来探讨一个问题：<code>inheritPrototype()</code>是复制父类的原型到子类身上，那为什么不直接用<code>SubClass.prototype=Super.prototype</code>呢，这样也达到了复制的目的啊？</p><p>这是因为，这样做是一种浅拷贝，如果我们改变<code>SubClass.prototype</code>的某个属性或者方法，<code>SuperClass.prototype</code>也会跟着变，看以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent5&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child6&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child6</span>;<br><br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sayHi&quot;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>()<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent6</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">constructor</span> ===s2.<span class="hljs-property">constructor</span>) <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>从这个例子得之，<code>Child5.prototype.constructor = Child5</code> 将 <code>Parent5.prototype</code> 原型中的constructor 也修改了，所以我们需要用Object.create() 避免对 <code>Parent5.prototype</code> 的直接引用。</p><h3 id="7-ES6的extends被编译后的JavaScript代码"><a href="#7-ES6的extends被编译后的JavaScript代码" class="headerlink" title="7.ES6的extends被编译后的JavaScript代码"></a>7.<strong>ES6的extends被编译后的JavaScript代码</strong></h3><p>我们通过babel将<code>extends</code>从ES6转换成ES5：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_possibleConstructorReturn</span>(<span class="hljs-params">self, call</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> call &amp;&amp; (<span class="hljs-keyword">typeof</span> call === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">&#x27;function&#x27;</span>) ? call : self;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//看到没有</span><br>    subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superClass &amp;&amp; superClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>        <span class="hljs-attr">constructor</span>: &#123;<br>            <span class="hljs-attr">value</span>: subClass,<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (superClass) <span class="hljs-title class_">Object</span>.<span class="hljs-property">setPrototypeOf</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(subClass, superClass) : subClass.<span class="hljs-property">__proto__</span> = superClass;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 验证是否是 Parent 构造出来的 this</span><br>    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Parent</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params">_Parent</span>) &#123;<br>    <span class="hljs-title function_">_inherits</span>(<span class="hljs-title class_">Child</span>, _Parent);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Child</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_possibleConstructorReturn</span>(<span class="hljs-variable language_">this</span>, (<span class="hljs-title class_">Child</span>.<span class="hljs-property">__proto__</span> || <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Child</span>)).<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Child</span>;<br>&#125;(<span class="hljs-title class_">Parent</span>));<br><br></code></pre></td></tr></table></figure><p>这段代码的核心是<code>_inherits</code>函数，可以看到它采用的依然也是寄生组合继承方式。其中，<code>Object.setPrototypeOf(subClass, superClass)</code> 作用是用来继承父类静态方法，这也是原来的继承方式疏忽掉的地方。</p><h2 id="三、补充："><a href="#三、补充：" class="headerlink" title="三、补充："></a>三、补充：</h2><h3 id="梳理上文Object对象的相关方法"><a href="#梳理上文Object对象的相关方法" class="headerlink" title="梳理上文Object对象的相关方法"></a>梳理上文Object对象的相关方法</h3><table><thead><tr><th>方法</th><th>用法</th></tr></thead><tbody><tr><td>Object.setPrototypeOf()</td><td>设置一个指定的对象的原型（即，内部 [[Prototype]]属性）到另一个对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null</a></td></tr><tr><td>Object.getPrototypeOf()</td><td>返回指定对象的原型（内部[[Prototype]]属性的值）。</td></tr><tr><td>Object.create(proto, propertiesObject?)</td><td>用于创建一个新对象，使用现有的对象来作为新创建对象的原型</td></tr></tbody></table><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li><strong>继承对象自身属性</strong>，我们需要<code>构造函数继承</code>的方式，通过call改变对象的构造函数this和传参</li><li><strong>继承对象原型的属性和方式</strong>，我们需要<code>原型链继承</code>的方式，将对象原型的属性和方法绑定到需要继承的对象上</li><li><strong>继承对象原型属性和方式又不想影响继承对象原型本身</strong>，我们需要通过<code>原型式继承</code>，通过<code>Object.create()</code>将继承对象绑定到这个空对象上，从而实现继承后的类通过prototype直接修改到继承对象的原型</li><li><strong>修改原型对象之后会丢失constructor属性，注意重新增加其继承的构造函数的constructor</strong></li><li>方便自己的扩展性的话，再利用<code>寄生继承</code>封装成工厂函数，方便继承。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS防抖与节流</title>
    <link href="/2022/10/02/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2022/10/02/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><h2 id="一、防抖"><a href="#一、防抖" class="headerlink" title="一、防抖"></a>一、防抖</h2><p>函数防抖 是指在事件被触发 n 秒内再次触发，重新计时n秒，直到n秒后才能执行函数。</p><p>防抖可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、节流"><a href="#二、节流" class="headerlink" title="二、节流"></a>二、节流</h2><p>函数节流 是单位时间内只触发一次函数的执行。</p><p>节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>,<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS深拷贝与浅拷贝</title>
    <link href="/2022/10/01/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/10/01/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="JS深拷贝与浅拷贝"><a href="#JS深拷贝与浅拷贝" class="headerlink" title="JS深拷贝与浅拷贝"></a>JS深拷贝与浅拷贝</h1><h2 id="一、浅拷贝"><a href="#一、浅拷贝" class="headerlink" title="一、浅拷贝"></a>一、浅拷贝</h2><p>浅拷贝是一种复制对象的方法，它只复制对象第一层的属性（只要不是复制所有层就算浅拷贝），如果对象中有嵌套对象，只会复制嵌套对象的引用，而不是嵌套对象本身。</p><h3 id="方法1：object-assign"><a href="#方法1：object-assign" class="headerlink" title="方法1：object.assign()"></a>方法1：<strong>object.assign()</strong></h3><p><code>object.assign</code>是 ES6 中 <code>object</code>的一个方法，该方法可以用于 JS 对象的合并等多个用途，<code>其中一个用途就是可以进行浅拷贝</code>。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p><p><strong>object.assign 的示例代码如下：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> target = &#123;&#125;;<br><span class="hljs-keyword">let</span> source = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// &#123; a: &#123; b: 1 &#125; &#125;;</span><br></code></pre></td></tr></table></figure><p>适用：对象</p><p>特点：</p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>可以拷贝 <code>Symbol</code> 类型的属性。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>:&#123; <span class="hljs-attr">b</span>:<span class="hljs-number">1</span> &#125;, <span class="hljs-attr">sym</span>:<span class="hljs-title class_">Symbol</span>(<span class="hljs-number">1</span>)&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj1, <span class="hljs-string">&#x27;innumerable&#x27;</span> ,&#123;<br>    <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;不可枚举属性&#x27;</span>,<br>    <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span><br>&#125;);<br><span class="hljs-keyword">let</span> obj2 = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj2,obj1)<br>obj1.<span class="hljs-property">a</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2);<br></code></pre></td></tr></table></figure><p><img src="/img/copy1.png"></p><h3 id="方法2：扩展运算符"><a href="#方法2：扩展运算符" class="headerlink" title="方法2：扩展运算符"></a>方法2：扩展运算符</h3><p>以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 对象的拷贝 */</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;...obj1&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">b</span> === obj1.<span class="hljs-property">b</span>)  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">/* 数组的拷贝 */</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]];<br><span class="hljs-keyword">let</span> newArr = [...arr]; <span class="hljs-comment">//跟arr.slice()是一样的效果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr[<span class="hljs-number">1</span>] === arr[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>适用：数组、对象</p><p>特点：</p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>可以拷贝 <code>Symbol</code> 类型的属性。</li></ul><h3 id="方法3：concat方法"><a href="#方法3：concat方法" class="headerlink" title="方法3：concat方法"></a>方法3：<strong>concat方法</strong></h3><p><code>concat</code>只能用于数组的浅拷贝，使用场景比较局限</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);  <span class="hljs-comment">// [ 1, 2, 3 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [ 1, 100, 3 ]</span><br></code></pre></td></tr></table></figure><p>适用：数组</p><h3 id="方法4：slice方法"><a href="#方法4：slice方法" class="headerlink" title="方法4：slice方法"></a>方法4：<strong>slice方法</strong></h3><p><code>slice</code>方法也比较有局限性，因为<code>它仅仅针对数组类型</code>。slice方法会返回一个新的数组对象，并且不会修改原数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123;<span class="hljs-attr">val</span>: <span class="hljs-number">4</span>&#125;];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">slice</span>();<br>newArr[<span class="hljs-number">2</span>].<span class="hljs-property">val</span> = <span class="hljs-number">1000</span>;<br>newArr[<span class="hljs-number">1</span>].<span class="hljs-property">val</span> = <span class="hljs-number">1000</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);  <span class="hljs-comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span><br></code></pre></td></tr></table></figure><p>适用：数组</p><h3 id="方法5：手工实现一个浅拷贝"><a href="#方法5：手工实现一个浅拷贝" class="headerlink" title="方法5：手工实现一个浅拷贝"></a>方法5：手工实现一个浅拷贝</h3><p>思路：</p><ul><li>对基础类型做一个最基本的一个拷贝；</li><li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shallowClone</span> = (<span class="hljs-params">target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? []: &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) &#123; <span class="hljs-comment">// 会遍历除Symbol以外的所有可枚举类型（包括继承属性）</span><br>      <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123; <span class="hljs-comment">// 判断是否是自己的属性，而不是继承的</span><br>          cloneTarget[prop] = target[prop];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>适用：对象、数组</p><p>特点：</p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>它不会拷贝 <code>Symbol</code> 类型的属性。</li></ul><h2 id="二、深拷贝"><a href="#二、深拷贝" class="headerlink" title="二、深拷贝"></a>二、深拷贝</h2><h3 id="方式1：JSON-parse-JSON-stringify-XXX-（最简单的深拷贝）"><a href="#方式1：JSON-parse-JSON-stringify-XXX-（最简单的深拷贝）" class="headerlink" title="方式1：JSON.parse(JSON.stringify(XXX))（最简单的深拷贝）"></a>方式1：JSON.parse(JSON.stringify(XXX))<strong>（最简单的深拷贝）</strong></h3><p><code>JSON.parse(JSON.stringify(XXX))</code>是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 <code>JSON</code>的字符串，并将对象里面的内容转换成字符串，最后再用 <code>JSON.parse()</code>的方法将 <code>JSON</code>字符串生成一个新的对象。看示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> a = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">jobs</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;FE&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a))<br>a.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span> = <span class="hljs-string">&#x27;native&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// FE</span><br></code></pre></td></tr></table></figure><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>无法拷贝不可枚举的属性</li><li>无法拷贝对象的原型链</li><li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li><li>拷贝 <code>Date</code> 引用类型会变成字符串</li><li>对象中含有 <code>NaN</code>、<code>Infinity</code> 以及 <code>Infinity</code>，<code>JSON</code> 序列化的结果会变成 <code>null</code></li><li>不能解决循环引用的对象，即对象成环 (<code>obj[key] = obj</code>)。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Obj</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">func</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>) &#125;;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">und</span> = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">reg</span> = <span class="hljs-regexp">/123/</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">NaN</span> = <span class="hljs-title class_">NaN</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">infinity</span> = <span class="hljs-title class_">Infinity</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sym</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">let</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj1,<span class="hljs-string">&#x27;innumerable&#x27;</span>,&#123;<br>  <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;innumerable&#x27;</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1);<br><span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1);<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2);<br></code></pre></td></tr></table></figure><p><img src="/img/copy2.png"></p><p>使用 <code>JSON.parse(JSON.stringify(XXX))</code>方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</p><h3 id="方式2：基础班（手写递归实现）"><a href="#方式2：基础班（手写递归实现）" class="headerlink" title="方式2：基础班（手写递归实现）"></a>方式2：基础班（<strong>手写递归实现</strong>）</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123; <br>  <span class="hljs-keyword">let</span> cloneObj = &#123;&#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;           <span class="hljs-comment">//会遍历除Symbol以外的所有可枚举类型（包括继承属性）</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] ===<span class="hljs-string">&#x27;object&#x27;</span>) &#123; <br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])  <span class="hljs-comment">//是对象就再次调用该函数递归</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cloneObj[key] = obj[key]  <span class="hljs-comment">//基本类型的话直接复制值</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>这个深拷贝函数并不能复制不可枚举的属性以及 <code>Symbol</code> 类型；</li><li>这种方法<code>只是针对普通的引用类型的值做递归复制</code>，而对于 <code>Array、Date、RegExp、Error、Function</code> 这样的引用类型并不能正确地拷贝；</li><li>对象的属性里面成环，即<code>循环引用没有解决</code>。</li></ul><h3 id="方法3：改进版（改进后递归实现）"><a href="#方法3：改进版（改进后递归实现）" class="headerlink" title="方法3：改进版（改进后递归实现）"></a><strong>方法3：改进版（改进后递归实现）</strong></h3><p>针对基础版的缺点，我们通过一下方式解决</p><ul><li>针对能够遍历对象的不可枚举属性以及 <code>Symbol</code> 类型，我们可以使用 <code>Reflect.ownKeys</code> 方法；</li><li>当参数为 <code>Date、RegExp</code> 类型，则直接生成一个新的实例返回；</li><li>利用 <code>Object.getOwnPropertyDescriptors()</code> 方法可以获得对象的所有属性（包括其原型上的），以及对应的特性，顺便结合 <code>Object.create</code> 方法创建一个新对象，并继承传入原对象的原型链；</li><li>利用 <code>WeakMap</code> 类型作为 <code>Hash</code> 表，因为 <code>WeakMap</code> 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 <code>Map</code> 和 <code>weakMap</code> 的关键区别，这里要用 <code>weakMap</code>），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 <code>WeakMap</code> 存储的值</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isComplexDataType</span> = obj =&gt; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">const</span> deepClone = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)       <span class="hljs-comment">// 日期对象直接返回一个新的日期对象</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">RegExp</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)     <span class="hljs-comment">//正则对象直接返回一个新的正则对象</span><br>  &#125;<br><br>  <span class="hljs-comment">//如果循环引用了就用 weakMap 来解决</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)<br>  &#125;<br><span class="hljs-comment">// 获取obj对象包括原型对象的所有属性</span><br>  <span class="hljs-keyword">let</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj)<br><br>  <span class="hljs-comment">//遍历传入参数所有键的特性</span><br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), allDesc)<br><br>  <span class="hljs-comment">// 把cloneObj原型复制到obj上</span><br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj)<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)) &#123; <span class="hljs-comment">//会遍历所有自身所有属性</span><br>    cloneObj[key] = (<span class="hljs-title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) ? <span class="hljs-title function_">deepClone</span>(obj[key], hash) : obj[key]<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来验证下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">boolean</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">unf</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">nul</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;我是一个对象&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;,<br>  <span class="hljs-attr">arr</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是一个函数&#x27;</span>) &#125;,<br>  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-attr">reg</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;/我是一个正则/ig&#x27;</span>),<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>)]: <span class="hljs-number">1</span>,<br>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;innumerable&#x27;</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;不可枚举属性&#x27;</span> &#125;<br>);<br>obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj))<br>obj.<span class="hljs-property">loop</span> = obj    <span class="hljs-comment">// 设置loop成循环引用的属性</span><br><span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title function_">deepClone</span>(obj)<br>cloneObj.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj&#x27;</span>, obj)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cloneObj&#x27;</span>, cloneObj)<br></code></pre></td></tr></table></figure><p><img src="/img/copy3.png"></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS优化</title>
    <link href="/2022/09/30/JS%E4%BC%98%E5%8C%96/"/>
    <url>/2022/09/30/JS%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="JS优化技巧"><a href="#JS优化技巧" class="headerlink" title="JS优化技巧"></a>JS优化技巧</h1><h2 id="1-遍历类数组对象"><a href="#1-遍历类数组对象" class="headerlink" title="1.遍历类数组对象"></a>1.<strong>遍历类数组对象</strong></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(selector);<br>[].<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(elements, <span class="hljs-function">(<span class="hljs-params">el, idx, list</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el) <span class="hljs-comment">// 元素节点</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-对象计算属性"><a href="#2-对象计算属性" class="headerlink" title="2.对象计算属性"></a>2.对象计算属性</h2><p>我们经常碰到这样的问题，无论是在微信小程序还是React中，我们需要根据某个条件去修改某个数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;boy&#x27;</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-attr">boyName</span>: name<br>  &#125;)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;girl&#x27;</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-attr">girlName</span>: name<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我也不知道这个新特性叫啥，我就自己取名叫<code>属性动态属性</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>  [<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span>Name`</span>]: name<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3、函数只执行一次"><a href="#3、函数只执行一次" class="headerlink" title="3、函数只执行一次"></a><strong>3、函数只执行一次</strong></h2><p>很多时候，我们希望一个函数只执行一次。如果多次调用该函数，则只会执行第一次。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!called) &#123;<br>            called = <span class="hljs-literal">true</span>;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">launchRocket</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我已经执行了&quot;</span>);<br>&#125;<br><span class="hljs-keyword">const</span> launchRocketOnce = <span class="hljs-title function_">once</span>(launchRocket);<br><span class="hljs-title function_">launchRocketOnce</span>();<br><span class="hljs-title function_">launchRocketOnce</span>();<br><span class="hljs-title function_">launchRocketOnce</span>();<br></code></pre></td></tr></table></figure><h2 id="4、浏览器嗅探"><a href="#4、浏览器嗅探" class="headerlink" title="4、浏览器嗅探"></a><strong>4、浏览器嗅探</strong></h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vue<span class="hljs-regexp">/src/</span>core<span class="hljs-regexp">/util/</span>env.js<br></code></pre></td></tr></table></figure><p>我们知道Javascript可以在浏览器、nodejs等环境中运行，那么如何检查当前的Javascript代码是否在浏览器环境中运行？</p><p>如果Javascript在浏览器环境中运行，则会有一个全局对象：window。因此，可以通过以下方式判断环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> inBrowser = <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="5、比较时间大小"><a href="#5、比较时间大小" class="headerlink" title="5、比较时间大小"></a>5、比较时间大小</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> toTimeStamp = <span class="hljs-keyword">function</span>(<span class="hljs-params">date</span>)&#123;<br><span class="hljs-keyword">let</span> temp = date.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-/g</span>,<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment">//将-格式转换成/格式</span><br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(temp) <span class="hljs-comment">//返回一个时间戳，距离1970/1/1的毫秒数</span><br>&#125;<br><span class="hljs-keyword">let</span> date1=<span class="hljs-string">&#x27;2016-8-13&#x27;</span><br><span class="hljs-keyword">let</span> date2=<span class="hljs-string">&#x27;2016-8-23&#x27;</span><br><span class="hljs-keyword">let</span> date1_s=<span class="hljs-title function_">toTimeStamp</span>(date1)   <span class="hljs-comment">//利用正则将字符串格式转换统一标准格式 date1_s输出：2016/8/23.</span><br><span class="hljs-keyword">let</span> date2_s=<span class="hljs-title function_">toTimeStamp</span>(date2)<br><br>date1_s &gt; date2_s <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS类型检测</title>
    <link href="/2022/09/28/JS%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <url>/2022/09/28/JS%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JS类型检测"><a href="#JS类型检测" class="headerlink" title="JS类型检测"></a>JS类型检测</h1><h2 id="一、JS内置数据类型"><a href="#一、JS内置数据类型" class="headerlink" title="一、JS内置数据类型"></a>一、JS内置数据类型</h2><p><img src="/img/type1.png"></p><p>JS数据类型分为：原始<strong>类型</strong> 和 <strong>引用类型，</strong>原始类型存在<strong>栈</strong>中，引用类型存在<strong>堆</strong>中</p><p><strong>原始类型：</strong><code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>（<code>es6</code>新增）和<code>BigInt</code>（<code>es10</code>新增）</p><p><strong>引用类型：</strong>普通对象-<code>Object</code>，数组对象-<code>Array</code>，正则对象-<code>RegExp</code>，日期对象-<code>Date</code>，数学函数-<code>Math</code>，函数对象-<code>Function</code></p><h2 id="二、数据类型检测"><a href="#二、数据类型检测" class="headerlink" title="二、数据类型检测"></a>二、数据类型检测</h2><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object     null 的数据类型被 typeof 解释为 object</span><br></code></pre></td></tr></table></figure><p><code>**typeof**</code> 对于<strong>原始类型</strong>来说，除了 <code>**null**</code> 都可以显示正确的类型；对于<strong>引用类型</strong>来说，除了**<code>function</code>**函数都会显示 <code>**object**</code>。</p><p>所以，<code>**typeof**</code> 更适合判断基础类型，如果想进一步判断引用类型使用 <strong><code>instanceof</code></strong> 更适合</p><h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. <strong>instanceof</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Undefined</span>);         <span class="hljs-comment">// Undefined is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Null</span>);                   <span class="hljs-comment">// Null is not defined</span><br></code></pre></td></tr></table></figure><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的原型对象</p><p><code>instanceof</code> 可以准确地判断复杂<strong>引用数据类型</strong>，但是<strong>不能正确判断原始数据类型</strong>；</p><p><strong>注意：</strong>如果手动更改该原型对象，**<code>instanceof</code>**判断类型就不准确了。</p><p>源码实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 我们也可以试着实现一下 instanceof</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_instanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-comment">// 由于instance要检测的是某对象，需要有一个前置判断条件</span><br>    <span class="hljs-comment">//基本数据类型直接返回false</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">&#x27;object&#x27;</span> || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 获得类型的原型</span><br>    <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-comment">// 获得对象的原型</span><br>    left = left.<span class="hljs-property">__proto__</span><br>    <span class="hljs-comment">// 判断对象的类型是否等于类型的原型</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> (prototype === left)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    left = left.<span class="hljs-property">__proto__</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. <strong>constructor</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong><code>constructor</code></strong> 通过原型链查找实例的构造函数从而来判断数据类型，它既可以判断原始数据类型，也可以判断引用数据类型。</p><p><strong>注意：</strong>如果手动更改该原型对象，<code>**constructor**</code>判断类型就不准确了。</p><h3 id="4-Object-prototype-toString-call"><a href="#4-Object-prototype-toString-call" class="headerlink" title="4.Object.prototype.toString.call()"></a>4.<strong>Object.prototype.toString.call()</strong></h3><p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，可以统一返回格式为 <code>“[object Xxx]”</code>的字符串，其中 <code>Xxx</code>就是对象的类型。</p><p><strong>对于 <code>Object</code>对象，直接调用 <code>toString()</code> 就能返回 <code>[objectObject]</code>；而对于其他对象，则需要通过 <code>call</code>来调用，才能返回正确的类型信息</strong>。我们来看一下代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(&#123;&#125;)       <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;)  <span class="hljs-comment">// 同上结果，加上call也ok</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>)    <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;1&#x27;</span>)  <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)  <span class="hljs-comment">// &quot;[object Function]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>)   <span class="hljs-comment">//&quot;[object Null]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">//&quot;[object Undefined]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-regexp">/123/g</span>)    <span class="hljs-comment">//&quot;[object RegExp]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) <span class="hljs-comment">//&quot;[object Date]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([])       <span class="hljs-comment">//&quot;[object Array]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">document</span>)  <span class="hljs-comment">//&quot;[object HTMLDocument]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">window</span>)   <span class="hljs-comment">//&quot;[object Window]&quot;</span><br></code></pre></td></tr></table></figure><p>目前这个方法也是最为准确和完美的方法。</p><h3 id="5-全局通用数据类型判断方法"><a href="#5-全局通用数据类型判断方法" class="headerlink" title="5.全局通用数据类型判断方法"></a>5.全局通用数据类型判断方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">obj</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\[object (\S+)\]$/</span>, <span class="hljs-string">&#x27;$1&#x27;</span>); <br> <span class="hljs-comment">// 注意正则中间有个空格</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th></th><th>typeof</th><th>instanceof</th><th>constructor</th><th>Object.prototype.toString.call()</th></tr></thead><tbody><tr><td>底层机制</td><td>基于数据值的二进制</td><td>原型链</td><td>原型链</td><td>原型链</td></tr><tr><td>缺点</td><td>不适合检测引用类型和null类型</td><td>不适合检测基本类型，易被篡改</td><td>易被篡改</td><td>暂无</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用git命令</title>
    <link href="/2022/09/27/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/27/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h1><h2 id="一、创建版本库"><a href="#一、创建版本库" class="headerlink" title="一、创建版本库"></a><strong>一、创建版本库</strong></h2><h3 id="1-克隆远程仓库"><a href="#1-克隆远程仓库" class="headerlink" title="1. 克隆远程仓库"></a><strong>1. 克隆远程仓库</strong></h3><ul><li><strong>git clone <url></strong></li></ul><h3 id="2-初始化本地版本库"><a href="#2-初始化本地版本库" class="headerlink" title="2. 初始化本地版本库"></a><strong>2. 初始化本地版本库</strong></h3><ul><li><strong>git init</strong></li></ul><h2 id="二、修改和提交"><a href="#二、修改和提交" class="headerlink" title="二、修改和提交"></a><strong>二、修改和提交</strong></h2><h3 id="1-查看当前状态"><a href="#1-查看当前状态" class="headerlink" title="1. 查看当前状态"></a><strong>1. 查看当前状态</strong></h3><ul><li><strong>git status</strong></li></ul><h3 id="2-git-add-追踪文件"><a href="#2-git-add-追踪文件" class="headerlink" title="2. git add 追踪文件"></a><strong>2. git add 追踪文件</strong></h3><ul><li><strong>git add . 追踪所有改动的文件</strong></li><li><strong>git add &lt; file &gt; 追踪指定文件</strong></li></ul><h3 id="3-提交文件"><a href="#3-提交文件" class="headerlink" title="3. 提交文件"></a><strong>3. 提交文件</strong></h3><ul><li><strong>git commit -m “commit message” 提交所有更新过的文件</strong></li></ul><h2 id="三、分支"><a href="#三、分支" class="headerlink" title="三、分支"></a><strong>三、分支</strong></h2><h3 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1. 查看分支"></a><strong>1. 查看分支</strong></h3><ul><li><strong>git branch 查看本地所有分支</strong></li><li><strong>git branch -r 查看远程所有分支</strong></li><li><strong>git branch -a 查看本地和远程所有分支</strong></li></ul><h3 id="2-删除分支"><a href="#2-删除分支" class="headerlink" title="2. 删除分支"></a><strong>2. 删除分支</strong></h3><ul><li><strong>git branch -d <branch> 删除本地分支</strong></li><li><strong>git branch -D <branch> 强制删除本地分支</strong></li></ul><h3 id="3-创建分支"><a href="#3-创建分支" class="headerlink" title="3. 创建分支"></a><strong>3. 创建分支</strong></h3><p><strong>① 创建本地分支</strong></p><ul><li><strong>git branch <new-branch> 创建新分支但不切换到新分支</strong></li><li><strong>git checkout -b <new-branch>创建新分支并切换到新分支</strong></li></ul><p><strong>② 创建远程分支</strong></p><ul><li><strong>git push origin <local-branch> （本地创建分支后推送过去远程就会新建分支）</strong></li></ul><h3 id="4-切换分支-（重要）"><a href="#4-切换分支-（重要）" class="headerlink" title="4. 切换分支 （重要）"></a><strong>4. 切换分支 （重要）</strong></h3><ul><li><strong>git checkout <branch> （优先切换本地分支，没有会检查是否有远程分支，有则会拉取远程分支并在本地创建同名分支。本地和远程都没有则会报错）</strong></li></ul><h3 id="5-合并分支"><a href="#5-合并分支" class="headerlink" title="5. 合并分支"></a><strong>5. 合并分支</strong></h3><ul><li><strong>git merge <branch > 合并分支（将<branch> 合并到当前分支）</strong></li></ul><h2 id="四、存储和恢复进度"><a href="#四、存储和恢复进度" class="headerlink" title="四、存储和恢复进度"></a><strong>四、存储和恢复进度</strong></h2><h3 id="1-保存进度"><a href="#1-保存进度" class="headerlink" title="1. 保存进度"></a><strong>1. 保存进度</strong></h3><ul><li><strong>git stash save “save message”将文件给放到一个临时空间中（仅缓存到当前分支，不用担心在别的分支stash时，给覆盖掉）</strong></li></ul><h3 id="2-恢复进度"><a href="#2-恢复进度" class="headerlink" title="2. 恢复进度"></a><strong>2. 恢复进度</strong></h3><ul><li><strong>git stash pop 将文件从临时空间pop下来（仅缓存到当前分支，不用担心把别的分支stash的内容pop出来，给覆盖掉）</strong></li></ul><h3 id="3-查看存储列表"><a href="#3-查看存储列表" class="headerlink" title="3. 查看存储列表"></a><strong>3. 查看存储列表</strong></h3><ul><li><strong>git stash list 查看已经存储的列表（同理）</strong></li></ul><h2 id="五、远程操作"><a href="#五、远程操作" class="headerlink" title="五、远程操作"></a><strong>五、远程操作</strong></h2><h3 id="1-下载代码"><a href="#1-下载代码" class="headerlink" title="1. 下载代码"></a><strong>1. 下载代码</strong></h3><ul><li><strong>git fetch 将远程主机的最新内容拉到本地</strong></li><li><strong>git fetch origin <branch> 将远程某个分支更新到本地</strong></li></ul><h3 id="2-下载并合并代码"><a href="#2-下载并合并代码" class="headerlink" title="2. 下载并合并代码"></a><strong>2. 下载并合并代码</strong></h3><ul><li><strong>git pull 默认拉取远程与本地track的分支并合并</strong></li><li><strong>git pull origin &lt; branch&gt; 拉取指定远程分支并合并</strong></li></ul><h3 id="3-上传代码并合并"><a href="#3-上传代码并合并" class="headerlink" title="3. 上传代码并合并"></a><strong>3. 上传代码并合并</strong></h3><ul><li><strong>git push 默认将本地仓库的代码push到与远程track的仓库并合并</strong></li><li><strong>git push origin <branch> 将代码上传到指定远程仓库并合并</strong></li></ul><h2 id="六、查看提交记录"><a href="#六、查看提交记录" class="headerlink" title="六、查看提交记录"></a><strong>六、查看提交记录</strong></h2><h3 id="1-查看提交历史（主要在回退时使用，获取HEAD）"><a href="#1-查看提交历史（主要在回退时使用，获取HEAD）" class="headerlink" title="1. 查看提交历史（主要在回退时使用，获取HEAD）"></a><strong>1. 查看提交历史（主要在回退时使用，获取HEAD）</strong></h3><ul><li><strong>git log 查看提交历史</strong></li><li><strong>git log -p <file> 查看指定文件的提交历史</strong></li><li><strong>git blame <file> 以列表形式查看指定文件提交历史</strong></li></ul><h2 id="七、版本回退"><a href="#七、版本回退" class="headerlink" title="七、版本回退"></a><strong>七、版本回退</strong></h2><h3 id="1-撤销"><a href="#1-撤销" class="headerlink" title="1. 撤销"></a><strong>1. 撤销</strong></h3><ul><li><strong>git reset –hard HEAD 撤销工作目录中所有未提交文件的修改内容</strong></li><li><strong>git checkout Head <file> 撤销指定未提交文件的修改内容</strong></li><li><strong>git revert <commit> 撤销指定的提交</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS常用命名总结</title>
    <link href="/2022/09/27/CSS%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/27/CSS%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="css常用命名总结"><a href="#css常用命名总结" class="headerlink" title="css常用命名总结"></a>css常用命名总结</h1><h3 id="页面结构命名"><a href="#页面结构命名" class="headerlink" title="页面结构命名"></a><strong>页面结构命名</strong></h3><ol><li>page：代表整个页面，用于最外层。</li><li>wrap：外套，将所有元素包在一起的一个外围包，用于最外层</li><li>wrapper：页面外围控制整体布局宽度，用于最外层</li><li>container：一个整体容器，用于最外层</li><li>head、header：页头区域，用于头部</li><li>nav：导航条</li><li>content：内容，网站中最重要的内容区域，用于网页中部主体</li><li>main：网站中的主要区域（表示最重要的一块位置），用于中部主体内容</li><li>column：栏目</li><li>sidebar：侧栏</li><li>foot、footer：页尾、页脚。网站一些附加信息放置区域，（或命名为copyright）用于底部</li></ol><h3 id="导航命名"><a href="#导航命名" class="headerlink" title="导航命名"></a><strong>导航命名</strong></h3><ol><li>nav、navbar、navigation、nav-wrapper：导航条或导航包，代表横向导航</li><li>topnav：顶部导航</li><li>mainbav：主导航</li><li>subnav：子导航</li><li>sidebar：边导航</li><li>leftsidebar 或 sidebar_a ：左导航</li><li>rightsidebar 或 sidebar_b：右导航</li><li>title：标题</li><li>summary：摘要/li&gt;</li><li>menu：菜单。区域包含一般的链接和菜单</li><li>submenu：子菜单</li><li>drop：下拉</li><li>dorpmenu：下拉菜单</li><li>links：链接菜单</li></ol><h3 id="功能命名"><a href="#功能命名" class="headerlink" title="功能命名"></a><strong>功能命名</strong></h3><ol><li>logo：标记网站logo标志</li><li>banner：标语、广告条、顶部广告条</li><li>login：登陆，（例如登录表单：form-login）</li><li>loginbar：登录条</li><li>regsiter：注册</li><li>tool、toolbar：工具条</li><li>search：搜索</li><li>searchbar：搜索条</li><li>searchlnput：搜索输入框</li><li>shop：功能区，表示现在的</li><li>icon：小图标</li><li>label：商标</li><li>homepage：首页</li><li>subpage：二级页面子页面</li><li>hot：热门热点</li><li>list：文章列表，（例如新闻列表：list-news）</li><li>scroll:滚动</li><li>tab：标签</li><li>sitemap：网站地图</li><li>msg 或 message：提示信息</li><li>current：当前的</li><li>joinus：加入</li><li>status：状态</li><li>btn：按钮，（例如搜索按钮可写成：btn-search）</li><li>tips：小技巧</li><li>note：注释</li><li>guild：指南</li><li>arr、arrow：标记箭头</li><li>service：服务</li><li>breadcrumb：(即页面所处位置导航提示）</li><li>download：下载</li><li>vote：投票</li><li>siteinfo：网站信息</li><li>partner：合作伙伴</li><li>link、friendlink：友情链接</li><li>copyright：版权信息</li><li>siteinfoCredits：信誉</li><li>siteinfoLegal：法律信息</li><li>board：面板</li><li>card：卡片</li></ol><h3 id="CSS样式命名"><a href="#CSS样式命名" class="headerlink" title="CSS样式命名"></a><strong>CSS样式命名</strong></h3><ol><li>对齐样式命名：left（左边内容）、center（中间内容）、right（右边内容）等；</li><li>颜色英文命名：red（红色）、green（绿色）、yellow（黄色），又或者border_red（红色边框）等；</li><li>颜色代码命名：f00（红色）、ff0（黄色）、f90（橙色）等；</li><li>文字大小命名：font12px（字体12像素）、font16px（字体16像素）等；</li><li>页面线条命名：line_x （横线）、line_y （纵线）或 line_red（红线）、line_black（黑线）</li><li>图片图标命名：pic_1.jpg、pic_2.jpg 或 ico_1.gif、ico_2.gif</li><li>页面广告命名：ad_01、ad_02</li><li>背景框架命名：nav_bg（代表导航条的背景图片位置）、tool_bg（代表工具栏的背景图片位置）</li></ol><h3 id="CSS样式表命名"><a href="#CSS样式表命名" class="headerlink" title="CSS样式表命名"></a><strong>CSS样式表命名</strong></h3><ol><li>index.css：单独为首页建立样式</li><li>head.css：头部样式，多个页面头部设计风格相同时使用。</li><li>base.css：共用样式。</li><li>style.css：独立页面所使用的样式文件。</li><li>global.css：页面样式基础，全局公用样式，页面中必须包含。</li><li>layout.css：布局、版面样式，公用类型较多时使用，一般用在首页级页面和产品类页面中</li><li>module.css：模块，用于产品类页，也可与其它样式配合使用。</li><li>master.css：主要的样式表</li><li>columns.css：专栏样式</li><li>themes.css：主体样式</li><li>forms.css：表单样式</li><li>mend.css：补丁，基于以上样式进行的私有化修补。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/05/hello-world/"/>
    <url>/2022/05/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hello World</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
