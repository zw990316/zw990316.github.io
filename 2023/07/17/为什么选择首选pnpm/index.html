

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/head_img.png">
  <link rel="icon" href="/img/head_img.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="rgb(82,118,138)">
  <meta name="author" content="Vito">
  <meta name="keywords" content="">
  
    <meta name="description" content="为什么选择首选pnpm?这篇文章给大家分享一个业内一款出色的包管理器——pnpm。目前 GitHub 已经有 star 9.8k，现在已经相对成熟且稳定了。它由 npm&#x2F;yarn 衍生而来，但却解决了 npm&#x2F;yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。下面是本文的思维导图:  一、什么是 pnpm ?pnpm 的官方文档(https:&#x2F;&#x2F;pnpm.js.org&#x2F;en&#x2F;)">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么选择首选pnpm">
<meta property="og:url" content="http://example.com/2023/07/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E9%A6%96%E9%80%89pnpm/index.html">
<meta property="og:site_name" content="Vito&#39;s Blog">
<meta property="og:description" content="为什么选择首选pnpm?这篇文章给大家分享一个业内一款出色的包管理器——pnpm。目前 GitHub 已经有 star 9.8k，现在已经相对成熟且稳定了。它由 npm&#x2F;yarn 衍生而来，但却解决了 npm&#x2F;yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。下面是本文的思维导图:  一、什么是 pnpm ?pnpm 的官方文档(https:&#x2F;&#x2F;pnpm.js.org&#x2F;en&#x2F;)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1313648-20210225174230334-853579081.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174301546-870504832.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174325371-2122926684.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174423589-1848330844.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174453543-1691727439.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174508815-583671864.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174526027-1148614674.png">
<meta property="og:image" content="http://example.com/img/1313648-20210225174630884-216606871.png">
<meta property="article:published_time" content="2023-07-17T14:05:06.000Z">
<meta property="article:modified_time" content="2024-10-24T16:14:00.240Z">
<meta property="article:author" content="Vito">
<meta property="article:tag" content="包管理工具">
<meta property="article:tag" content="pnpm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/1313648-20210225174230334-853579081.png">
  
  
  
  <title>为什么选择首选pnpm - Vito&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Vito&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg8.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="为什么选择首选pnpm"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-17 22:05" pubdate>
          2023年7月17日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">为什么选择首选pnpm</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="为什么选择首选pnpm"><a href="#为什么选择首选pnpm" class="headerlink" title="为什么选择首选pnpm?"></a>为什么选择首选pnpm?</h1><p>这篇文章给大家分享一个业内一款出色的包管理器——<code>pnpm</code>。目前 GitHub 已经有 star 9.8k，现在已经相对成熟且稳定了。它由 npm/yarn 衍生而来，但却解决了 npm/yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。下面是本文的思维导图:</p>
<p><img src="/img/1313648-20210225174230334-853579081.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="一、什么是-pnpm"><a href="#一、什么是-pnpm" class="headerlink" title="一、什么是 pnpm ?"></a><strong>一、什么是 pnpm ?</strong></h2><p>pnpm 的官方文档(<a target="_blank" rel="noopener" href="https://pnpm.js.org/en/)%E6%98%AF%E8%BF%99%E6%A0%B7%E8%AF%B4%E7%9A%84">https://pnpm.js.org/en/)是这样说的</a>:</p>
<blockquote>
<p>Fast, disk space efficient package manager</p>
</blockquote>
<p>因此，pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它作为杀手锏的两个优势在于:</p>
<ul>
<li>包安装速度极快；</li>
<li>磁盘空间利用非常高效。</li>
</ul>
<p>它的安装也非常简单。可以有多简单?</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm i <span class="hljs-literal">-g</span> pnpm<br></code></pre></td></tr></table></figure>

<h2 id="二、特性概览"><a href="#二、特性概览" class="headerlink" title="二、特性概览"></a><strong>二、特性概览</strong></h2><h3 id="1-速度快"><a href="#1-速度快" class="headerlink" title="1. 速度快"></a><strong>1. 速度快</strong></h3><p>pnpm 安装包的速度究竟有多快？先以 React 包为例来对比一下:</p>
<p><img src="/img/1313648-20210225174301546-870504832.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，作为黄色部分的 pnpm，在绝多大数场景下，包安装的速度都是明显优于 npm/yarn，速度会比 npm/yarn 快 2-3 倍。</p>
<p>对 yarn 比较熟悉的同学可能会说，yarn 不是有 <code>PnP 安装模式</code>(<a target="_blank" rel="noopener" href="https://classic.yarnpkg.com/en/docs/pnp/)%E5%90%97%EF%BC%9F%E7%9B%B4%E6%8E%A5%E5%8E%BB%E6%8E%89">https://classic.yarnpkg.com/en/docs/pnp/)吗？直接去掉</a> node_modules，将依赖包内容写在磁盘，节省了 node 文件 I/O 的开销，这样也能提升安装速度。（具体原理见这篇文章(<a target="_blank" rel="noopener" href="https://loveky.github.io/2019/02/11/yarn-pnp/)%EF%BC%89">https://loveky.github.io/2019/02/11/yarn-pnp/)）</a></p>
<p>接下来，我们以这样一个仓库(<a target="_blank" rel="noopener" href="https://github.com/pnpm/benchmarks-of-javascript-package-managers)%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E4%B8%80%E7%9C%8B">https://github.com/pnpm/benchmarks-of-javascript-package-managers)为例，我们来看一看</a> benchmark 数据，主要对比一下 <code>pnpm</code> 和 <code>yarn PnP</code>:</p>
<p><img src="/img/1313648-20210225174325371-2122926684.png" srcset="/img/loading.gif" lazyload></p>
<p>从中可以看到，总体而言，<code>pnpm</code> 的包安装速度还是明显优于 <code>yarn PnP</code>的。</p>
<h3 id="2-高效利用磁盘空间"><a href="#2-高效利用磁盘空间" class="headerlink" title="2. 高效利用磁盘空间"></a><strong>2. 高效利用磁盘空间</strong></h3><p>pnpm 内部使用<code>基于内容寻址</code>的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:</p>
<ul>
<li>不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 <code>hardlink</code>(硬链接，不清楚的同学详见这篇文章(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html))%E3%80%82">https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html))。</a></li>
<li>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 <code>hardlink</code>，仅仅写入那<code>一个新增的文件</code>。</li>
</ul>
<h3 id="3-支持-monorepo"><a href="#3-支持-monorepo" class="headerlink" title="3. 支持 monorepo"></a><strong>3. 支持 monorepo</strong></h3><p>随着前端工程的日益复杂，越来越多的项目开始使用 <code>monorepo</code>。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 <code>monorepo</code> 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的<code>packages</code>目录下，那么一个子项目就代表一个<code>package</code>。如果你之前没接触过 <code>monorepo</code> 的概念，建议仔细看看这篇文章(<a target="_blank" rel="noopener" href="https://www.perforce.com/blog/vcs/what-monorepo)%E4%BB%A5%E5%8F%8A%E5%BC%80%E6%BA%90%E7%9A%84">https://www.perforce.com/blog/vcs/what-monorepo)以及开源的</a> <code>monorepo</code> 管理工具<code>lerna</code>(<a target="_blank" rel="noopener" href="https://github.com/lerna/lerna#readme)%EF%BC%8C%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%B8%80%E4%B8%8B">https://github.com/lerna/lerna#readme)，项目目录结构可以参考一下</a> <code>babel 仓库</code>(<a target="_blank" rel="noopener" href="https://github.com/babel/babel)%E3%80%82">https://github.com/babel/babel)。</a></p>
<p><code>pnpm</code> 与 <code>npm/yarn</code> 另外一个很大的不同就是支持了 <code>monorepo</code>，体现在各个子命令的功能上，比如在根目录下 <code>pnpm add A -r</code>, 那么所有的 <code>package</code> 中都会被添加 A 这个依赖，当然也支持 <code>--filter</code>字段来对 package 进行过滤。</p>
<h3 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a><strong>4. 安全性高</strong></h3><p>之前在使用 npm/yarn 的时候，由于 <code>node_module</code> 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。但 pnpm 脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性，具体怎么体现<code>安全</code>、规避非法访问依赖的<code>风险</code>的，后面再来详细说说。</p>
<h2 id="三、依赖管理"><a href="#三、依赖管理" class="headerlink" title="三、依赖管理"></a><strong>三、依赖管理</strong></h2><h3 id="npm-yarn-install-原理"><a href="#npm-yarn-install-原理" class="headerlink" title="npm/yarn install 原理"></a><strong>npm/yarn install 原理</strong></h3><p>主要分为两个部分, 首先，执行 npm/yarn install之后，<code>包如何到达项目 node_modules 当中</code>。其次，node_modules <code>内部如何管理依赖</code>。</p>
<p>执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:</p>
<ul>
<li><ol>
<li>将依赖包的版本区间解析为某个具体的版本号</li>
</ol>
</li>
<li><ol start="2">
<li>下载对应版本依赖的 tar 包到本地离线镜像</li>
</ol>
</li>
<li><ol start="3">
<li>将依赖从离线镜像解压到本地缓存</li>
</ol>
</li>
<li><ol start="4">
<li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li>
</ol>
</li>
</ul>
<p>然后，对应的包就会到达项目的<code>node_modules</code>当中。</p>
<p>那么，这些依赖在<code>node_modules</code>内部是什么样的目录结构呢，换句话说，项目的依赖树是什么样的呢？</p>
<p>在 <code>npm1</code>、<code>npm2</code> 中呈现出的是嵌套结构，比如下面这样:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">node_modules<br>└─ foo<br>   ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>   ├─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>   └─ node_modules<br>      └─ <span class="hljs-keyword">bar</span><br><span class="hljs-keyword"></span>         ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>         └─ package.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure>

<p>如果 <code>bar</code> 当中又有依赖，那么又会继续嵌套下去。试想一下这样的设计存在什么问题:</p>
<ol>
<li>依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下。</li>
<li>大量重复的包被安装，文件体积超级大。比如跟 <code>foo</code> 同级目录下有一个<code>baz</code>，两者都依赖于同一个版本的<code>lodash</code>，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。</li>
<li>模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。</li>
</ol>
<p>接着，从 npm3 开始，包括 yarn，都着手来通过<code>扁平化依赖</code>的方式来解决这个问题。相信大家都有这样的体验，我明明就装个 <code>express</code>，为什么 <code>node_modules</code>里面多了这么多东西？</p>
<p><img src="/img/1313648-20210225174423589-1848330844.png" srcset="/img/loading.gif" lazyload></p>
<p>没错，这就是<code>扁平化</code>依赖管理的结果。相比之前的<code>嵌套结构</code>，现在的目录结构类似下面这样:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">node_modules<br>├─ foo<br>|  ├─ <span class="hljs-keyword">index</span>.js<br>|  └─ package.json<br>└─ bar<br>   ├─ <span class="hljs-keyword">index</span>.js<br>   └─ package.json<br></code></pre></td></tr></table></figure>

<p>所有的依赖都被拍平到<code>node_modules</code>目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的<code>node_modules</code>当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p>
<p>之前的问题是解决了，但仔细想想这种<code>扁平化</code>的处理方式，它真的就是无懈可击吗？并不是。它照样存在诸多问题，梳理一下:</p>
<ol>
<li>依赖结构的<strong>不确定性</strong>。</li>
<li>扁平化算法本身的<strong>复杂性</strong>很高，耗时较长。</li>
<li>项目中仍然可以<strong>非法访问</strong>没有声明过依赖的包</li>
</ol>
<p>后面两个都好理解，那第一点中的<code>不确定性</code>是什么意思？这里来详细解释一下。</p>
<p>假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的:</p>
<p><img src="/img/1313648-20210225174453543-1691727439.png" srcset="/img/loading.gif" lazyload></p>
<p>那么 npm/yarn install 的时候，通过扁平化处理之后，究竟是这样</p>
<p><img src="/img/1313648-20210225174508815-583671864.png" srcset="/img/loading.gif" lazyload></p>
<p>还是这样？</p>
<p><img src="/img/1313648-20210225174526027-1148614674.png" srcset="/img/loading.gif" lazyload></p>
<p>答案是: 都有可能。取决于 foo 和 bar 在 <code>package.json</code>中的位置，如果 foo 声明在前面，那么就是前面的结构，否则是后面的结构。</p>
<p>这就是为什么会产生依赖结构的<code>不确定</code>问题，也是 <code>lock 文件</code>诞生的原因，无论是<code>package-lock.json</code>(npm 5.x才出现)还是<code>yarn.lock</code>，都是为了保证 install 之后都产生确定的<code>node_modules</code>结构。</p>
<p>尽管如此，npm/yarn 本身还是存在<code>扁平化算法复杂</code>和<code>package 非法访问</code>的问题，影响性能和安全。</p>
<h3 id="pnpm-依赖管理"><a href="#pnpm-依赖管理" class="headerlink" title="pnpm 依赖管理"></a><strong>pnpm 依赖管理</strong></h3><p>pnpm 的作者<code>Zoltan Kochan</code>发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器，开创了一套新的依赖管理机制，现在就让我们去一探究竟。</p>
<p>还是以安装 <code>express</code> 为例，我们新建一个目录，执行:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm init <span class="hljs-literal">-y</span><br></code></pre></td></tr></table></figure>

<p>然后执行:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm install express<br></code></pre></td></tr></table></figure>

<p>我们再去看看<code>node_modules</code>:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.pnpm<br>.modules.yaml<br>express<br></code></pre></td></tr></table></figure>

<p>我们直接就看到了<code>express</code>，但值得注意的是，这里仅仅只是一个<code>软链接</code>，不信你打开看看，里面并没有 node_modules 目录，如果是真正的文件位置，那么根据 node 的包加载机制，它是找不到依赖的。那么它真正的位置在哪呢？</p>
<p>我们继续在 .pnpm 当中寻找:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs powershell">▾ node_modules<br>  ▾ .pnpm<br>    ▸ accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span><br>    ▸ array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span><br>    ...<br>    ▾ express@<span class="hljs-number">4.17</span>.<span class="hljs-number">1</span><br>      ▾ node_modules<br>        ▸ accepts<br>        ▸ array<span class="hljs-literal">-flatten</span><br>        ▸ body<span class="hljs-literal">-parser</span><br>        ▸ content<span class="hljs-literal">-disposition</span><br>        ...<br>        ▸ etag<br>        ▾ express<br>          ▸ lib<br>            History.md<br>            index.js<br>            LICENSE<br>            package.json<br>            Readme.md<br></code></pre></td></tr></table></figure>

<p>好家伙！竟然在 <code>.pnpm/express@4.17.1/node_modules/express</code>下面找到了!</p>
<p>随便打开一个别的包:</p>
<p><img src="/img/1313648-20210225174630884-216606871.png" srcset="/img/loading.gif" lazyload></p>
<p>好像也都是一样的规律，都是<code>&lt;package-name&gt;@version/node_modules/&lt;package-name&gt;</code>这种目录结构。并且 express 的依赖都在<code>.pnpm/express@4.17.1/node_modules</code>下面，这些依赖也全都是<strong>软链接</strong>。</p>
<p>再看看<code>.pnpm</code>，<code>.pnpm</code>目录下虽然呈现的是扁平的目录结构，但仔细想想，顺着<code>软链接</code>慢慢展开，其实就是嵌套的结构！</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">▾ node_modules<br>  ▾ .pnpm<br>    ▸ accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span><br>    ▸ array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span><br>    ...<br>    ▾ express@<span class="hljs-number">4.17</span>.<span class="hljs-number">1</span><br>      ▾ node_modules<br>        ▸ accepts  -&gt; ../accepts@<span class="hljs-number">1.3</span>.<span class="hljs-number">7</span>/node_modules/accepts<br>        ▸ array<span class="hljs-literal">-flatten</span> -&gt; ../array<span class="hljs-literal">-flatten</span>@<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>/node_modules/array<span class="hljs-literal">-flatten</span><br>        ...<br>        ▾ express<br>          ▸ lib<br>            History.md<br>            index.js<br>            LICENSE<br>            package.json<br>            Readme.md<br></code></pre></td></tr></table></figure>

<p>将<code>包本身</code>和<code>依赖</code>放在同一个<code>node_module</code>下面，与原生 Node 完全兼容，又能将 package 与相关的依赖很好地组织到一起，设计十分精妙。</p>
<p>现在我们回过头来看，根目录下的 node_modules 下面不再是眼花缭乱的依赖，而是跟 <code>package.json</code> 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 <code>node_modules</code> 当中，但整体上，根目录的<code>node_modules</code>比以前还是清晰和规范了许多。</p>
<h2 id="四、再谈安全"><a href="#四、再谈安全" class="headerlink" title="四、再谈安全"></a><strong>四、再谈安全</strong></h2><p>不知道你发现没有，pnpm 这种依赖管理的方式也很巧妙地规避了<code>非法访问依赖</code>的问题，也就是只要一个包未在 package.json 中声明依赖，那么在项目中是无法访问的。</p>
<p>但在 npm/yarn 当中是做不到的，那你可能会问了，如果 A 依赖 B， B 依赖 C，那么 A 就算没有声明 C 的依赖，由于有依赖提升的存在，C 被装到了 A 的<code>node_modules</code>里面，那我在 A 里面用 C，跑起来没有问题呀，我上线了之后，也能正常运行啊。不是挺安全的吗？</p>
<p>还真不是。</p>
<p>第一，你要知道 B 的版本是可能随时变化的，假如之前依赖的是<code>C@1.0.1</code>，现在发了新版，新版本的 B 依赖 <code>C@2.0.1</code>，那么在项目 A 当中 <code>npm/yarn install</code> 之后，装上的是 2.0.1 版本的 C，而 A 当中用的还是 C 当中旧版的 API，可能就直接报错了。</p>
<p>第二，如果 B 更新之后，可能不需要 C 了，那么安装依赖的时候，C 都不会装到<code>node_modules</code>里面，A 当中引用 C 的代码直接报错。</p>
<p>还有一种情况，在 monorepo 项目中，如果 A 依赖 X，B 依赖 X，还有一个 C，它不依赖 X，但它代码里面用到了 X。由于依赖提升的存在，npm/yarn 会把 X 放到根目录的 node_modules 中，这样 C 在本地是能够跑起来的，因为根据 node 的包加载机制，它能够加载到 monorepo 项目根目录下的 node_modules 中的 X。但试想一下，一旦 C 单独发包出去，用户单独安装 C，那么就找不到 X 了，执行到引用 X 的代码时就直接报错了。</p>
<p>这些，都是依赖提升潜在的 bug。如果是自己的业务代码还好，试想一下如果是给很多开发者用的工具包，那危害就非常严重了。</p>
<p><code>npm</code> 也有想过去解决这个问题，指定<code>--global-style</code>参数即可禁止变量提升，但这样做相当于回到了当年嵌套依赖的时代，一夜回到解放前，前面提到的嵌套依赖的缺点仍然暴露无遗。</p>
<p><code>npm/yarn</code> 本身去解决依赖提升的问题貌似很难完成，不过社区针对这个问题也已经有特定的解决方案: <strong>dependency-check</strong>，地址: <a target="_blank" rel="noopener" href="https://github.com/dependency-check-team/dependency-check">https://github.com/dependency-check-team/dependency-check</a></p>
<p>但不可否认的是，pnpm 做的更加彻底，独创的一套依赖管理方式不仅解决了依赖提升的安全问题，还大大优化了时间和空间上的性能。</p>
<h2 id="五、日常使用"><a href="#五、日常使用" class="headerlink" title="五、日常使用"></a><strong>五、日常使用</strong></h2><p>说了这么多，估计你会觉得 <code>pnpm</code> 挺复杂的，是不是用起来成本很高呢？</p>
<p>恰好相反，pnpm 使用起来十分简单，如果你之前有 <code>npm/yarn</code> 的使用经验，甚至可以无缝迁移到 pnpm 上来。不信我们来举几个日常使用的例子。</p>
<h3 id="1-pnpm-install"><a href="#1-pnpm-install" class="headerlink" title="1. pnpm install"></a><strong>1. pnpm install</strong></h3><p>跟 npm install 类似，安装项目下所有的依赖。但对于 monorepo 项目，会安装 workspace 下面所有 packages 的所有依赖。不过可以通过 –filter 参数来指定 package，只对满足条件的 package 进行依赖安装。</p>
<p>当然，也可以这样使用，来进行单个包的安装:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// 安装 axios<br>pnpm install axios<br>// 安装 axios 并将 axios 添加至 devDependencies<br>pnpm install axios <span class="hljs-literal">-D</span><br>// 安装 axios 并将 axios 添加至 dependencies<br>pnpm install axios <span class="hljs-literal">-S</span><br></code></pre></td></tr></table></figure>

<p>当然，也可以通过 –filter 来指定 package。</p>
<h3 id="2-pnpm-update"><a href="#2-pnpm-update" class="headerlink" title="2. pnpm update"></a><strong>2. pnpm update</strong></h3><p>根据指定的范围将包更新到最新版本，monorepo 项目中可以通过 –filter 来指定 package。</p>
<h3 id="3-pnpm-uninstall"><a href="#3-pnpm-uninstall" class="headerlink" title="3. pnpm uninstall"></a><strong>3. pnpm uninstall</strong></h3><p>在 node_modules 和 package.json 中移除指定的依赖。monorepo 项目同上。举例如下:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// 移除 axios<br>pnpm uninstall axios <span class="hljs-literal">--filter</span> package<span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure>

<h3 id="4-pnpm-link"><a href="#4-pnpm-link" class="headerlink" title="4. pnpm link"></a><strong>4. pnpm link</strong></h3><p>将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链接。如:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm link ../../axios<br></code></pre></td></tr></table></figure>

<p>另外，对于我们经常用到<code>npm run/start/test/publish</code>，这些直接换成 pnpm 也是一样的，不再赘述。更多的使用姿势可参考官方文档: <a target="_blank" rel="noopener" href="https://pnpm.js.org/en/">https://pnpm.js.org/en/</a></p>
<p>可以看到，虽然 pnpm 内部做了非常多复杂的设计，但实际上对于用户来说是无感知的，使用起来非常友好。并且，现在作者现在还一直在维护，目前 npm 上周下载量已经有 10w +，经历了大规模用户的考验，稳定性也能有所保障。</p>
<p>因此，综合来看，pnpm 是一个相比 npm/yarn 更优的方案，期待未来 pnpm 能有更多的落地。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cangqinglang/p/14448329.html">https://www.cnblogs.com/cangqinglang/p/14448329.html</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" class="category-chain-item">包管理工具</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" class="print-no-link">#包管理工具</a>
      
        <a href="/tags/pnpm/" class="print-no-link">#pnpm</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>为什么选择首选pnpm</div>
      <div>http://example.com/2023/07/17/为什么选择首选pnpm/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Vito</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/30/nvm%E7%89%88%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%92%8C%E8%B8%A9%E5%9D%91/" title="nvm版本管理工具使用和踩坑">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">nvm版本管理工具使用和踩坑</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/10/yapi%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/" title="yapi部署踩坑总结">
                        <span class="hidden-mobile">yapi部署踩坑总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
